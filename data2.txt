1.2.变量与算术表达式
另一个较为严重的问题是,由于我们使用的是整型算术运算,因此经计算得到的摄氏温度值不太精确,例如,与0T对应的精确的摄氏温度应该为-17.8℃,而不是-17℃。为了得到更精确的结果,应该用浮点算术运算代替上面的整型算术运算。这就需要对程序做适当修改。下面是该程序的又一种版本
这个程序与前一个程序基本相同,不同的是,它把fahr与celsius声明为float类型,转换公式的表述方式也更自然一些。在前一个程序中,之所以不能使用5/9的形式,
是因为按整型除法的计算规则,它们相除并舍位后得到的结果为0。但是,常数中的小数点表明该常数是一个浮点数,因此,5.0/9.0是两个浮点数相除,结果将不被舍位。
如果某个算术运算符的所有操作数均为整型,则执行整型运算。但是,如果某个算术运算符有一个浮点型操作数和一个整型操作数,则在开始运算之前整型操作数将会被转换为浮点型。例如,在表达式fahr–32中,32在运算过程中将被自动转换为浮点数再参与运算。不过,即使浮点常量取的是整型值,在书写时最好还是为它加上一个显式的小数点,这样可以强调其浮点性质,便于阅读。
第2章将详细介绍把整型数转换为浮点型数的规则。在这里需要注意,赋值语句fahr=lower;
与条件测试语句
也都是按照这种方式执行的,即在运算之前先把int类型的操作数转换为float类型的操作数。
printf中的转换说明%3.0f表明待打印的浮点数(即fahr)至少占3个字符宽,且不带小数点和小数部分;%6.1f表明另一个待打印的数(celsius)至少占6个字符宽,且小数点后面有1位数字。其输出如下所示:
格式说明可以省略宽度与精度,例如,%6f表示待打印的浮点数至少有6个字符宽;%.2f指定待打印的浮点数的小数点后有两位小数,但宽度没有限制;%f则仅仅要求按照浮点数打印该数。
%d按照十进制整型数打印
%6d按照十进制整型数打印,至少6个字符宽
%f按照浮点数打印
%6f按照浮点数打印,至少6个字符宽
%.2f按照浮点数打印,小数点后有两位小数
%6.2f按照浮点数打印,至少6个字符宽,小数点后有两位小数
此外,printf函数还支持下列格式说明:%o表示八进制数;%x表示十六进制数;%c表示字符;%s表示字符串;%%表示百分号(%)本身。
练习1-3修改温度转换程序,使之能在转换表的顶部打印一个标题。
练习1-4编写一个程序打印摄氏温度转换为相应华氏温度的转换表。
1.3.for语句
对于某个特定任务我们可以采用多种方法来编写程序。下面这段代码也可以实现前面的温度转换程序的功能:
这个程序与上节中介绍的程序执行结果相同,但程序本身却有所不同。最主要的改进在于它去掉了大部分变量,而只使用了一个int类型的变量fahr。在新引入的for语句中,温度的下限、上限和步长都是常量,而计算摄氏温度的表达式现在变成了printf函数的第三个参数,它不再是一个单独的赋值语句。
以上几点改进中的最后一点是C语言中一个通用规则的实例:在允许使用某种类型变量值的任何场合,都可以使用该类型的更复杂的表达式。因为printf函数的第三个参数必须是与%6.1f匹配的浮点值,所以可以在此处使用任何浮点表达式。
for语句是一种循环语句,它是对while语句的推广。如果将for语句与前面介绍的while语句比较,就会发现for语句的操作更直观一些。圆括号中共包含3个部分,各部分之间用分号隔开。第一部分
fahr=0
是初始化部分,仅在进入循环前执行一次。第二部分fahr<=300
是控制循环的测试或条件部分。循环控制将对该条件求值,如果结果值为真(true),则执行循环体(本例中的循环体仅包含一个printf函数调用语句)。此后将执行第三部分
fahr=fahr+20
以将循环变量fahr增加一个步长,并再次对条件求值。如果计算得到的条件值为假(faise),循环将终止执行。与while语句一样,for循环语句的循环体可以只有一条语句,也可以是用花括号括起来的一组语句。初始化部分(第一部分)、条件部分(第二部分)与增加步长部分(第三部分)都可以是任何表达式。
在实际编程过程中,可以选择whi1e与for中的任意一种循环语句,主要要看使用哪一种更清晰。for语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形,因为它将循环控制语句集中放在一起,且比while语句更紧凑。
练习1-5修改温度转换程序,要求以逆序(即按照从300度到0度的顺序)打印温
度转换表。
1.4.符号常量
在结束讨论温度转换程序前,我们再来看一下符号常量。在程序中使用300、20等类似的“幻数”并不是一个好习惯,它们几乎无法向以后阅读该程序的人提供什么信息,而且使程序的修改变得更加困难。处理这种幻数的一种方法是赋予它们有意义的名字。#define指令可以把符号名(或称为符号常量)定义为一个特定的字符串:
#define名字替换文本
在该定义之后,程序中出现的所有在#define中定义的名字(既没有用引号引起来,也不是其它名字的一部分)都将用相应的替换文本替换。其中,名字与普通变量名的形式相同:它们都是以字母打头的字母和数字序列;替换文本可以是任何字符序列,而不仅限于数字。
1.5.字符输入/输出
接下来我们看一组与字符型数据处理有关的程序。读者将会发现,许多程序只不过是这里所讨论的程序原型的扩充版本而已。
标准库提供的输入/输出模型非常简单。无论文本从何处输入,输出到何处,其输入/输出都是按照字符流的方式处理。文本流是由多行字符构成的字符序列,而每行字符则由0个或多个字符组成,行末是一个换行符。标准库负责使每个输入/输出流都能够遵守这一模型。使用标准库的C语言程序员不必关心在程序之外这些行是如何表示的。
标准库提供了一次读/写一个字符的函数,其中最简单的是getchar和putchar两个函数。每次调用时,getchar函数从文本流中读入下一个输入字符,并将其作为结果值返回。
也就是说,在执行语句c=getchar()
之后,变量c中将包含输入流中的下一个字符。这种字符通常是通过键盘输入的。关于从文件输入字符的方法,我们将在第7章中讨论。
每次调用putchar函数时将打印一个字符。例如,语句putchar()
将把整型变量c的内容以字符的形式打印出来,通常是显示在屏幕上。putchar与printf这两个函数可以交替调用,输出的次序与调用的次序一致。
1.5.1.文件复制
借助于getchar与putchar函数,可以在不了解其它输入/输出知识的情况下编写出数量惊人的有用的代码。最简单的例子就是把输入一次一个字符地复制到输出,其基本思想如下:
读一个字符
while(该字符不是文件结束指示符)输出刚读入的字符
读下一个字符
将上述基本思想转换为C语言程序为:#include<stdio.h>
其中,关系运算符!=表示“不等于”。
字符在键盘、屏幕或其它的任何地方无论以什么形式表现,它在机器内部都是以位模式存储的。char类型专门用于存储这种字符型数据,当然任何整型(int)也可以用于存储字符型数据。因为某些潜在的重要原因,我们在此使用int类型。
这里需要解决如何区分文件中有效数据与输入结束符的问题。C语言采取的解决方法是:在没有输入时,getchar函数将返回一个特殊值,这个特殊值与任何实际字符都不同。这个值称为EOF(endoffile,文件结束)。我们在声明变量c的时候,必须让它大到足以存放getchar函数返回的任何值。这里之所以不把c声明成char类型,是因为它必须足够大,除了能存储任何可能的字符外还要能存储文件结束符EOF。因此,我们将c声明成int类型。
EOF定义在头文件<stdio.h>中,是个整型数,其具体数值是什么并不重要,只要它与任何char类型的值都不相同即可。这里使用符号常量,可以确保程序不需要依赖于其对应的任何特定的数值。
对于经验比较丰富的C语言程序员,可以把这个字符复制程序编写得更精炼一些。在C语言中,类似于
c=getchar()
之类的赋值操作是一个表达式,并且具有一个值,即赋值后左边变量保存的值。也就是说,赋值可以作为更大的表达式的一部分出现。如果将为c赋值的操作放在while循环语句的测试部分中,上述字符复制程序便可以改写成下列形式:
在该程序中,while循环语句首先读一个字符并将其赋值给c,然后测试该字符是否为文件结束标志。如果该字符不是文件结束标志,则执行while语句体,并打印该字符。随后重复执行while语句。当到达输入的结尾位置时,while循环语句终止执行,从而整个main函数执行结束。
以上这段程序将输入集中化,getchar函数在程序中只出现了一次,这样就缩短了程序,整个程序看起来更紧凑。习惯这种风格后,读者就会发现按照这种方式编写的程序更易阅读。我们经常会看到这种风格。(不过,如果我们过多地使用这种类型的复杂语句,编写的程序可能会很难理解,应尽量避免这种情况。)
对while语句的条件部分来说,赋值表达式两边的圆括号不能省略。不等于运算符!=的优先级比赋值运算符=的优先级要高,这样,在不使用圆括号的情况下关系测试!=将在赋值=操作之前执行。因此语句
c=getchar()!=EOF等价于语句
c=(getchar()!=EOF)
该语句执行后,c的值将被置为0或1(取决于调用getchar函数时是否碰到文件结束标志),这并不是我们所希望的结果(更详细的内容,请参见第2章的相关部分)。
练习1-6验证表达式getchar()!=EOF的值是0还是1。
练习1-7编写一个打印EOF值的程序。
1.5.2.字符计数
下列程序用于对字符进行计数,它与上面的复制程序类似。#include<stdio.h>
其中,语句
引入了一个新的运算符++,其功能是执行加1操作。可以用语句nc=nc+1代替它,但语句++nc更精炼一些,且通常效率也更高。与该运算符相应的是自减运算符--。++与--这两个运算符既可以作为前缀运算符(如++nc),也可以作为后缀运算符(如nc++)。我们在第2章中将看到,这两种形式在表达式中具有不同的值,但++nc与nc++都使nc的值增加1。目前,我们只使用前缀形式。
该字符计数程序使用long类型的变量存放计数值,而没有使用int类型的变量。long整型数(长整型)至少要占用32位存储单元。在某些机器上int与long类型的长度相同,但在一些机器上,int类型的值可能只有16位存储单元的长度(最大值为32767),这样,相当小的输入都可能使int类型的计数变量溢出。转换说明%ld告诉printf函数其对应的参数是long整型。
使用double(双精度浮点数)类型可以处理更大的数字。我们在这里不使用while循环语句,而用for循环语句来展示编写此循环的另一种方法:
对于float与double类型。printf函数都使用%f进行说明。%.0f强制不打印小数点和小数部分,因此小数部分的位数为0。
在该程序段中,for循环语句的循环体是空的,这是因为所有工作都在测试(条件)部分与增加步长部分完成了。但C语言的语法规则要求for循环语句必须有一个循环体,因此用单独的分号代替。单独的分号称为空语句,它正好能满足for语句的这一要求。把它单独放在一行是为了更加醒目。
在结束讨论字符计数程序之前,我们考虑以下情况:如果输入中不包含字符,那么,在第一次调用getchar函数的叫候,while语句或for语句中的条件测试从一开始就为假,程序的执行结果将为0,这也是正确的结果。这一点很重要。whi1e语句与for语句的优点之一就是在执行循环体之前就对条件进行测试,如果条件不满足,则不执行循环体,这就可能出现循环体一次都不执行的情况。在出现0长度的输入时,程序的处理应该灵活一些,在出现边界条件时,while语句与for语句有助于确保程序执行合理的操作。
1.5.3.行计数
接下来的这个程序用于统计输入中的行数。我们在上面提到过,标准库保证输入文本流以行序列的形式出现,每一行均以换行符结束。因此,统计行数等价于统计换行符的个数。
在该程序中,while循环语句的循环体是一个if语句,它控制自增语句++nl。if语句先测试圆括号中的条件,如果该条件为真,则执行其后的语句(或括在花括号中的一组语句)。这里再次用缩进方式表明语句之间的控制关系。
双等于号==是C语言中表示“等于”关系的运算符(类似于Pascal中的单等于号=及Fortran中的.EQ.)。由于C语言将单等于号=作为赋值运算符,因此使用双等于号==表示相等的逻辑关系,以示区分。这里提醒注意,在表示“等于”逻辑关系的时候(应该用==),C语言初学者有时会错误地写成单等于号=。在第2章我们将看到,即使这样误用了,其结果通常仍然是合法的表达式,因此系统不会给出警告信息。
单引号中的字符表示一个整型值,该值等于此字符在机器字符集中对应的数值,我们称之为字符常量。但是,它只不过是小的整型数的另一种写法而已。例如,'A'是一个字符常量;在ASCII字符集中其值为65(即字符A的内部表示值为65)。当然,用'A'要比用65好,因为。'A'的意义更清楚,且与特定的字符集无关。
字符串常量中使用的转义字符序列也是合法的字符常量,比如,'\n'代表换行符的值,在ASCII字符集中其值为10。我们应当注意到,'\n'是单个字符,在表达式中它不过是一个整型数而已;而"\n"是一个仅包含一个字符的字符串常量。有关字符串与字符之间的关系,我们将在第2章进一步讨论。
练习1-8编写一个统计空格、制表符与换行符个数的程序。
练习1-9编写一个将输入复制到输出的程序,并将其中连续的多个空格用一个空格代
替。
练习1-10编写一个将输入复制到输出的程序,并将其中的制表符替换为\t,把回退符替换为\b,把反斜杠替按为\\。这样可以将制表符和回退符以可见的方式显示出来。
程序执行时,每当遇到单词的第一个字符,它就作为一个新单词加以统计。state变量记录程序当前是否正位于一个单词之中,它的初值是“不在单词中”,即初值被赋为OUT。我们在这里使用了符号常量IN与OUT,而没有使用其对应的数值1与0,这样程序更易读。在较小的程序中,这种做法也许看不出有什么优势,但在较大的程序中,如果从一开始就这样做,因此而增加的一点工作量与提高程序可读性带来的好处相比是值得的。读者也会发现,如果程序中的幻数都以符号常量的形式出现,对程序进行大量修改就会相对容易得多。
下列语句
nl=nw=nc=0;
将把其中的3个变量nl、nw与nc都设置为0。这种用法很常见,但要注意这样一个事实:在兼有值与赋值两种功能的表达式中,赋值结合次序是由右至左。所以上面这条语句等同于
n1=(nw=(nc=0));
运算符||代表OR(逻辑或),所以下列语句
if(c==''||c=='\n'||c=='\t')
的意义是“如果c是空格,或c是换行符,或c是制表符”(前面讲过,转义字符序列\t是制表符的可见表示形式)。相应地,运算符&&代表AND(逻辑与),它仅比||高一个优先级。由&&或||连接的表达式由左至右求值,并保证在求值过程中只要能够判断最终的结果为真或假,求值就立即终止。如果c是空格,则没有必要再测试它是否为换行符或制表符,这样就不必执行后面两个测试。在这里,这一点并不特别重要,但在某些更复杂的情况下这样做就有必要了,不久我们将会看到这种例子。
这段程序中还包括一个else部分,它指定当if语句中的条件部分为假时所要执行的动作。其一般形式为:
if(表述式)语句1
else
其中,if-else中的两条语句有且仅有一条语句被执行。如果表达式的值为真,则执行语句1,否则执行语句2。这两条语句都既可以是单条语句,也可以是括在花括号内的语句序列。在单词计数程序中,else之后的语句仍是一个if语句,该if语句控制了包含在花括号内的两条语句。
练习1-11你准备如何测试单词计数程序?如果程序中存在某种错误,那么什么样的输入最可能发现这类错误呢’
练习1-12编写一个程序,以每行一个单词的形式打印其输入。
1.6.数组
在这部分内容中,我们来编写一个程序,以统计各个数字、空白符(包括空格符、制表符及换行符)以及所有其它字符出现的次数。这个程序的实用意义并不大,但我们可以通过该程序讨论C语言多方面的问题。
所有的输入字符可以分成12类,因此可以用一个数组存放各个数字出现的次数,这样比使用10个独立的变量更方便。下面是该程序的一种版本:
当把这段程序本身作为输入时,输出结果为:
digits=9300000001,whitespace=123,other=345
该程序中的声明语句intndigit[10],
将变量ndigit声明为由10个整型数构成的数组。在C语言中,数组下标总是从0开始,因
此该数组的10个元素分别为ndigit[0]、ndiglt[1]、…、ndigit[9],这可以通过初始化和打印数组的两个for循环语句反映出来。
数组下标可以是任何整型表达式,包括整型变量(如i)以及整型常量。该程序的执行取决于数字的字符表示属性。例如,测试语句
if(c>='0'&&c<='9')
用于判断c中的字符是否为数字。如果它是数字,那么该数字对应的数值是c-'0'
只有当'0'、'1'、…、'9'具有连续递增的值时,这种做法才可行。幸运的是,所有的字符集都是这样的。
由定义可知,char类型的字符是小整型,因此char类型的变量和常量在算术表达式中等价于int类型的变量和常量。这样做既自然又方便,例如,c-'0'是一个整型表达式,如果存储在c中的字符是'0'~'9',其值将为0~9,因此可以充当数组ndigit的合法下标。
判断一个字符是数字、空白符还是其它字符的功能可以由下列语句序列完成:
if(c>='0'&&c<='9')
++ndigit[c-'0'];
elseif(c==''||c=='\n'||c=='\t')
++nwhite;
else
++nother;
程序中经常使用下列方式表示多路判定:
if(条件1)语句1
elseif(条件1)语句2
...
...
else
语句n
在这种方式中,各条件从前往后依次求值,直到满足某个条件,然后执行对应的语句部分。这部分语句执行完成后,整个语句体执行结束(其中的任何语句都可以是括在花括号中的若干条语句)。如果所有条件都不满足,则执行位于最后一个else之后的语句(如果有的话)。类似于前面的单词计数程序,如果没有最后一个else及对应的语句,该语句体将不执行任何动作。在第一个if与最后一个else之间可以有0个或多个下列形式的语句序列:
elseif(条件)语句
就程序设计风格而言,我们建议读者采用上面所示的缩进格式以体现该结构的层次关系,否则,如果每个if都比前一个else向里缩进一些距离,那么较长的判定序列就可能超出页面的右边界。
第3章将讨论的switch语句提供了编写多路分支程序的另一种方式,它特别适合于判定某个整型或字符表达式是否与一个常量集合中的某个元素相匹配的情况。我们将在3.4节给
出用switch语句编写的该程序的另一个版本,与此进行比较。
练习1-13编写一个程序,打印输入中单词长度的直方图。水平方向的直方图比较容易绘制,垂直方向的直方图则要困难些。
练习1-14编写一个程序,打印输入中各个字符出现频度的直方图。
1.7.函数
C语言中的函数等价于Fortran语言中的子程序或函数,也等价于Pascal语言中的过程或函数。函数为计算的封装提供了一种简便的方法,此后使用函数时不需要考虑它是如何实现的。使用设计正确的函数,程序员无需考虑功能是如何实现的,而只需知道它具有哪些功能就够了。在C语言中可以简单、方便、高效地使用函数。我们经常会看到在定义后仅调用了一次的短函数,这样做可以使代码段更清晰易读。
到目前为止,我们所使用的函数(如printf、getchar和putchar等)都是函数库中提供的函数。现在,让我们自己动手来编写一些函数。C语言没有像Fortran语言一样提供类似于**的求幂运算符,我们现在通过编写一个求幂的函数power(m,n)来说明函数定义的方法。power(m,n)函数用于计算整数m的n次幂,其中n是正整数。对函数调用power(2,5)来说,其结果值为32。该函数并非一个实用的求幂函数,它只能处理较小的整数的正整数次幂,但这对于说明问题已足够了。(标准库中提供了一个计算xy的函数pow(x,y)。)
下面是函数power(m,n)的定义及调用它的主程序,这样我们可以看到一个完整的程序结构。
函数定义的一般形式为:
返回值类型函数名(0个或多个参数声明)
{
声明部分
语句序列}
函数定义可以以任意次序出现在一个源文件或多个源文件中,但同一函数不能分割存放在多个文件中。如果源程序分散在多个文件中,那么,在编译和加载时,就需要做更多的工作,但这是操作系统的原因,并不是语言的属性决定的。我们暂且假定将main和power这两个函数放在同一文件中,这样前面所学的有关运行C语言程序的知识仍然有效。
main函数在下列语句中调用了两次power函数:
printf("%d%d%d\n",i,power(2,i),power(-i,3));
每次调用时,main函数向power函数传递两个参数;在调用执行完成时,power函数向main函数返回一个格式化的整数并打印。在表达式中,power(2,i)同2和i一样都是整数(并不是所有函数的结果都是整型值,我们将在第4章中讨论)。
power函数的第一行语句
intpower(intbase,intn)
声明参数的类型、名字以及该函数返回结果的类型。power函数的参数使用的名字只在power函数内部有效,对其它任何函数都是不可见的:其它函数可以使用与之相同的参数名字而不会引起冲突。变量i与p也是这样:power函数中的i与main函数中的i无关。
我们通常把函数定义中圆括号内列表中出现的变量称为形式参数,而把函数调用中与形式参数对应的值称为实际参数。
power函数计算所得的结果通过return语句返回给main函数。关键字return的后面可以跟任何表达式,形式为:
return表达式;
函数不一定都有返回值。不带表达式的return语句将把控制权返回给调用者,但不返回有用的值。这等同于在到达函数的右终结花括号时,函数就“到达了尽头”。主调函数也可以忽略函数返回的值。
读者可能已经注意到,main函数的末尾有一个return语句。由于main本身也是函数,因此也可以向其调用者返回一个值,该调用者实际上就是程序的执行环境。一般来说,返回值为0表示正常终止,返回值为非0表示出现异常情况或出错结束条件。为简洁起见,前面的main函数都省略了return语句,但我们将在以后的main函数中包含return语句,以提醒大家注意,程序还要向其执行环境返回状态。
出现在main函数之前的声明语句intpower(intm,intn);
表明power函数有两个int类型的参数,并返回一个int类型的值。这种声明称为函数原型,它必须与power函数的定义和用法一致。如果函数的定义、用法与函数原型不一致,将出现错误。
函数原型与函数声明中参数名不要求相同。事实上,函数原型中的参数名是可选的,这样上面的函数原型也可以写成以下形式
intpower(int,int);
但是,合适的参数名能够起到很好的说明性作用,因此我们在函数原型中总是指明参数名。
回顾一下,ANSIC同较早版本C语言之间的最大区别在于函数的声明与定义方式的不同。按照C语言的最初定义,power函数应该写成下列形式:
其中,参数名在圆括号内指定,参数类型在左花括号之前声明。如果没有声明某个参数的类型,则默认为int类型。函数体与ANSIC中形式相同。
在C语言的最初定义中,可以在程序的开头按照下面这种形式声明power函数:intpower();
函数声明中不允许包含参数列表,这样编译器就无法在此时检查power函数调用的合法性。事实上,power函数在默认情况下将被假定返回int类型的值,因此整个函数的声明可以全部省略。
在ANSIC中定义的函数原型语法中,编译器可以很容易检测出函数调用中参数数目和类型方面的错误。ANSIC仍然支持旧式的函数声明与定义,这样至少可以有一个过渡阶段。但我们还是强烈建议读者:在使用新式的编译器时,最好使用新式的函数原型声明方式。
练习1-15重新编写1.2节中的温度转换程序,使用函数实现温度转换计算。
1.8.参数——传值调用
习惯其它语言(特别是Fortran语言)的程序员可能会对C语言的函数参数传递方式感到陌生。在C语言中,所有函数参数都是“通过值”传递的。也就是说,传递给被调用函数的参数值存放在临时变量中,而不是存放在原来的变量中。这与其它某些语言是不同的,比如,Fortran等语言是“通过引用调用”,Pascal则采用var参数的方式,在这些语言中,被调用的函数必须访问原始参数,而不是访问参数的本地副本。
最主要的区别在于,在C语言中,被调用函数不能直接修改主调函数中变量的值,而只能修改其私有的临时副本的值。
传值调用的利大于弊。在被调用函数中,参数可以看作是便于初始化的局部变量,因此额外使用的变量更少。这样程序可以更紧凑简洁。侧如,下面的这个power函数利用了这一性质:
其中,参数n用作临时变量,并通过随后执行的for循环语句递减,直到其值为0,这样就不需要额外引入变量i;power函数内部对n的任何操作不会影响到调用函数中n的原始参数值。
必要时,也可以让函数能够修改主调函数中的变量。这种情况下,调用者需要向被调用函数提供待设置值的变量的地址(从技术角度看,地址就是指向变量的指针),而被调用函数则需要将对应的参数声明为指针类型,并通过它间接访问变量。我们将在第5章中讨论指针。
如果是数组参数,情况就有所不同了。当把数组名用作参数时,传递给函数的值是数组起始元素的位置或地址——它并不复制数组元素本身。在被调用函数中,可以通过数组下标访问或修改数组元索的值。这是下一节将要讨论的问题。
1.9.字符数组
字符数组是C语言中最常用的数组类型。下面我们通过编写一个程序,来说明字符数组以及操作字符数组的函数的用法。该程序读入一组文本行,并把最长的文本行打印出来。该算法的基本框架非常简单:
while(还有未处理的行)
if(该行比已处理的最长行还要长)保存该行为最长行
保存该行的长度打印最长的行
从上面的框架中很容易看出,程序很自然地分成了若干片断,分别用于读入新行、测试读入的行、保存该行,其余部分则控制这一过程。
因为这种划分方式比较合理,所以可以按照这种方式编写程序。首先,我们编写一个独立的函数getline,它读取输入的下一行。我们尽量保持该函数在其它场台也有用。至少getline函数应该在读到文件末尾时返回一个信号;更为有用的设计是它能够在读入文本行时返回该行的长度,而在遇到文件结束符时返回0。由于0不是有效的行长度,因此可以作为标志文件结束的返回值。每一行至少包括一个字符,只包含换行符的行,其长度为1。
当发现某个新读入的行比以前读入的最长行还要长时,就需要把该行保存起来。也就是说,我们需要用另一个函数copy把新行复制到一个安全的位置。
最后,我们需要在主函数main中控制getline和copy这两个函数。以下便是我们编写的程序:
程序的开始对getline和copy这两个函数进行了声明,这里假定它们都存放在同一个文件中。
main与getline之间通过一对参数及一个返回值进行数据交换。在getline函数中,两个参数是通过程序行
intgetline(chars[],intlim)
声明的,它把第一个参数s声明为数组,把第二个参数lim声明为整型,声明中提供数组大小的目的是留出存储空间。在getline函数中没有必要指明数组s的长度,这是因为该数组
的大小是在main函数中设置的。如同power函数一样,getline函数使用了一个return语句将值返回给其调用者。上述程序行也声明了getline数的返回值类型为int。由于函数的默认返回值类型为int,因此这里的int可以省略。
有些函数返回有用的值,而有些函数(如copy)仅用于执行一些动作,并不返回值。copy函数的返回值类型为void,它显式说明该函数不返回任何值。
getline函数把字符'\0'(即空字符,其值为0)插入到它创建的数组的末尾,以标记字符串的结束。这一约定已被C语言采用:当在C语言程序中出现类似于
"hello\0"
的字符串常量时,它将以字符数组的形式存储,数组的各元素分别存储字符串的各个字符,并以'\0'标志字符串的结束。
printf函数中的格式规范%s规定,对应的参数必须是以这种形式表示的字符串。copy函数的实现正是依赖于输入参数由'\0'结束这一事实,它将'\0'拷贝到输出参数中。(也就是说,空字符'\0'不是普通文本的一部分。)
值得一提的是,即使是上述这样很小的程序,在传递参数时也会遇到一些麻烦的设计问题。例如,当读入的行长度大于允许的最大值时,main函数应该如何处理,getline函数的执行是安全的,无论是否到达换行符字符,当数组满时它将停止读字符。main函数可以通过测试行的长度以及检查返回的最后一个字符来判定当前行是否太长,然后再根据具体的情况处理。为了简化程序,我们在这里不考虑这个问题。
调用getline函数的程序无法预先知道输入行的长度,因此getline函数需要检查是否溢出。另一方面,调用copy函数的程序知道(也可以找出)字符串的长度,因此该函数不需要进行错误检查。
练习1-16修改打印最长文本行的程序的主程序main,使之可以打印任意长度的输入行的长度,并尽可能多地打印文本。
练习1-17编写一个程序,打印长度大于80个字符的所有输入行。
练习1-18编写一个程序,删除每个输入行末尾的空格及制表符,并删除完全是空格的
行。
练习1-19编写函数reverse(s),将字符串s中的字符顺序颠倒过来。使用该函数编写一个程序,每次颠倒一个输入行中的字符顺序。
1.10.外部变量与作用域
main函数中的变量(如line、longest等)是main函数的私自变量或局部变量。由于它们是在main函数中声明的,因此其它函数不能直接访问它们。其它函数中声明的变量也同样如此。例如,getline函数中声明的变量i与copy函数中声明的变量i没有关系。函数中的每个局部变量只在函数被调用时存在,在函数执行完毕退出时消失。这也是其它语言
通常把这类变量称为自动变最的原因。以后我们使用“自动变量”代表“局部变量”。(第4章将讨论static存储类,这种类型的局部变量在多次函数调用之间保持值不变。)
由于自动变量只在函数调用执行期间存在,因此,在函数的两次调用之间,自动变量不保留前次调用时的赋值,且在每次进入函数时都要显式为其赋值。如果自动变量没有赋值,则其中存放的是无效值。
除自动变量外,还可以定义位于所有函数外部的变量,也就是说,在所有函数中都可以通过变量名访问这种类型的变量(这机制同Fortran语言中的COMMON变量或Pascal语言中最外层程序块声明的变量非常类似)。由于外部变量可以在全局范围内访问,因此,函数间可以通过外部变量交换数据,而不必使用参数表。再者,外部变量在程序执行期间一直存在,而不是在函数调用时产生、在函数执行完毕时消失。即使在对外部变量赋值的函数返回后,这些变量仍将保持原来的值不变。
外部变量必须定义在所有函数之外,且只能定义一次,定义后编译程序将为它分配存储单元。在每个需要访问外部变量的函数中,必须声明相应的外部变量,此时说明其类型。声明时可以用extern语句显式声明,也可以通过上下文隐式声明。为了更详细地讨论外部变量,我们改写上述打印最长文本行的程序,把line、longest与max声明成外部变量。这需要修改这3个函数的调用、声明与函数体。
在该例子中,前几行定义了main、getline与copy函数使用的几个外部变量,声明了各外部变量的类型,这样编译程序将为它们分配存储单元。从语法角度看,外部变量的定义与局部变量的定义是相同的,但由于它们位于各函数的外部,因此这些变量是外部变量。函数在使用外部变量之前,必须要知道外部变量的名字。要达到该目的,一种方式是在函数中使用extern类型的声明。这种类型的声明除了在前面加了一个关键字extern外,其它方面与普通变量的声明相同。
某些情况下可以省略extern声明。在源文件中,如果外部变量的定义出现在使用它的函数之前,那么在那个函数中就没有必要使用extern声明。因此,main、getline及copy中的几个extern声明都是多余的。在通常的做法中,所有外部变量的定义都放在源文件的开始处,这样就可以省略extern声明。
如果程序包含在多个源文件中,而某个变量在file1文件中定义、在file2和file3文件中使用,那么在文件file2与file3中就需要使用extern声明来建立该变量与其定义之间的联系。人们通常把变量和函数的extern声明放在一个单独的文件中(习惯上称之为头文件),并在每个源文件的开头使用#include语句把所要用的头文件包含进来。后缀名.h约定为头文件名的扩展名。例如,标准库中的函数就是在类似于<stdio.h>的头文件中声明的。更详细的信息将在第4章中讨论,第7章及附录B将讨论函数库。
在上述特别版本中,由于getline与copy函数都不带参数,因此从逻辑上讲,在源文件开始处它们的原型应该是getline()与copy()。但为了与老版本的C语言程序兼容,ANSIC语言把空参数表看成老版本C语言的声明方式,并且对参数表不再进行任何检查。在ANSIC中,如果要声明空参数表,则必须使用关键字void进行显式声明。第4章将对此进一步讨论。
读者应该注意到,这节中我们在谈论外部变量时谨慎地使用了定义(define)与声明(declaration)这两个词。“定义”表示创建变量或分配存储单元,而“声明”指的是说明变量的性质,但并不分配存储单元。
顺便提一下,现在越来越多的人把用到的所有东西都作为外部变量使用,因为似乎这样可以简化数据的通信——参数表变短了,且在需要时总可以访问这些变量。但是,即使在不使用外部变量的时候,它们也是存在的。过分依赖外部变量会导致一定的风险,因为它会使程序中的数据关系模糊不清——外部变量的值可能会被意外地或不经意地修改,而程序的修改又变得十分困难。我们前面编写的打印最长文本行的程序的第2个版本就不如第1个版本好,原因有两方面,其一便是使用了外部变量;另一方面,第2个版本中的函数将它们所操纵的变量名直接写入了函数,从而使这两个有用的函数失去了通用性。
到目前为止,我们已经对C语言的传统核心部分进行了介绍。借助于这些少量的语言元素,我们已经能够编写出相当规模的有用的程序。建议读者花一些时间编写程序作为练习。下面的几个练习比本章前面编写的程序要复杂一些。
练习1-20编写程序detab,将输入中的制表符替换成适当数目的空格,使空格充满到下一个制表符终止位的地方。假设制表符终止位的位置是固定的,比如每隔n列就会出现一个制表符终止位。n应该作为变量还是符号常量呢?
练习1-21编写程序entab,将空格串替换为最少数量的制表符和空格,但要保持单词之间的间隔不变。假设制表符终止位的位置与练习1-20的detab程序的情况相同。当使用一个制表符或者一个空格都可以到达下一个制表符终止位时,选用哪一种替换字符比较好?
练习1-22编写一个程序,把较长的输入行“折”成短一些的两行或多行,折行的位置在输入行的第n列之前的最后一个非空格之后。要保证程序能够智能地处理输入行很长以及在指定的列前没有空格或制表符时的情况。
练习1-23编写一个删除C语言程序中所有的注释语句。要正确处理带引号的字符串与字符常量。在C语言中,注释不允许嵌套。
练习1-24编写一个程序,查找C语言程序中的基本语法错误,如圆括号、方括号、花括号不配对等。要正确处理引号(包括单引号和双引号)、转义字符序列与注释。(如果读者想把该程序编写成完全通用的程序,难度会比较大。)
第2章类型、运算符与表达式
变量和常量是程序处理的两种基本数据对象。声明语句说明变量的名字及类型,也可以指定变量的初值。运算符指定将要进行的操作。表达式则把变量与常量组合起来生成新的值。对象的类型决定该对象可取值的集合以及可以对该对象执行的操作。本章将详细讲述这些内容。
ANSI标准对语言的基本类型与表达式做了许多小的修改与增补。所有整型都包括signed(带符号)和unsigned(无符号)两种形式,且可以表示无符号常量与十六进制字符常量。浮点运算可以以单精度进行,还可以使用更高精度的longdouble类型运算。字符串常量可以在编译时连接。ANSIC还支持枚举类型,该语言特性经过了长期的发展才形成。对象可以声明为const(常量)类型,表明其值不能修改。该标准还对算术类型之间的自动强制转换规则进行了扩充,以适合于更多的数据类型。
2.1.变量名
对变量的命名与符号常量的命名存在一些限制条件,这一点我们在第1章没有说明。名字是由字母和数字组成的序列,但其第一个字符必须为字母。下划线“_”被看做是字母,通常用于命名较长的变量名,以提高其可读性。由于例程的名字通常以下划线开头,因此变量名不要以下划线开头。大写字母与小写字母是有区别的,所以,x与X是两个不同的名字。在传统的C语言用法中,变量名使用小写字母,符号常量名全部使用大写字母。
对于内部名而言,至少前31个字符是有效的。函数名与外部变量名包含的字符数目可能小于31,这是因为汇编程序和加载程序可能会使用这些外部名,而语言本身是无法控制加载和汇编程序的。对于外部名,ANSI标准仅保证前6个字符的惟一性,并且不区分大小写。类似于if、else、int、float等关键字是保留给语言本身使用的,不能把它们用做变量名。所有关健字中的字符都必须小写。
选择的变量名要能够尽量从字面上表达变量的用途,这样做不容易引起混淆。局部变量一般使用较短的变量名(尤其是循环控制变量),外部变量使用较长的名字。
2.2.数据类型及长度
C语言只提供了下列几种基本数据类型:
char字符型,占用一个字节,可以存放本地字符集中的一个字符
int整型,通常反映了所用机器中整数的最自然长度
float单精度浮点型
double双精度浮点型
此外,还可以在这些基本数据类型的前面加上一些限定符。short与long两个限定符用于限定整型:
shortintsh;
longintcounter;
在上述这种类型的声明中,关键字int可以省略。通常很多人也习惯这么做。
short与long两个限定符的引入可以为我们提供满足实际需要的不同长度的整型数。int通常代表特定机器中整数的自然长度。short类型通常为16位,1ong类型通常为32位,int类型可以为16位或32位。各编译器可以根据硬件特性自主选择合适的类型长度,但要遵循下列限制:short与int类型至少为16位,而long类型至少为32位,并且short类型不得长于int类型,而int类型不得长于long类型。
类型限定符signed与unsigned可用于限定char类型或任何整型。unsigned类型的数总是正值或0,并遵守算术模2n定律,其中n是该类型占用的位数。例如,如果char对象占用8位,那么unsignedchar类型变量的取值范围为0~255,而signedchar类型变量的取值范围则为-128~127(在采用对二的补码的机器上)。不带限定符的char类型对象是否带符号则取决于具体机器,但可打印字符总是正值。
longdouble类型表示高精度的浮点数。同整型一样,浮点型的长度也取决于具体的实现。float、double与longdouble类型可以表示相同的长度,也可以表示两种或三种不同的长度。
有关这些类型长度定义的符号常量以及其它与机器和编译器有关的属性可以在标准头文件<limits.h>与<float.h>中找到,这些内容将在附录B中讨论。
练习2-1编写一个程序以确定分别由signed及unsigned限定的char、short、int与long类型变量的取值范围。采用打印标准头文件中的相应值以及直接计算两种方式实现。后一种方法的实现较困难一些,因为要确定各种浮点类型的取值范围。
2.3.常量
类似于1234的整数常量属于int类型。long类型的常量以字母l或L结尾,如123456789L。如果一个整数太大以至于无法用int类型表示时,也将被当作long类型处理。无符号常量以字母u或U结尾。后缀ul或UL表明是unsignedlong类型。
浮点数常量中包含一个小数点(如123.4)或一个指数(如1e-2),也可以两者都有。没有后缀的浮点数常量为double类型。后缀f或F表示float类型,而后缀l或L则表示longdouble类型。
整型数除了用十进制表示外,还可以用八进制或十六进制表示。带前缀0的整型常量表示它为八进制形式;前缀为0x或0X,则表示它为十六进制形式。例如,十进制数31可以写成八进制形式037,也可以写成十六进制形式0x1f或0X1F。八进制与十六进制的常量也可以使用后缀L表示long类型,使用后缀U表示unsigned类型。例如,0XFUL是一个unsignedlong类型(无符号长整型)的常量,其值等于十进制数15。
一个字符常量是一个整数,书写时将一个字符括在单引号中,如,'x'。字符在机器字符集中的数值就是字符常量的值。例如,在ASCII字符集中,字符'0'的值为48,它与数值0没有关系。如果用字符'0'代替这个与具体字符集有关的值(比如48),那么,程序就无需关心该字符对应的具体值,增加了程序的易读性。字符常量一般用来与其它字符进行比较,但也可以像其它整数一样参与数值运算,
某些字符可以通过转义字符序列(例如,换行符\n)表示为字符和字符串常量。转义字符序列看起来像两个字符,但只表示一个字符。另外,我们可以用
'\ooo'
表示任意的字节大小的位模式。其中,ooo代表1~3个八进制数字(0…7)。这种位模式还可以用
'\xhh'
表示,其中,hh是一个或多个十六进制数字(0…9,a…f,A…F)。因此,我们可以按照下列形式书写语句:
反斜杠问号
单引号双引号
八进制数
十六进制数
字符常量'\0'表示值为0的字符,也就是空字符(null)。我们通常用'\0'的形式代替0,以强调某些表达式的字符属性,但其数字值为0。
常量表达式是仅仅只包含常量的表达式。这种表达式在编译时求值,而不在运行时求值。它可以出现在常量可以出现的任何位置,例如:
#defineMAXLINE1000
charline[MAXLINE+1];或
#defineLEAP1/*inleapyears*/
intdays[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
字符串常量也叫字符串字面值,是用双引号括起来的0个或多个字符组成的字符序列。例如:
"Iamastring"或
""/*空字符串*/
都是字符串。双引号不是字符串的一部分,它只用于限定字符串。字符常量中使用的转义字符序列同样也可以用在字符串中。在字符串中使用\"表示双引号字符。编译时可以将多个字符串常量连接起来,例如,下列形式:
"hello,""world"
等价于
"hello,world"
字符串常量的连接为将较长的字符串分散在若干个源文件行中提供了支持。
从技术角度看,字符串常量就是字符数组。字符串的内部表示使用一个空字符'\0'作为串的结尾,因此。存储字符串的物理存储单元数比括在双引号中的字符数多一个。这种表示方法也说明,C语言对字符串的长度没有限制,但程序必须扫描完整个字符串后才能确定字符串的长度。标准库函数strlen(s)可以返回字符串参数s的长度,但长度不包括末尾的'\0'。下面是我们设计的strlen函数的一个版本:
标准头文件<string.h>中声明了strlen和其它字符串函数。
我们应该搞清楚字符常量与仅包含一个字符的字符串之间的区别:'x'与"x"是不同的。前者是一个整数,其值是字母x在机器字符集中对应的数值(内部表示值);后者是一个包含一个字符(即字母x)以及一个结束符'\0'的字符数组。
枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表,例如:enumboolean{NO,YES};
在没有显式说明的情况下,enum类型中第一个枚举名的值为0,第二个为1,依此类推。如果只指定了部分枚举名的值,那么未指定值的枚举名的值将依着最后一个指定值向后递增,参看下面两个例子中的第二个例子:
不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值。
枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于#define语句来说,它的优势在于常量值可以自动生成。尽管可以声明enum类型的变量,但编译器不检查这种类型的变量中存储的值是否为该枚举的有效值。不过,枚举变量提供这种检查,因此枚举比#define更具优势。此外,调试程序可以以符号形式打印出枚举变量的值。
2.4.声明
所有变量都必须先声明后使用,尽管某些变量可以通过上下文隐式地声明。一个声明指定一种变量类型,后面所带的变量表可以包含一个或多个该类型的变量。例如:
intlower,upper,step;
charc,1ine[1000];
一个声明语句中的多个变量可以拆开在多个声明语句中声明。上面的两个声明语句也可以等价地写成下列形式:
按照这种形式书写代码需要占用较多的空间,但便于向各声明语句中添加注释,也便于以后修改。
还可以在声明的同时对变量进行初始化。在声明中,如果变量名的后面紧跟一个等号以及一个表达式,该表达式就充当对变量进行初始化的初始化表达式。例如:
如果变量不是自动变量,则只能进行一次初始化操作,从概念上讲,应该是在程序开始执行之前进行,并且初始化表达式必须为常量表达式。每次进入函数或程序块时,显式初始化的自动变量都将被初始化一次,其初始化表达式可以是任何表达式。默认情况下,外部变量与静态变量将被初始化为0。未经显式初始化的自动变量的值为未定义值(即无效值)。
任何变量的声明都可以使用const限定符限定。该限定符指定变量的值不能被修改。对数组而言,const限定符指定数组所有元素的值都不能被修改:
const限定符也可配合数组参数使用,它表明函数不能修改数组元素的值:intstrlen(constchar[]);
如果试图修改const限定符限定的值,其结果取决于具体的实现。
2.5.算术运算符
二元算术运算符包括:+、-、*、/、%(取模运算符)。整数除法会截断结果中的小数部分。表达式
x%y
的结果是x除以y的余数,当x能被y整除时,其值为0。例如,如果某一年的年份能被4整除但不能被100整除,那么这一年就是闰年,此外,能被400整除的年份也是闰年。因此,可以用下列语句判断闰年:
取模运算符%不能应用于float或double类型。在有负操作数的情况下,整数除法截取的方向以及取模运算结果的符号取决于具体机器的实现,这和处理上溢或下溢的情况是一样的。
二元运算符+和具有相同的优先级,它们的优先级比运算符*、/和%的优先级低,而运算符*、/和%的优先级又比一元运算符+和的优先级低。算术运算符采用从左到右的结合规则。
本章末尾的表2-1完整总结了所有运算符的优先级和结合律。
2.6.关系运算符与逻辑运算符
关系运算符包括下列几个运算符:>>=<<=
它们具有相同的优先级。优先级仅次于它们的是相等性运算符:==!=
关系运算符的优先级比算术运算符低。因此,表达式i<lim1等价于i<(lim1)。
逻辑运算符&&与||有一些较为特殊的属性,由&&与||连接的表达式按从左到右的顺序进行求值,并且,在知道结果值为真或假后立即停止计算。绝大多数C语言程序运用了这些属性。例如,下列在功能上与第1章的输入函数getline中的循环语句等价的循环语句:
for(i=0;i<lim1&&(c=getchar())!='\n'&&c!=EOF;++i)
s[i]=c;
在读入一个新字符之前必须先检查数组s中足否还有空间存放这个字符,因此必须首先测试条件i<lim1。如果这一测试失败,就没有必要继续读入下一字符。
类似地,如果在调用getchar函数之前就测试c是否为EOF,结果也是不正确的,因此,函数的调用与赋值都必须在对c中的字符进行测试之前进行。
运算符&&的优先级比||的优先级高,但两者都比关系运算符和相等性运算符的优先级低。因此,表达式
i<lim1&&(c=getchar())!='\n'&&c!=EOF
就不需要另外加圆括号。但是,由于运算符!=的优先级高于赋值运算符的优先级,因此,在表达式
(c=getchar())!='\n'
中,就需要使用圆括号,这样才能达到预期的目的:先把函数返回值赋值给c,然后再将c与'\n'进行比较。
根据定义,在关系表达式或逻辑表达式中,如果关系为真,则表达式的结果值为数值1;如果为假,则结果值为数值0。
逻辑非运算符!的作用是将非0操作数转换为0,将操作数0转换为1。该运算符通常用于下列类似的结构中:
if(!valid)
一般不采用下列形式:if(valid==0)
当然,很难评判上述两种形式哪种更好。类似于!valid的用法读起来更直观一些(“如果不是有效的”),但对于一些更复杂的结构可能会难于理解。
练习2-2在不使用运算符&&或||的条件下编写一个与上面的for循环语句等价的循
环语句。
2.7.类型转换
当一个运算符的几个操作数类型不同时,就需要通过一些规则把它们转换为某种共同的类型。一般来说,自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数,并且不丢失信息的转换,例如,在计算表达式f+i时,将整型变量i的值自动转换为浮点型(这里的变量f为浮点型)。不允许使用无意义的表达式,例如,不允许把float类型的表达式作为下标。针对可能导致信息丢失的表达式,编译器可能会给出警告信息,比如把较长的整型值赋给较短的整型变量,把浮点型值赋值给整型变量,等等,但这些表达式并不非法。
由于char类型就是较小的整型,因此在算术表达式中可以自由使用char类型的变量,这就为实现某些字符转换提供了很大的灵活性,比如,下面的函数atoi就是一例,它将一串数字转换为相应的数值:
我们在第1章讲过,表达式s[i]-'0'
能够计算出s[i]中存储的字符所对应的数字值,这是因为'0'、'l'等在字符集中对应的数值是一个连续的递增序列。
函数lower是将char类型转换为int类型的另一个例子,它将ASCII字符集中的字符映射到对应的小写字母。如果待转换的字符不是大写字母,lower函数将返回字符本身。
上述这个函数是为ASCII字符集设计的。在ASCII字符集中,大写字母与对应的小写字母作为数字值来说具有固定的间隔,并且每个字母表都是连续的——也就是说,在A~Z之间只有字母。但是,后面一点对EBCDIC字符集是不成立的,因此这一函数作用在EBCDIC字符集中就不仅限于转换字母的大小写。
附录B介绍的标准头文件<ctype.h>定义了一组与字符集无关的测试和转换函数。例如,tolower(c)函数将c转换为小写形式(如果c为大写形式的话),可以使用tolower替代上述lower函数。类似地,测试语句
c>='0'&&c<='9'
可以用该标准库中的函数isdigit(c)
替代。在本书的后续内容中,我们将使用<ctype.h>中定义的函数。
将字符类型转换为整型时,我们需要注意一点。C语言没有指定char类型的变量是无符号变量(signed)还是带符号变量(unsigned)。当把一个char类型的值转换为int类型的值时,其结果有没有可能为负整数?对于不同的机器,其结果也不同,这反映了不同机器结构之间的区别。在某些机器中,如果char类型值的最左一位为1,则转换为负整数(进行“符号扩展”)。而在另一些机器中,把char类型值转换为int类型时,在char类型值的左边添加0,这样导致的转换结果值总是正值。
C语言的定义保证了机器的标准打印字符集中的字符不会是负值,因此,在表达式中这些字符总是正值。但是,存储在字符变量中的位模式在某些机器中可能是负的,而在另一些机器上可能是正的。为了保证程序的可移植性,如果要在char类型的变量中存储非字符数据,最好指定signed或unsigned限定符。
当关系表达式(如i>j)以及由&&、||连接的逻辑表达式的判定结果为真时,表达式的值为1;当判定结果为假时,表达式的值为0。因此,对于赋值语句
d=c>='0'&&c<='9'
来说,当c为数字时,d的值为l,否则d的值为0。但是,某些函数(比如isdigit)在结果为真时可能返回任意的非0值。在if、while、for等语句的测试部分中,“真”就意味着“非0”,这二者之间没有区别。
C语言中,很多情况下会进行隐式的算术类型转换。一般来说,如果二元运算符(具有两个操作数的运算符称为二元运算符,比如+或*)的两个操作数具有不同的类型,那么在进行运算之前先要把“较低”的类型提升为“较高”的类型,运算的结果为较高的类型。附录A.6节详细地列出了这些转换规则。但是,如果没有unsigned类型的操作数,则只要使用下面这些非正式的规则就可以了:
.如果其中一个操作数的类型为longdouble,则将另一个操作数转换为1ongdouble类型;
.如果其中一个操作数的类型为double,则将另一个操作数转换为double类型;
.如果其中一个操作数的类型为float,则将另一个操作数转换为float类型;
.将char与short类型的操作数转换为int类型;
.如果其中一个操作数的类型为long,则将另一个操作数也转换为long类型。
注意,表达式中float类型的操作数不会自动转换为double类型,这一点与最初的定义有所不同。一般来说,数学函数(如标准头文件<math.h>中定义的函数)使用双精度类型的变量。使用float类型主要是为了在使用较大的数组时节省存储空间,有时也为了节省机器执行时间(双精度算术运算特别费时)。
当表达式中包含unsigned类型的操作数时,转换规则要复杂一些。主要原因在于,带符号值与无符号值之间的比较运算是与机器相关的,因为它们取决于机器中不同整数类型的大小。例如,假定int类型占16位,long类型占32位,那么,-1L<1U,这是因为unsighedint类型的1U将被提升为signedlong类型;但-1L>1UL,这是因为1L将被提升为unslgnedlong类型,因而成为一个比较大的正数。
赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型,左边变量的类型即赋值表达式结果的类型。
前面提到过,无论是否进行符号扩展,字符型变量都将被转换为整型变量。
当把较长的整数转换为较短的整数或char类型时,超出的高位部分将被丢弃。因此,下列程序段:
执行后,c的值将保持不变。无论是否进行符号扩展,该结论都成立。但是,如果把两个赋值语句的次序颠倒一下,则执行后可能会丢失信息。
如果x是float类型,i是int类型,那么语句x=i与i=x在执行时都要进行类型转换。当把float类型转换为int类型时,小数部分将被截取掉;当把double类型转换为float类型时,是进行四舍五入还是截取取决于具体的实现。
由于函数调用的参数是表达式,所以在把参数传递给函数时也可能进行类型转换。在没有函数原型的情况下,char与short类型都将被转换为int类型,float类型将被转换为double类型。因此,即使调用函数的参数为char或float类型,我们也把函数参数声明为int或double类型。
最后,在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换。在下列语句中,表达式将按照上述转换规则被转换为类型名指定的类型:
(类型名)表达式
我们可以这样来理解强制类型转换的准确含义:在上述语句中,表达式首先被赋值给类型名指定的类型的某个变量,然后再用该变量替换上述整条语句。例如,库函数sqrt的参数为double类型,如果处理不当,结果可能会无意义(sqrt在<math.h>中声明)。因此,如果n是整数,可以使用
在把n传递给函数sqrt之前先将其转换为double类型。注意,强制类型转换只是生成一个指定类型的n的值,n本身的值并没有改变。强制类型转换运算符与其它一元运算符具有相同的优先级,表2-1对运算符优先级进行了总结。
在通常情况下,参数是通过函数原型声明的。这样,当函数被调用时,声明将对参数进行自动强制转换。例如,对于sqrt的函数原型
不需要使用强制类型转换运算符就可以自动将整数2强制转换为double类型的值2.0。
标准库中包含一个可移植的实现伪随机数发生器的函数rand以及一个初始化种子数的函数srand。前一个函数rand使用了强制类型转换。
练习2-3编写函数htoi(s),把由十六进制数字组成的字符串(包含可选的前缀0x或0X)转换为与之等价的整型值。字符串中允许包含的数字包括:0~9、a~f以及A~F。
2.8.自增运算符与自减运算符
C语言提供了两个用于变量递增与递减的特殊运算符。自增运算符++使其操作数递增1,自减运算符使其操作数递减1。
执行后的结果是将x的值置为5,而x=++n;
将x的值置为6。这两条语句执行完成后,变量n的值都是6。自增与自减运算符只能作用于变量,类似于表达式(i+j)++是非法的。
在不需要使用任何具体值且仅需要递增变量的情况下,前缀方式和后缀方式的效果相同。
但在某些情况下需要酌情考虑。例如,考虑下面的函数squeeze(s,c),它删除字符串s中出现的所有字符c:
每当出现一个不是c的字符时,该函数把它拷贝到数组中下标为j的位置,随后才将j的值增加1,以准备处理下一个字符。其中的if语句完全等价于下列语句:
我们在第1章中编写的函数getline是类似结构的另外一个例子。我们可以将该函数中的if语句:
用下面这种更简洁的形式代替:
我们再来看第三个例子。考虑标准函数strcat(s,t),它将字符串t连接到字符串s的尾部。函数strcat假定字符串s中有足够的空间保存这两个字符串连接的结果。下面编写的这个函数没有任何返回值(标准库中的该函数返回一个指向新字符串的指针):
在将t中的字符逐个拷贝到s的尾部时,变量i和j使用的都是后缀运算符++,从而保证在
循环过程中i与j均指向下一个位置。
练习2-4squeeze(s1,s2),将字符串s1中任何与字符串s2中字符匹配的字符
都删除。
练习2-5编写函数any(s1,s2),将字符串s2中的任一字符在字符串s1中第一次出现的位置作为结果返回。如果s1中不包含s2中的字符,则返回-1。(标准库函数strpbrk具有同样的功能,但它返回的是指向该位置的指针。)
2.9.按位运算符
C语言提供了6个位操作运算符。这些运算符只能作用于整型操作数,即只能作用于带符号或无符号char、short、int、long类型:
&按位与(AND)
|按位或(OR)
^按位异或(XOR)
<<左移>>右移
~按位求反(一元运算符)
按位与运算符&经常用于屏蔽某些二进制位,例如:n=n&0177:
该语句将n中除7个低二进制位外的其它各位均置为0。按位或运算符|常用于将某些二进制位置为1,例如:x=x|SET_ON;
该语句将x中对应于SET_ON中为1的那些二进制位置为1。
按位异或运算符^当两个操作数的对应位不相同时将该位设置为1,否则,将该位设置为0。
我们必须将位运算符&、|同逻辑运算符&&、||区分开来,后者用于从左至右求表达式的真值。例如,如果x的值为1,Y的值为2,那么,x&y的结果为0,而x&&y的值为1。
移位运算符<<与>>分别用于将运算的左操作数左移与右移,移动的位数则由右操作数指定(右操作数的值必须是非负值)。因此,表达式x<<2将把x的值左移2位,右边空出的2位用0填补,该表达式等价于对左操作数乘以4。在对unsigned类型的无符号值进行右移位时,左边空出的部分将用0填补;当对signed类型的带符号值进行右移时,某些机器将对左边空出的部分用符号位填补(即“算术移位”),而另一些机器则对左边空出的部分用0填补(即“逻辑移位”)。
一元运算符~用于求整数的二进制反码,即分别将操作数各二进制位上的1变为0,0变为1。例如:
x=x&~077
将把x的最后6位设置为0。注意,表达式x&~077与机器字长无关,它比形式为x&0177700的表达式要好,同为后者假定x是16位的数值。这种可移植的形式并没有增加额外开销,因
为,~077是常量表达式,可以在编译时求值。
为了进一步说明某些位运算符,我们来看函数getbits(x,p,n),它返回x中从右边数第p位开始向右数n位的字段。这里假定最右边的一位是第0位,n与p都是合理的正值。例如,getbits(x,4,3)返回x中第4、3、2三位的值。
其中,表达式m<<(p+1-n)将期望获得的字段移位到字的最右端。~0的所有位都为1,这里使用语句~0<<n将~0左移n位,并将最右边的n位用0填补。再使用~运算对它按位取反,这样就建立了最右边n位全为1的屏蔽码。
练习2-6编写一个函数setbits(x,p,n,y),该函数返回对x执行下列操作后的结果值:将x中从第p位开始的n个(二进制)位设置为y中最右边n位的值,x的其余各位保持不变。
练习2-7编写一个函数invert(x,p,n),该函数返回对x执行下列操作后的结果值:将x中从第p位开始的n个(二进制)位求反(即,1变成0,0变成1),x的其余各位保持不变。
练习2-8编写一个函数rightrot(x,n),该函数返回将x循环右移(即从最右端移出的位将从最左端移入)n(二进制)位后所得到的值。
2.10.赋值运算符与表达式
在赋值表达式中,如果表达式左边的变量重复出现在表达式的右边,如:i=i+2
则可以将这种表达式缩写为下列形式:i+=2
其中的运算符+=称为赋值运算符。
大多数二元运算符(即有左、右两个操作数的运算符,比如+)都有一个相应的赋值运算
符op=,其中,op可以是下面这些运算符之一:+-*/%<<>>&^|如果expr1和expr2是表达式,
它们的区别在于,前一种形式expr1只计算一次。注意,在第二种形式中,expr2两边的圆括号是必不可少的,
我们这里举例说明。下面的函数bitcount统计其整型参数的值为1的二进制位的个数。
这里将x声明为无符号类型是为了保证将x右移时,无论该程序在什么机器上运行,左边空出的位都用0(而不是符号位)填补。
除了简洁外,赋值运算符还有一个优点:表示方式与人们的思维习惯比较接近。我们通常会说“把2加到i上”或“把i增加2”,而不会说“取i的值,加上2,再把结果放回到i中”,因此,表达式i+=2比i=i+2更自然,另外,对于复杂的表达式,例如:
yyval[yypv[p3+p4]+yypv[p1+p2]]+=2
赋值运算符使程序代码更易于理解,代码的阅读者不必煞费苦心地去检查两个长表达式是否完全一样,也无须为两者为什么不一样而疑惑不解,并且,赋值运算符还有助于编译器产生高效代码。
从上述例子中我们可以看出,赋值语句具有值,且可以用在表达式中。下面是最常见的一个例子:
其它赋值运算符(如+=、-=等)也可以用在表达式中,尽管这种用法比较少见。
在所有的这类表达式中,赋值表达式的类型是它的左操作数的类型,其值是赋值操作完成后的值,
练习2-9在求对二的补码时,表达式x&=(x–1)可以删除x中最右边值为1的一个二进制位。请解释这样做的道理。用这一方法重写bitcount函数,以加快其执行速度。
2.11.条件表达式
用于求a和b中的最大值,并将结果保存到z中。条件表达式(使用三元运算符“?:”)提供了另外一种方法编写这段程序及类似的代码段,在表达式
应该注意,条件表达式实际上就是一种表达式,它可以用在其它表达式可以使用的任何地方;如果expr2与expr3的类型不同,结果的类型将由本章前面讨论的转换规则决定。例如,如果f为float类型,n为int类型,那么表达式
(n>0)?f:n
是float类型,与n是否为正值无关。
条件表达式中第一个表达式两边的圆括号并不是必须的,这是因为条件运算符?:的优先级非常低,仅高于赋值运算符。但我们还是建议使用圆括号,因为这可以使表达式的条件部分更易于阅读。
采用条件表达式可以编写出很简洁的代码。例如,下面的这个循环语句打印一个数组的n个元素,每行打印10个元素,每列之间用一个空格隔开,每行用一个换行符结束(包括最后一行):
for(i=0;i<n;i++)
printf("%6d%c",a[i],(i%10==9!!i==n-1)?'\n':'');
在每10个元素之后以及在第n个元素之后都要打印一个换行符,所有其它元素后都要打印一个空格。编写这样的代码可能需要一些技巧,但比用等价的if-else结构编写的代码要紧凑一些。下面是另一个比较好的例子:
printf("Youhave%ditem%s.\n",n,n==1?"":"s");
在任何一种编程语言中,如果代码的执行结果与求值顺序相关,则都是不好的程序设计风格。很自然,有必要了解哪些问题需要避免,但是,如果不知道这些问题在各种机器上是如何解决的,就最好不要尝试运用某种特殊的实现方式。
第3章控制流
程序语言中的控制流语句用于控制各计算操作执行的次序。在前面的例子中,我们曾经使用了一些最常用的控制流结构。本章将更详细地讲述控制流语句。
3.1.语句与程序块
在x=0、i++或printf(...)这样的表达式之后加上一个分号(;),它们就变成了语句。
用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句(也叫作程序块),复合语句在语法上等价于单条语句。函数体中被花括号括起来的语句便是明显一例。if、else,while与for之后被花括号括住的多条语句也是类似的例子。(在任何程序块中都可以声明变量,笫4章将对此进行讨论。)右花括号用于结束程序块,其后不需要分号。
3.2.if-else语句
if-else语句用于条件判定,该语句执行时,先计算表达式的值,如果其值为真(即表达式的值为非0),则执行语句1;如果其值为假(即表达式的值为0),并且该语句包含else部分,则执行语句2。
由于if语句只是简单测试表达式的数值,因此可以对某些代码的编写进行简化。最明显的例子是用如下写法
if(表达式)来代替
if(表达式!0)
某些情况下这种形式是自然清晰的,但也有些情况下可能会含义不清。
因为if-else语句的else部分是可选的,所以在嵌套的if语句中省略它的else部分将导致歧义。解决的方法是将每个else与最近的前一个没有else配对的if进行匹配。
例如,在下列语句中:
else部分与内层的if匹配,我们通过程序的缩进结构也可以看出来。如果这不符合我们的意图,则必须使用花括号强制实现正确的匹配关系:
歧义性在下面这种情况下尤为有害:
程序的缩进结构明确地表明了设计意图,但编译器无法获得这一信息,它会将else部分与内层的if配对。这种错误很难发现,因此我们建议在有if语句嵌套的情况下使用花括号。
3.3.else-if语旬
因此我们在这里单独说明一下。这种if语句序列是编写多路判定最常用的方法。其中的各表达式将被依次求值,一旦某个表达式结果为真,则执行与之相关的语句,并终止整个语句序列的执行。同样,其中各语句既可以是单条语句,也可以是用花括号括住的复合语句。
最后一个else部分用于处理“上述条件均不成立”的情况或默认情况,也就是当上面各条件都不满足时的情形。有时候并不需要针对默认情况执行显式的操作,这种情况下,可以把该结构末尾的
else语句部分省略掉;该部分也可以用来检查错误,以捕获“不可能”的条件。
这里通过一个折半查找函数说明三路判定程序的用法。该函数用于判定已排序的数组v中是否存在某个特定的值x。数组v的元素必须以升序排列。如果v中包含x,则该函数返回x在v中的位置(介于0~n-1之间的一个整数);否则,该函数返回-1。
在折半查找时,首先将输入值x与数组v的中间元素进行比较。如果x小于中间元素的值,则在该数组的前半部分查找;否则,在该数组的后半部分查找。在这两种情况下,下一步都是将x与所选部分的中间元素进行比较。这个过程一直进行下去,直到找到指定的值或查找范围为空。
该函数的基本判定是:在每一步判断x小于、大于还是等于中间元素v[mid]。使用else-if结构执行这种判定很自然。
练习3-1在上面有关折半查找的例子中,while循环语句内共执行了两次测试,其实只要一次就足够(代价是将更多的测试在循环外执行)。重写该函数,使得在循环内部只执行一次测试。比较两种版本函数的运行时间。
3.4.switch语句
switch语句是一种多路判定语句,它测试表达式是否与一些常量整数值中的某一个值匹配,并执行相应的分支动作。
switch(表达式){
case常量表达式:语句序列case常量表达式:语句序列default:语句序列
每一个分支都由一个或多个整数值常量或常量表达式标记。如果某个分支与表达式的值匹配,则从该分支开始执行。各分支表达式必须互不相同。如果没有哪一分支能匹配表达式,则执行标记为default的分支。default分支是可选的。如果没有default分支也没有其它分支与表达式的值匹配,则该switch语句不执行任何动作。各分支及default分支的排列次序是任意的。
我们在第1章中曾用if…elseif…else结构编写过一个程序以统计各个数字、空白符及其它所有字符出现的次数。下面我们用switch语句改写该程序如下:
break语句将导致程序的执行立即从switch语句中退出。在switch语句中,case的作用只是一个标号,因此,某个分支中的代码执行完后,程序将进入下一分支继续执行,除非在程序中显式地跳转。跳出switch语句最常用的方法是使用break语句与return语句。break语句还可强制控制从while、for与do循环语句中立即退出,对于这一点,我们稍后还将做进一步介绍。
依次执行各分支的做法有优点也有缺点。好的一面是它可以把若干个分支组合在一起完成一个任务,如上例中对数字的处理。但是,正常情况下为了防止直接进入下一个分支执行,
每个分支后必须以一个break语句结束。从一个分支直接进入下一个分支执行的做法并不健全,这样做在程序修改时很容易出错。除了一个计算需要多个标号的情况外,应尽量减少从一个分支直接进入下一个分支执行这种用法,在不得不使用的情况下应该加上适当的程序注释。
作为一种良好的程序设计风格,在switch语句最后一个分支(即default分支)的后面也加上一个break语句。这样做在逻辑上没有必要,但当我们需要向该switch语句后添加其它分支时,这种防范措施会降低犯错误的可能性。
练习3-2编写一个函数escape(s,t),将字符串t复制到字符串s中,并在复制过程中将换行符、制表符等不可见字符分别转换为\n、\t等相应的可见的转义字符序列。要求使用swich语句。再编写一个具有相反功能的函数,在复制过程中将转义字符序列转换为实际字符。
3.5.while循环与for循环
我们在前面已经使用过while与for循环语句。在while循环语句
while(表达式)语句
中,首先求表达式的值。如果其值非0,则执行语句,并再次求该表达式的值。这一循环过程一直进行下去,直到该表达式的值为0为止,随后继续执行语句后面的部分。
for循环语句;
for(表达式1;表达式2;表达式3)语句
它等价于下列while语句:
表达式1;
while(表达式2){语句
表达式3;}
但当while或for循环语句中包含continue语句时,上述二者之间就不一定等价了。我们将在3.7节中介绍continue语句。
从语法角度看,for循环语句的3个组成部分都是表达式。最常见的情况是,表达式1与表达式3是赋值表达式或函数调用,表达式2是关系表达式。这3个组成部分中的任何部分都可以省略,但分号必须保留。如果在for语句中省略表达式1与表达式3,它就退化成了while循环语句。如果省略测试条件,即表达式2,则认为其值永远是真值,因此,下列for循环语句:
是一个“无限”循环语句,这种语句需要借助其它手段(如break语句或return语句)才能终止执行。
在设计程序时到底选用while循环语句还是for循环语句,主要取决于程序设计人员的
个人偏好。例如,在下列语句中:
因为其中没有初始化或重新初始化的操作,所以使用whi1e循环语句更自然一些。
如果语句中需要执行简单的初始化和变量递增,使用for语句更合适一些,它将循环控制语句集中放在循环的开头,结构更紧凑、更清晰。通过下列语句可以很明显地看出这一点:
这是C语言处理数组前n个元素的一种习惯性用法,它类似于Fortran语言中的DO循环或Pascal语言中的for循环。但是,这种类比并不完全准确,因为在C语言中,for循环语句的循环变量和上限在循环体内可以修改,并且当循环因某种原因终止后循环变量i的值仍然保留。因为for语句的各组成部分可以是任何表达式,所以for语句并不限于通过算术级数进行循环控制。尽管如此,牵强地把一些无关的计算放到for语句的初始化和变量递增部分是一种不好的程序设计风格,该部分放置循环控制运算更合适。
作为一个较大的例子,我们来重新编写将字符串转换为对应数值的函数atoi。这里编写的函数比第2章中的atoi函数更通用,它可以处理可选的前导空白符以及一个可选的加(+)或减(-)号。(第4章将介绍函数atof,它用于对浮点数执行同样的转换。)
下面是程序的结构,从中可以看出输入的格式:
如果有空白符的话,则跳过
如果有符号的话,则读取符号取整数部分,并执行转换
其中的每一步都对输入数据进行相应的处理,并为下一步的执行做好准备。当遇到第一个不能转换为数字的字符时,整个处理过程终止。
标准库中提供了一个更完善的函数strtol,它将字符串转换为长整型数。有关函数strtol的详细信息,请参见附录B.5节。
把循环控制部分集中在一起,对于多重嵌套循环,优势更为明显。下面的函数是对整型数组进行排序的Shell排序算法。Shell排序算法是D.L.Shell于1959年发明的,其基本思想是:先比较距离远的元素,而不是像简单交换排序算法那样先比较相邻的元素。这样可以快
速减少大量的无序情况,从而减轻后续的工作。被比较的元素之间的距离逐步减少,直到减少为1,这时排序变成了相邻元素的互换。
该函数中包含一个三重嵌套的for循环语句。最外层的for语句控制两个被比较元素之间的距离,从n/2开始,逐步进行对折,直到距离为0。中间层的for循环语句用于在元素间移动位置。最内层的for语句用于比较各对相距gap个位置的元素,当这两个元素逆序时把它们互换过来。由于gap的值最终要递减到1,因此所有元素最终都会位于正确的排序位置上。注意,即使最外层for循环的控制变量不是算术级数,for语句的书写形式仍然没有变,这就说明for语句具有很强的通用性。
逗号运算符“,”也是C语言优先级最低的运算符,在for语句中经常会用到它。被逗号分隔的一对表达式将按照从左到右的顺序进行求值,表达式右边的操作数的类型和值即为其结果的类型和值。这样,在for循环语句中,可以将多个表达式放在各个语句成分中,比如同时处理两个循环控制变晕。我们可以通过下面的函数reverse(s)来举例。该函数用于倒置字符串s中各个字符的位置。
某些情况下的逗号并不是逗号运算符,比如分隔函数参数的逗号,分隔声明中变量的逗号等,这些逗号并不保证各表达式按从左至右的顺序求值。
应该慎用逗号运算符。逗号运算符最适用于关系紧密的结构中,比如上面的reverse函数内的for语句,对于需要在单个表达式中进行多步计算的宏来说也很适合。逗号表达式还适用于reverse函数中元素的交换,这样,元素的交换过程便可以看成是一个单步操作。
练习3-3编写函数expand(s1,s2),将字符串s1中类似于a-z一类的速记符号
在字符串s2中扩展为等价的完整列表abc…xyz。该函数可以处理大小写字母和数字,并可以处理a-b-c、a-z0-9与-a-z等类似的情况。作为前导和尾随的-字符原样排印。
3.6.do-while循环
我们在第1章中曾经讲过,while与for这两种循环在循环体执行前对终止条件进行测试。与此相反,C语言中的第三种循环——do-while循环则在循环体执行后测试终止条件,这样循环体至少被执行一次。
do-while循环的语法形式如下:
do
语句
while(表达式);
在这一结构中,先执行循环体中的语句部分,然后再求表达式的值。如果表达式的值为真,则再次执行语句,依此类推。当表达式的值变为假,则循环终止。除了条件测试的语义不同外,do-while循环与Pascal语言的repeat-until语句等价。
经验表明,do-while循环比while循环和for循环用得少得多。尽管如此,do-while循环语句有时还是很有用的,下面我们通过函数itoa来说明这一点。itoa函数是atoi函数的逆函数,它把数字转换为字符串。这个工作比最初想像的要复杂一些。如果按照atoi函数中生成数字的方法将数字转换为字符串,则生成的字符串的次序正好是颠倒的,因此,我们首先要生成反序的字符串,然后再把该字符串倒置。
这里有必要使用do-while语句,至少使用do-while语句会方便一些,因为即使n的值为0,也至少要把一个字符放到数组s中。其中的do-while语句体中只有一条语句,尽管没有必要,但我们仍然用花括号将该语句括起来了,这样做可以避免草率的读者将while部分误认为是另个while循环的开始。
练习3-4在数的对二的补码表示中,我们编写的itoa函数不能处理最大的负数,即n等于-2字长-1的情况。请解释其原因。修改该函数,使它在任何机器上运行时都能打印出正确的值。
练习3-5编写函数itob(n,s,b),将整数n转换为以b为底的数,并将转换结果
以字符的形式保存到字符串保存在s中。
s中。例如,itob(n,s,16)把整数n格式化成十六进制整数
练习3-6修改itoa函数,使得该函数可以接收三个参数。其中,第三个参数为最小字段宽度。为了保证转换后所得的结果至少具有第三个参数指定的最小宽度,在必要时应在所得结果的左边填充一定的空格。
3.7.break语句与continue语句
不通过循环头部或尾部的条件测试而跳出循环,有时是很方便的。break语句可用于从for、while与do-while等循环中提前退出,就如同从switch语句中提前退出一样。break语句能使程序从switch语句或最内层循环中立即跳出。
下面的函数trim用于删除字符串尾部的空格符、制表符与换行符。当发现最右边的字符为非空格符、非制表符、非换行符时,就使用break语句从循环中退出。
strlen函数返回字符串的长度。for循环从字符串的末尾开始反方向扫描寻找第一个不是空格符、制表符以及换行符的字符。当找到符合条件的第一个字符,或当循环控制变量n变为负数时(即整个字符串都被扫描完时),循环终止执行。读者可以验证,即使字符串为空或仅包含空白符,该函数也是正确的。
continue语句与break语句是相关联的,但它没有break语句常用。continue语句用于使for、while或do-while语句开始下一次循环的执行。在while与do-while语句中,continue语句的执行意味着立即执行测试部分;在for循环中,则意味着使控制转移到递增循环变量部分。continue语句只用于循环语句,不用于switch语句。某个循环包含的switch语句中的continue语句,将导致进入下一次循环。
例如,下面这段程序用于处理数组a中的非负元素。如果某个元素的值为负,则跳过不处理。
当循环的后面部分比较复杂时,常常会用到continue语句。这种情况下,如果不使用continue语句,则可能需要把测试颠倒过来或者缩进另一层循环,这样做会使程序的嵌套更深。
3.8.goto语句与标号
C语言提供了可随意滥用的goto语句以及标记跳转位置的标号。从理论上讲,goto语句是没有必要的,实践中不使用goto语句也可以很容易地写出代码。至此,本书中还没有使用goto语句。
但是,在某些场合下goto语句还是用得着的。最常见的用法是终止程序在某些深度嵌套的结构中的处理过程,例如一次跳出两层或多层循环。这种情况下使用break语句是不能达到目的的,它只能从最内层循环退出到上一级的循环。下面是使用goto语句的一个例子:
在该例子中,如果错误处理代码很重要,并且错误可能出现在多个地方,使用goto语句将会比较方便。
标号的命名同变量命名的形式相同,标号的后面要紧跟一个冒号。标号可以位于对应的goto语句所在函数的任何语句的前面。标号的作用域是整个函数。
我们来看另外一个例子。考虑判定两个数组a与b中是否具有相同元素的问题。一种可能的解决方法是:
所有使用了goto语句的程序代码都能改写成不带goto语句的程序,但可能会增加一些额外的重复测试或变量。例如,可将上面判定是否具有相同数组元素的程序段改写成下列形式:
大多数情况下,使用goto语句的程序段比不使用goto语句的程序段要难以理解和维护,少数情况除外,比如我们前面所举的几个例子。尽管该问题并不太严重,但我们还是建议尽可能少地使用goto语句。
第4章函数与程序结构
函数可以把大的计算任务分解成若干个较小的任务,程序设计人员可以基于函数进一步构造程序,而不需要重新编写一些代码。一个设计得当的函数可以把程序中不需要了解的具体操作细节隐藏起来,从而使整个程序结构更加清晰,并降低修改程序的难度。
C语言在设计中考虑了函数的高效性与易用性这两个因素。C语言程序一般都由许多小的函数组成,而不是由少量较大的函数组成。一个程序可以保存在一个或者多个源文件中。各个文件可以单独编译,并可以与库中已编译过的函数一起加载。我们在这里不打算详细讨论这一过程,因为编译与加载的具体实现细节在各个编译系统中并不相同。
ANSI标准对C语言所做的最明显的修改是函数声明与函数定义这两方面。第1章中我们曾经讲过,目前C语言已经允许在声明函数时声明参数的类型。为了使函数的声明与定义相适应,ANSI标准对函数定义的语法也做了修改。基于该原因,编译器就有可能检测出比以前的C语言版本更多的错误。并且,如果参数声明得当,程序可以自动地进行适当的强制类型转换。
ANSI标准进一步明确了名字的作用域规则,特别要求每个外部对象只能有一个定义。初始化的适用范围也更加广泛了,自动数组与结构都可以进行初始化。
C语言预处理的功能也得到了增强。新的预处理器包含一组更完整的条件编译指令(一种通过宏参数创建带引号的字符串的方法),对宏扩展过程的控制更严格。
4.1.函数的基本知识
首先我们来设计并编写一个程序,它将输入中包含特定“模式”或字符串的各行打印出来(这是UNIX程序grep的特例)例如,在下列一组文本行中查找包含字符串“ould”的行:
打印该行
尽管我们可以把所有的代码都放在主程序main中,但更好的做法是,利用其结构把每一部分设计成一个独立的函数。分别处理3个小的部分比处理一个大的整体更容易,因为这样
可以把不相关的细节隐藏在函数中,从而减少了不必要的相互影响的机会,并且,这些函数也可以在其它程序中使用。
我们用函数getline实现“还有未处理的行”,该函数已在第1章中介绍过;用printf函数实现“打印该行”,这个函数是现成的,别人已经提供了。也就是说,我们只需要编写一个判定“该行包含指定的模式”的函数。
我们编写函数strindex(s,t)实现该目标。该函数返回字符串t在字符串s中出现的起始位置或索引。当s不包含t时,返回值为-1。由于C语言数组的下标从0开始,下标的值只可能为0或正数,因此可以用像-1这样的负数表示失败的情况。如果以后需要进行更复杂的模式匹配,只需替换strindex函数即可,程序的其余部分可保持不变。(标准库中提供的库函数strstr的功能类似于strindex函数,但该库函数返回的是指针而不是下标值。)
完成这样的设计后,编写整个程序的细节就直截了当了。下面列出的就是一个完整的程序,读者可以查看各部分是怎样组合在一起的。我们现在查找的模式是字符串字面值,它不是一种最通用的机制。我们在这里只简单讨论字符数组的初始化方法,第5章将介绍如何在程序运行时将模式作为参数传递给函数。其中,getline函数较前面的版本也稍有不同,读者可将它与第1章中的版本进行比较,或许会得到一些启发。
函数的定义形式如下:
返回值类型函数明(参数声明表){
声明和语句}
函数定义中的各构成部分都可以省略。最简单的函数如下所示:dummy(){}
该函数不执行任何操作也不返回任何值。这种不执行任何操作的函数有时很有用,它可以在程序开发期间用以保留位置(留待以后填充代码)。如果函数定义中省略了返回值类型,则默认为int类型。
程序可以看成是变量定义和函数定义的集台。函数之间的通信可以通过参数、函数返回值以及外部变量进行。函数在源文件中出现的次序可以是任意的。只要保证每一个函数不被分离到多个文件中,源程序就可以分成多个文件。
被调用函数通过return语句向调用者返回值,return语句的后面可以跟任何表达式:return表达式;
在必要时,表达式将被转换为函数的返回值类型。表达式两边通常加一对圆括号,此处的括号是可选的。
调用函数可以忽略返回值。并且,return语句的后面也不一定需要表达式。当return语句的后面没有表达式时,函数将不向调用者返回值。当被调用函数执行到最后的右花括号而结束执行时,控制同样也会返回给调用者(不返回值)。如果某个函数从一个地方返回时有返回值,而从另一个地方返回时没有返回值,该函数并不非法,但可能是一种出问题的征兆。在任何情况下,如果函数没有成功地返回一个值,则它的“值”肯定是无用的。
在上面的模式查找程序中,主程序main返回了一个状态,即匹配的数目。该返回值可以在调用该程序的环境中使用。
在不同的系统中,保存在多个源义件中的C语言程序的编译与加载机制是不同的。例如,在UNIX系统中,可以使用第1章中提到过的cc命令执行这一任务。假定有3个函数分别存放在名为main.c、getline.c与strindex.c的3个文件中,则可以使用命令
4.2.返回非整型值的函数
到目前为止,我们所讨论的函数都是不返回任何值(void)或只返回int类型值的函数。假如某个函数必须返回其它类型的值,该怎么办呢?许多数值函数(如sqrt、sin与cos等函数)返回的是double类型的值,某些专用函数则返回其它类型的值。我们通过函数atof(s)来说明函数返回非整型值的方法。该函数把字符串s转换为相应的双精度浮点数。atof函数是atoi函数的扩展,第2章与第3章已讨论了atoi函数的几个版本。atof函数需要处理可选的符号和小数点,并要考虑可能缺少整数部分或小数部分的情况。我们这里编写的版本并不是一个高质量的输入转换函数,它占用了过多的空间。标准库中包含类似功能的atof函数,在头文件<stdlib.h>中声明。
首先,由于atof函数的返回值类型不是int,因此该函数必须声明返回值的类型。返回值的类型名应放在函数名字之前,如下所示:
其次,调用函数必须知道atof函数返回的是非整型值,这一点也是很重要的。为了达到该目的,一种方法是在调用函数中显式声明atof函数。下面所示的基本计算器程序(仅适用
于支票簿计算)中有类似的声明。该程序在每行中读取一个数(数的前面可能有正负号),并对它们求和,在每次输入完成后把这些数的累计总和打印出来:
其中,声明语句
表明sum是一个double类型的变量,atof函数带有个char[]类型的参数,且返回一个double类型的值。
函数atof的声明与定义必须一致。如果atof函数与调用它的主函数main放在同一源文件中,并且类型不一致,编译器就会检测到该错误。但是,如果atof函数是单独编译的(这种可能性更大),这种不匹配的错误就无法检测出来,atof函数将返回double类型的值,而main函数却将返回值按照int类型处理,最后的结果值毫无意义。
那么编译程序也不会对函数atof的参数作任何假设,并会关闭所有的参数检查。对空参数表的这种特殊处理是为了使新的编译器能编译比较老的C语言程序。不过,在新编写的程序中这么做是不提倡的。如果函数带有参数,则要声明它们;如果没有参数,则使用void进行声明。
在正确进行声明的函数atof的基础上,我们可以利用它编写出函数atoi(将字符串转换为int类型):
请注意其中的声明和return语句的结构。在下列形式的return语句中:return(表达式);
其中,表达式的值在返回之前将被转换为函数的类型。因为函数atoi的返回值为int类型,所以,return语句中的atof函数的double类型值将被自动转换为int类型值。但是,这种操作可能会丢失信息,某些编译器可能会对此给出警告信息。在该函数中,由于采用了类型转换的方法显式表明了所要执行的转换操作,因此可以防止有关的警告信息。
4.3.外部变量
C语言程序可以看成由一系列的外部对象构成,这些外部对象可能是变量或函数。形容词external与internal相对的,internal用于描述定义在函数内部的函数参数及变量。外部变量定义在函数之外,因此可以在许多函数中使用。由于C语言不允许在一个函数中定义其它函数,因此函数本身是“外部的”。默认情况下,外部变量与函数具有下列性质:通过同一个名字对外部变量的所有引用(即使这种引用来自于单独编译的不同函数)实际上都是引用同一个对象(标准中把这一性质称为外部链接)。在这个意义上,外部变量类似于Fortran语言的COMMON块或Pascal语言中在最外层程序块中声明的变量。我们将在后面介绍如何定义只能在某一个源文件中使用的外部变量与函数。
因为外部变量可以在全局范围内访问,这就为函数之间的数据交换提供了一种可以代替函数参数与返回值的方式。任何函数都可以通过名字访问一个外部变量,当然这个名字需要通过某种方式进行声明。
如果函数之间需要其享大量的变量,使用外部变量要比使用一个很长的参数表更方便、有效。但是,我们在第1章中已经指出,这样做必须非常谨慎,因为这种方式可能对程序结构产生不良的影响,而且可能会导致程序中各个函数之间具有太多的数据联系。
外部变量的用途还表现在它们与内部变量相比具有更大的作用域和更长的生存期。自动变量只能在函数内部使用,从其所在的函数被调用时变量开始存在,在函数退出时变量也将消失。而外部变量是永久存在的,它们的值在一次函数调用到下一次函数调用之间保持不变。因此,如果两个函数必须共享某些数据,而这两个函数互不调用对方,这种情况下最方便的方式便是把这些共享数据定义为外部变量,而不是作为函数参数传递。
下面我们通过一个更复杂的例子来说明这一点。我们的目标是编写一个具有加(+)、减(-)、乘(*)、除(/)四则运算功能的计算器程序。为了更容易实现,我们在计算器中使用逆波兰表示法代替普通的中辍表示法(逆波兰表示法用在某些袖珍计算器中,Forth与Postscript等语言也使用了逆波兰表示法)。
在逆波兰表示法中,所有运算符都跟在操作数的后面。比如,下列中缀表达式:
(1–2)*(4+5)采用逆波兰表示法表示为:
12-45+*
逆波兰表示法中不需要圆括号,只要知道每个运算符需要几个操作数就不会引起歧义。
计算器程序的实现很简单。每个操作数都被依次压入到栈中;当一个运算符到达时,从栈中弹出相应数目的操作数(对二元运算符来说是两个操作数),把该运算符作用于弹出的操作数,并把运算结果再压入到栈中。例如,对上面的逆波兰表达式来说,首先把1和2压入到栈中,再用两者之差-1取代它们;然后,将4和5压入到栈中,再用两者之和9取代它们。最后,从栈中取出栈顶的-1和9,并把它们的积-9压入到栈顶。到达输入行的末尾时,把栈顶的值弹出并打印。
这样,该程序的结构就构成一个循环,每次循环对一个运算符及相应的操作数执行一次操作:
while(下一个运算符或操作数不是文件结束指示符)if(是数)
将该数压入到栈中elseif(是运算符)
弹出所需数目的操作数执行运算
将结果压入到栈中elseif(是换行符)
弹出并打印栈顶的值else
出错
栈的压入与弹出操作比较简单,但是,如果把错误检测与恢复操作都加进来,该程序就显得很长了,最好把它们设计成独立的函数,而不要把它们作为程序中重复的代码段使用。另外还需要一个单独的函数来取下一个输入运算符或操作数。
到目前为止,我们还没有讨论设计中的一个重要问题:把栈放在哪儿?也就是说,哪些例程可以直接访问它?一种可能是把它放在主函数main中,把栈及其当前位置作为参数传递给对它执行压入或弹出操作的函数。但是,main函数不需要了解控制栈的变量信息,它只进行压入与弹出操作。因此,可以把栈及相关信息放在外部变量中,并只供push与pop函数访问,而不能被main函数访问。
把上面这段话转换成代码很容易。如果把该程序放在一个源文件中,程序可能类似于下列形式:
我们在后面部分将讨论如何把该程序分割成两个或多个源文件。
main函数包括一个很大的switch循环,该循环根据运算符或操作数的类型控制程序的转移。这里的switch语句的用法比3.4节中的例子更为典型。
因为+与*两个运算符满足交换律,因此,操作数的弹出次序无关紧要。但是,-与/两个
运算符的左右操作数必须加以区分。
如果变量定义在任何函数的外部,则是外部变量。因此,我们把push和pop函数必须共享的栈和栈顶指针定义在这两个函数的外部。但是,main函数本身并没有引用栈或栈顶指针,因此,对main函数而言要将它们隐藏起来。
下面我们来看getop函数的实现。该函数获取下一个运算符或操作数。该任务实现起来比较容易。它需要跳过空格与制表符。如果下一个字符不是数字或小数点,则返回;否则,把这些数字字符串收集起来(其中可能包含小数点),并返回NUMBER,以标识数已经收集起来了。
这段程序中的getch与ungetch两个函数有什么用途呢?程序中经常会出现这样的情况:程序不能确定它已经读入的输入是否足够,除非超前多读入一些输入。读入一些字符以合成一个数字的情况便是一例:在看到第一个非数字字符之前,已经读入的数的完整性是不能确定的。由于程序要超前读入一个字符,这样就导致最后有一个字符不属于当前所要读入的数。
如果能“反读”不需要的字符,该问题就可以得到解决。每当程序多读入一个字符时,就把它压回到输入中,对代码其余部分而言就好像没有读入该字符一样。我们可以编写一对互相协作的函数来比较方便地模拟反取字符操作。getch函数用于读入下一个待处理的字符,而ungetch函数则用于把字符放回到输入中,这样,此后在调用getch函数时,在读入新的输入之前先返回ungetch函数放回的那个字符。
这两个函数之间的协同工作也很简单。ungetch函数把要压回的字符放到一个共享缓冲区(字符数组)中,当该缓冲区不空时,getch函数就从缓冲区中读取字符;当缓冲区为空时,getch函数调用getchar函数直接从输入中读字符。这里还需要增加一个下标变量来记住缓冲区中当前字符的位置。
由于缓冲区与下标变量是供getch与ungetch函数共享的,且在两次调用之间必须保持值不变,因此它们必须是这两个函数的外部变量。可以按照下列方式编写getch、ungetch函数及其共享变量:
标准库中提供了ungetc,它将一个字符压回到栈中,我们将在第7章中讨论该函数。为了提供一种更通用的方法,我们在这里使用了一个数组而不是一个字符。
练习4-3在有了基本框架后,对计算器程序进行扩充就比较简单了。在该程序中加入取模(%)运算符,并注意考虑负数的情况。
练习4-4在栈操作中添加几个命令,分别用于在不弹出元素的情况下打印栈顶元素;复制栈顶元素;交换栈顶两个元素的值。另外增加一个命令用于清空栈。
练习4-5给计算器程序增加访问sin、exp与pow等库函数的操作。有关这些库函数的详细信息,参见附录B.4节中的头文件<math.h>。
练习4-6给计算器程序增加处理变量的命令(提供26个具有单个英文字母变量名的变量很容易)。增加一个变量存放最近打印的值。
练习4-7编写一个函数ungets(s),将整个字符串s压回到输入中。ungets函数需要使用buf和bufp吗?它能否仅使用ungetch函数?
练习4-8假定最多只压回一个字符。请相应地修改getch与ungetch这两个函数。
练习4-9以上介绍的getch与ungetch函数不能正确地处理压回的EOF。考虑压回EOF时应该如何处理?请实现你的设计方案。
练习4-10另一种方法是通过getline函数读入整个输入行,这种情况下可以不使用getch与ungetch函数。请运用这一方法修改计算器程序。
4.4.作用域规则
构成C语言程序的函数与外部变量可以分开进行编译。一个程序可以存放在几个文件中,原先已编译过的函数可以从库中进行加载。这里我们感兴趣的问题有:
.如何进行声明才能确保变量在编译时被正确声明?
.如何安排声明的位置才能确保程序在加载时各部分能正确连接?
.如何组织程序中的声明才能确保只有一份副本?
.如何初始化外部变量?
为了讨论这些问题,我们重新组织前面的计算器程序,将它分散到多个文件中。从实践的角度来看,计算器程序比较小,不值得分成几个文件存放,但通过它可以很好地说明较大的程序中遇到的类似问题。
名字的作用域指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来说,其作用域是声明该变量名的函数。不同函数中声明的具有相同名字的各个局部变量之间没有任何关系。函数的参数也是这样的,实际上可以将它看作是局部变量。
外部变量或函数的作用域从声明它的地方开始,到其所在的(待编译的)文件的末尾结束。例如,如果main、sp、val、push与pop是依次定义在某个文件中的5个函数或外部变量,如下所示:
那么,在push与pop这两个函数中不需进行任何声明就可以通过名字访问变量sp与val,但是,这两个变量名不能用在main函数中,push与pop函数也不能用在main函数中。
另一方面,如果要在外部变量的定义之前使用该变量,或者外部变量的定义与变量的使用不在同一个源文件中,则必须在相应的变量声明中强制性地使用关键字extern。
将外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性(主要是变量的类型),而变量定义除此以外还将引起存储器的分配。如果将下列语句放在所有函数的外部:
为源文件的其余部分声明了一个int类型的外部变量sp以及一个double数组类型的外部变量val(该数组的长度在其它地方确定),但这两个声明并没有建立变量或为它们分配存储单元。
在一个源程序的所有源文件中,一个外部变量只能在某个文件中定义一次,而其它文件可以通过extern声明来访问它(定义外部变量的源文件中也可以包含对该外部变量的extern声明)。外部变量的定义中必须指定数组的长度,但extern声明则不一定要指定数组的长度。
外部变量的初始化只能出现在其定义中。
假定函数push与pop定义在一个文件中,而变量val与sp在另一个文件中定义并被初始化(通常不大可能这样组织程序),则需要通过下面这些定义与声明把这些函数和变量“绑定”在一起:
在文件file1中:
由于文件file1中的extern声明不仅放在函数定义的外面,而且还放在它们的前面,因此它们适用于该文件中的所有函数。对于file1,这样一组声明就够了。如果要在同一个文件中先使用、后定义变量sp与val,也需要按照这种方式来组织文件。
4.5.头文件
下面我们来考虑把上述的计算器程序分割到若干个源文件中的情况。如果该程序的各组成部分很长,这么做还是有必要的。我们这样分割:将主函数main单独放在文件main.c中;将push与pop函数以及它们使用的外部变量放在第二个文件stack.c中;将getop函数放在第三个文件getop.c中;将getch与ungetch函数放在第四个文件getch.c中。之所以分割成多个文件,主要是考虑在实际的程序中,它们分别来自于单独编译的库。
此外,还必须考虑定义和声明在这些文件之间的共享问题。我们尽可能把共享的部分集中在一起,这样就只需要一个副本,改进程序时也容易保证程序的正确性。我们把这些公共部分放在头文件calc.h中,在需要使用该头文件时通过#include指令将它包含进来(#include指令将在4.11节中介绍)。这样分割后,程序的形式如下所示:
我们对下面两个因素进行了折衷:一方面是我们期望每个文件只能访问它完成任务所需的信息;另一方面是现实中维护较多的头文件比较困难。我们可以得出这样一个结论:对于某些中等规模的程序,最好只用一个头文件存放程序中各部分共享的对象。较大的程序需要使用更多的头文件,我们需要精心地组织它们。
4.6.静态变量
某些变量,比如文件stack.c中定义的变量sp与val以及文件getch.c中定义的变量buf与bufp,它们仅供其所在的源文件中的函数使用,其它函数不能访问。用static声明限定外部变量与函数,可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。通过static限定外部对象,可以达到隐藏外部对象的目的,比如,getch-ungetch复合结构需要共享buf与bufp两个变量,这样buf与bufp必须是外部变量,但这两个对象不应该被getch与ungetch函数的调用者所访问。
要将对象指定为静态存储,可以在正常的对象声明之前加上关键字static作为前缀。如果把上述两个函数和两个变量放在一个文件中编译,如下所示:
那么其它函数就不能访问变量buf与bufp,因此这两个名字不会和同一程序中的其它文件中的相同的名字相冲突。同样,可以通过把变量sp与val声明为静态类型隐藏这两个由执行栈操作的push与pop函数使用的变量。
外部的static声明通常多用于变量,当然,它也可用于声明函数。通常情况下,函数名字是全局可访问的,对整个程序的各个部分而言都可见。但是,如果把函数声明为static类型,则该函数名除了对该函数声明所在的文件可见外,其它文件都无法访问。
static也可用于声明内部变量。static类型的内部变量同自动变量一样,是某个特定函数的局部变量,只能在该函数中使用,但它与自动变量不同的是,不管其所在函数是否被调用,它一直存在,而不像自动变量那样,随着所在函数的被调用和退出而存在和消失。换句话说,static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。
练习4-11修改getop函数,使其不必使用ungetch函数。提示:可以使用一个static类型的内部变量解决该问题。
4.7.寄存器变量
register声明告诉编译器,它所声明的变量在程序中使用频率较高。其思想是,将register变量放在机器的寄存器中,这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。
register声明只适用于自动变量以及函数的形式参数。
实际使用时,底层硬件环境的实际情况对寄存器变量的使用会有一些限制。每个函数中只有很少的变量可以保存在寄存器中,且只允许某些类型的变量。但是,过量的寄存器声明并没有什么害处,这是因为编译器可以忽略过量的或不支持的寄存器变量声明。另外,无论寄存器变量实际上是不是存放在寄存器中,它的地址都是不能访问的(有关这一点更详细的信息,我们将在第5章中讨论)。在不同的机器中,对寄存器变量的数目和类型的具体限制也是不同的。
4.8.程序块结构
C语言并不是Pascal等语言意义上的程序块结构的语言,它不允许在函数中定义函数。但是,在函数中可以以程序块结构的形式定义变量。变量的声明(包括初始化)除了可以紧跟在函数开始的花括号之后,还可以紧跟在任何其它标识复合语句开始的左花括号之后。以这种方式声明的变量可以隐藏程序块外与之同名的变量,它们之间没有任何关系,并在与左花括号匹配的右花括号出现之前一直存在。例如,在下面的程序段中:
变量i的作用域是if语句的“真”分支,这个i与该程序块外声明的i无关。每次进入程序块时,在程序块内声明以及初始化的自动变量都将被初始化。静态变量只在第一次进入程序块时被初始化一次。
自动变量(包括形式参数)也可以隐藏同名的外部变量与函数。在下面的声明中:
函数f内的变量x引用的是函数的参数,类型为double;面在函数f外,x是int类型的外部变量。这段代码中的变量y也是如此。
在一个好的程序设计风格中,应该避免出现变量名隐藏外部作用域中相同名字的情况,否则,很可能引起混乱和错误。
4.9.初始化
前面我们多次提到过初始化的概念,不过始终没有详细讨论。本节将对前面讨论的各种
存储类的初始化规则做一个总结。
在不进行显式初始化的情况下,外部变量和静态变量都将被初始化为0,而自动变量和寄存器变量的初值则没有定义(即初值为无用的信息)。
定义标量变量时,可以在变量名后紧跟一个等号和一个表达式来初始化变量:
对于外部变量与静态变量来说,初始化表达式必须是常量表达式,且只初始化一次(从概念上讲是在程序开始执行前进行初始化)。对于自动变量与寄存器变量,则在每次进入函数或程序块时都将被初始化。
对于自动变量与寄存器变量来说,初始化表达式可以不是常量表达式:表达式中可以包含任意在此表达式之前已经定义的值,包括函数调用,我们在3.3节中介绍的折半查找程序的初始化可以采用下列形式:
代替原来的形式:
实际上,自动变量的初始化等效于简写的赋值语句。究竟采用哪一种形式,还得看个人的习惯。考虑到变量声明中的初始化表达式容易被人忽略,且距使用的位置较远,我们一般使用显式的赋值语句。
数组的初始化可以在声明的后面紧跟一个初始化表达式列表,初始化表达式列表用花括号括起来,各初始化表达式之间通过逗号分隔。例如,如果要用一年中各月的天数初始化数组days,其变量的定义如下:
当省略数组的长度时,编译器将把花括号中初始化表达式的个数作为数组的长度,在本例中数组的长度为12。
如果初始化表达式的个数比数组元索数少,则对外部变量、静态变量和自动变量来说,没有初始化表达式的元素将被初始化为0,如果初始化表达式的个数比数组元素数多,则是错误的。不能一次将一个初始化表达式指定给多个数组元素,也不能跳过前面的数组元素而直接初始化后面的数组元素。
字符数组的初始化比较特殊:可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列。
这种情况下,数组的长度是5(4个字符加上一个字符串结束符'\0')。
4.10.递归
C语言中的函数可以递归调用,即函数可以直接或间接调用自身。我们考虑一下将一个数作为字符串打印的情况。前面讲过,数字是以反序生成的:低位数字先于高位数字生成,但它们必须以与此相反的次序打印。
解决该问题有两种方法。一种方法是将生成的各个数字依次存储到一个数组中,然后再以相反的次序打印它们,这种方式与3.6节中itoa函数的处理方式相似。另一种方法则是使用递归,函数printd首先调用它自身打印前面的(高位)数字,然后再打印后面的数字。这里编写的函数不能处理最大的负数。
函数递归调用自身时,每次调用都会得到一个与以前的自动变量集合不同的新的自动变量集合。因此,调用printd(123)时,第一次调用printd的参数n=123。它把12传递给printd的第二次调用,后者又把1传递结printd的第三次调用。第三次调用printd时首先将打印1,然后再返回到第二次调用。从第三次调用返回后的第二次调用同样也将先打印2,然后再返回到第一次调用。返回到第一次调用时将打3,随之结束函数的执行。
另外一个能较好说明递归的例子是快速排序。快速排序算法是C.A.R.Hoare于1962年发明的。对于一个给定的数组,从中选择一个元素,以该元素为界将其余元素划分为两个子集,一个子集中的所有元素都小于该元索,另一个子集中的所有元素都大于或等于该元素。对这样两个子集递归执行这一过程,当某个子集中的元素数小于2时,这个子集就不需要再次排序,终止递归。
从执行速度来讲,下列版本的快速排序函数可能不是最快的,但它是最简单的算法之一。在每次划分子集时,该算法总是选取各个子数组的中间元素。
这里之所以将数组元素交换操作放在一个单独的函数swap中,是因为它在qsort函数中要使用3次。
标准库中提供了一个qsort函数,它可用于对任何类型的对象排序。
递归并不节省存储器的开销,因为递归调用过程中必须在某个地方维护一个存储处理值的栈。递归的执行速度并不快,但递归代码比较紧凑,并且比相应的非递归代码更易于编写与理解。在描述树等递归定义的数据结构时使用递归尤其方便。我们将在6.5节中介绍一个比较好的例子。
练习4-12运用printd函数的设计思想编写一个递归版本的itoa函数,即通过递归调用把整数转换为字符串。
练习4-13编写一个递归版本的reverse(s)函数,以将字符串s倒置。
4.11.C预处理器
C语言通过预处理器提供了一些语言功能。从概念上讲,预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是:#include指令(用于在编译期间把指定文件的内容包含进当前文件中)和#define指令(用任意字符序列替代一个标记)。本节还将介绍预处理器的其它一些特性,如条件编译与带参数的宏。
4.11.1.文件包含
文件包含指令(即#include指令)使得处理大量的#define指令以及声明更加方便。在源文件中,任何形如:
#include"文件名"
的行都将被替换为由文件名指定的文件的内容。如果文件名用引号引起来,则在源文件所在位置查找该文件;如果在该位置没有找到文件,或者如果文件名是用尖括号<与>括起来的,则将根据相应的规则查找该文件,这个规则同具体的实现有关。被包含的文件本身也可包含#include指令。
源文件的开始处通常都会有多个#include指令,它们用以包含常见的#define语句和extern声明,或从头文件中访问库函数的函数原型声明,比如<stdio.h>。(严格地说,这些内容没有必要单独存放在文件中;访问头文件的细节同具体的实现有关。)
在大的程序中,#include指令是将所有声明捆绑在一起的较好的方法。它保证所有的源文件都具有相同的定义与变量声明,这样可以避免出现一些不必要的错误。很自然,如果某个包含文件的内容发生了变化,那么所有依赖于该包含文件的源文件都必须重新编译。
4.11.2.宏替换
宏定义的形式如下:
#define名字替换文本
这是一种最简单的宏替换——后续所有出现名字记号的地方都将被替换为替换文本。
#define指令中的名字与变量名的命名方式相同,替换文本可以是任意字符串。通常情况下,#define指令占一行,替换文本是#define指令行尾部的所有剩余部分内容,但也可以把一个较长的宏定义分成若干行,这时需要在待续的行末尾加上一个反斜杠符\。#define指令定义的名字的作用域从其定义点开始,到被编译的源文件的末尾处结束。宏定义中也可以使用前面出现的宏定义。替换只对记号进行,对括在引号中的字符串不起作用。例如,如果YES是一个通过#define指令定义过的名字,则在printf("YES")或YESMAN中将不执行替换。
替换文本可以是任意的,
宏定义也可以带参数,这样可以对不同的宏调用使用不同的替换文本。
使用宏max看起来很像是函数词用,但宏调用直接将替换文本插入到代码中。形式参数(在此为A或B)的每次出现都将被替换成对应的实际参数。
但是,宏还是很有价值的。<stdio.h>头文件中有一个很实用的例子:getchar与putchar函数在实际中常常被定义为宏,这样可以避免处理字符时调用函数所需的运行时开销。<ctype.h>头文件中定义的函数也常常是通过宏实现的。
可以通过#undef指令取消名字的宏定义,这样做可以保证后续的调用是函数调用,而不是宏调用:
其中的字符串被连接起来了,这样,该宏调用的效果等价于printf("x/y=&g\n",x/y);
在实际参数中,每个双引号"将被替换为\",反斜杠\将被替换为\\,因此替换后的字符串是合法的字符串常量。
预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与##相邻,则该参数将被实际参数替换,##与前后的空白符将被删除,并对替换后的结果重新扫描。例如,下面定义的宏paste用于连接两个参数
4.11.3.条件包含
还可以使用条件语句对预处理本身进行控制,这种条件语句的值是在预处理执行的过程中进行计算。这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了一种手段。
#if语句对其中的常量整型表达式(其中不能包含sizeof、类型转换运算符或enum常量)进行求值,若该表达式的值不等于0,则包含其后的各行,直到遇到#endif、#elif或#else语句为止(预处理器语句#elif类似于elseif)。在#if语句中可以使用表达式defined(名字),该表达式的值遵循下列规则:当名字已经定义时,其值为1;否则,其值为0。
例如,为了保证hdr.h文件的内容只被包含一次,可以将该文件的内容包含在下列形式的条件语句中:
/*hdr.h文件的内容放在这里*/#endif
第一次包含头文件hdr.h时,将定义名字HDR;此后再次包含该头文件时,会发现该名字已经定义,这样将直接跳转到#endif处。类似的方式也可以用来避免多次重复包含同一文件。如果多个头文件能够一致地使用这种方式,那么,每个头文件都可以将它所依赖的任何头文件包含进来,用户不必考虑和处理头文件之间的各种依赖关系。
下面的这段预处理代码首先测试系统变量SYSTEM,然后根据该变量的值确定包含哪个版本的头文件:
C语言专门定义了两个预处理语句#ifdef与#ifndef,它们用来测试某个名字是否已经定义。上面有关#if的第一个例子可以改写为下列形式:
第5章指针与数组
指针是一种保存变量地址的变量。在C语言中,指针的使用非常广泛,原因之一是,指针常常是表达某个计算的惟一途径,另一个原因是,同其它方法比较起来,使用指针通常可以生成更高效、更紧凑的代码。指针与数组之间的关系十分密切,我们将在本章中讨论它们之间的关系,并探讨如何利用这种关系。
指针和goto语句一样,会导致程序难以理解。如果使用者粗心,指针很容易就指向了错误的地方。但是,如果谨慎地使用指针,便可以利用它写出简单、清晰的程序。在本章中我们将尽力说明这一点。
ANSIC的一个最重要的变化是,它明确地制定了操纵指针的规则。事实上,这些规则已经被很多优秀的程序设计人员和编译器所采纳。此外,ANSIC使用类型void*(指向void的指针)代替char*作为通用指针的类型。
5.1.指针与地址
首先,我们通过一个简单的示意图来说明内存是如何组织的。通常的机器都有一系列连续编号或编址的存储单元,过些存储单元可以单个进行操纵,也可以以连续成组的方式操纵。通常情况下,机器的一个字节可以存放一个char类型的数据,两个相邻的字节存储单元可存储一个short(短整型)类型的数据,而4个相邻的字节存储单元可存储一个long(长整型)类型的数据。指针是能够存放一个地址的一组存储单元(通常是两个或4个字节)。因此,如果c的类型是char,并且p是指向c的指针,则可用图5-1表示它们之间的关系:
图5-1
一元运算符&可用于取一个对象的地址,因此,下列语句:p=&c;
将把c的地址赋值给变量p,我们称p为“指向”c的指针。地址运算符&只能应用于内存中的对象,即变量与数组元素。它不能作用于表达式、常量或register类型的变量。
一元运算符*是间接寻址或间接引用运算符。当它作用于指针时,将访问指针所指向的对象。我们在这里假定x与y是整数,而ip是指向int类型的指针,下面的代码段说明了如何在程序中声明指针以及如何使用运算符&和*:
变量x、y与z的声明方式我们已经在前面的章节中见到过。我们来看指针ip的声明,如下所示:
这样声明是为了便于记忆。该声明语句表明表达式*ip的结果是int类型。这种声明变量的语法与声明该变量所在表达式的语法类似。同样的原因,对函数的声明也可以采用这种方式。
表明,在表达式中,*dp和atof(s)的值都是double类型,且atof的参数是一个指向char类型的指针。
我们应该注意,指针只能指向某种特定类型的对象,也就是说,每个指针都必须指向某种特定的数据类型。(一个例外情况是指向void类型的指针可以存放指向任何类型的指针,但它不能间接引用其自身。我们将在5.11节中详细讨论该问题)。
如果指针ip指向整型变量,那么在x可以出现的任何上下文中都可以使用*ip,因此,语句
一元运算符*和&的优先级比算术运算符的优先级高,因此,赋值语句y=*ip+1
将把*ip指向的对象的值取出并加1,然后再将结果赋值给y,而下列赋值语句:*ip+=1
语句的执行结果。语句(*ip)++中的圆括号是必需的,否则,该表达式将对ip进行加1运算,而不是对ip指向的对象进行加1运算,这是因为,类似于*和++这样的一元运算符遵循从右至左的结合顺序。
最后说明一点,由于指针也是变量,所以在程序中可以直接使用,而不必通过间接引用的方法使用。例如,如果iq是另一个指向整型的指针,那么语句
将把ip中的值拷贝到iq中,这样,指针iq也将指向ip指向的对象。
5.2.指针与函数参数
由于C语言是以传值的方式将参数值传递给被调用函数。因此,被调用函数不能直接修改主调函数中变最的值。例如,排序函数可能会使用一个名为swap的函数来交换两个次序颠倒的元素。但是,如果将swap函数定义为下列形式:
则下列语句无法达到该目的。swap(a,b);
这是因为,由于参数传递采用传值方式,因此上述的swap函数不会影响到调用它的例程中的参数a和b的值。该函数仅仅交换了a和b的副本的值。
那么,如何实现我们的目标呢,可以使主调程序将指向所要交换的变量的指针传递给被调用函数,即:
我们通过图5-2进行说明。
图5-2
指针参数使得被调用函数能够访问和修改主调函数中对象的值。我们来看这样一个例子:函数getint接受自由格式的输入,并执行转换,将输入的字符流分解成整数,且每次调用得到一个整数。getint需要返回转换后得到的整数,并且,在到达输入结尾时要返回文件结束标记。这些值必须通过不同的方式返回。EOF(文件结束标记)可以用任何值表示,当然也可用一个输入的整数表示。
可以这样设计该函数:将标识是否到达文件结尾的状态作为getint函数的返回值,同时,使用一个指针参数存储转换后得到的整数并传回给主调函数。函数scanf的实现就采用了这种方法,具体细节请参见7.4节。
下面的循环语句调用getint函数给一个整型数组赋值:intn,array[SIZE],getint(int*);
在getint函数中,*pn始终作为一个普通的整型变量使用。其中还使用了getch和ungetch两个函数(参见4.3节),借助这两个函数,函数getint必须读入的一个多余字符就可以重新写回到输入中。
练习5-1在上面的例子中,如果符号+或-的后面紧跟的不是数字,getint函数将把符号视为数字0的有效表达方式。修改该函数,将这种形式的+或-符号重新写回到输入流中。
练习5-2模仿函数getint的实现方法,编写一个读取浮点数的函数getfloat。getfloat函数的返回值应该是什么类型?
5.3.指针与数组
在C语言中,指针和数组之间的关系十分密切,因此,在接下来的部分中,我们将同时讨论指针与数组。通过数组下标所能完成的任何操作都可以通过指针来实现。一般来说,用指针编写的程序比用数组下标编写的程序执行速度快,但另一方面,用指针实现的程序理解
起来稍微困难一些。声明
inta[10];
定义了一个长度为10的数组a。换句话说,它定义了一个由10个对象组成的集合,这10个对象存储在相邻的内存区域中,名字分别为a[0]、a[1]、…、a[9](参见图5-3)。
图5-3a[i]表示该数组的第i个元素。如果pa的声明为
int*pa;
则说明它是一个指向整型对象的指针,那么,赋值语句
pa=&a[0];
则可以将指针pa指向数组a的第0个元素,也就是说,pa的值为数组元素a[0]的地址(参见图5-4)。
图5-4
这样,赋值语句x=*pa;
将把数组元素a[0]中的内容复制到变量x中。
如果pa指向数组中的某个特定元素,那么,根据指针运算的定义,pa+1将指向下一个元素,pa+i将指向pa所指向数组元素之后的第i个元素,而pa-i将指向pa所指向数组元素之前的第i个元素。因此,如果指针pa指向a[0],那么*(pa+1)引用的是数组元素a[1]的内容,pa+i是数组元素a[i]的地址,*(pa+i)引用的是数组元素a[i]的内容(参见图5-5)。
图5-5
无论数组a中元素的类型或数组长度是什么,上面的结论都成立。“指针加1”就意味着,pa+1指向pa所指向的对象的下一个对象。相应地,pa+i指向pa所指向的对象之后的第i个对象。
下标和指针运算之间具有密切的对应关系。根据定义,数组类型的变量或表达式的值是
该数组第0个元素的地址。执行赋值语句pa=&a[0];
后,pa和a具有相同的值。因为数组名所代表的就是该数组最开始的一个元素的地址,所以,赋值语句pa=&a[0]也可以写成下列形式:
pa=a;
对数组元素a[i]的引用也可以写成*(a+i)这种形式。对第一次接触这种写法的人来说,可能会觉得很奇怪。在计算数组元素a[i]的值时,C语言实际上先将其转换为*(a+i)的形式,然后再进行求值,因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分别施加地址运算符&,便可以得出这样的结论:&a[i]和a+i的含义也是相同的。a+i是a
之后第i个元素的地址。相应地,如果pa是个指针,那么,在表达式中也可以在它的后面加下标。pa[i]与*(pa+i)是等价的。简而言之,一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。
但是,我们必须记住,数组名和指针之间有一个不同之处,指针是一个变量,因此,在C语言中,语句pa=a和pa++都是合法的。但数组名不是变量,因此,类似于a=pa和a++形式的语句是非法的。
当把数组名传递给一个函数时,实际上传递的是该数组第一个元索的地址。在被调用函数中,该参数是一个局部变量,因此,数组名参数必须是一个指针,也就是一个存储地址值的变量。我们可以利用该特性编写strlen函数的另一个版本,该函数用于计算一个字符串的长度。
因为s是一个指针,所以对其执行自增运算是合法的。执行s++运算不会影响到strlen函数的调用者中的字符串,它仅对该指针在strlen函数中的私有副本进行自增运算。因此,类似于下面这样的函数调用:
都可以正确地执行。
在函数定义中,形式参数
是等价的。我们通常更习惯于使用后一种形式,因为它比前者更直观地表明了该参数是一个指针。如果将数组名传递给函数,函数可以根据情况判定是按照数组处理还是按照指针处理,随后根据相应的方式操作该参数。为了直观且恰当地描述函数,在函数中甚至可以同时使用数组和指针这两种表示方法。
也可以将指向子数组起始位置的指针传递给函数,这样,就将数组的一部分传递给了函数。例如,如果a是一个数组,那么下面两个函数调用
都将把起始于a[2]的子数组的地址传递给函数f。在函数f中,参数的声明形式可以为
对于函数f来说,它并不关心所引用的是否只是一个更大数组的部分元素。
如果确信相应的元素存在,也可以通过下标访问数组第一个元素之前的元素。类似于p[-1]、p[-2]这样的表达式在语法上都是合法的,它们分别引用位于p[0]之前的两个元素。当然,引用数组边界之外的对象是非法的。
5.4.地址算术运算
如果p是一个指向数组中某个元素的指针,那么p++将对p进行自增运算并指向下一个元素,而p+=i将对p进行加i的增量运算,使其指向指针p当前所指向的元素之后的第i个元素。这类运算是指针或地址算术运算中最简单的形式。
C语言中的地址算术运算方法是一致且有规律的,将指针、数组和地址的算术运算集成在一起是该语言的一大优点。为了说明这一点,我们来看一个不完善的存储分配程序。它由两个函数组成。第一个函数alloc(n)返回一个指向n个连续字符存储单元的指针,alloc函数的调用者可利用该指针存储字符序列。第二个函数afree(p)释放已分配的存储空间,以便以后重用。之所以说这两个函数是“不完善的”,是因为对afree函数的调用次序必须与调用alloc函数的次序相反。换句话说,alloc与afree以栈的方式(即后进先出的列表)进行存储空间的管理。标准库中提供了具有类似功能的函数malloc和free,它们没有上述限制,我们将在8.7节中说明如何实现这些函数。
最容易的实现方法是让alloc函数对一个大字符数组allocbuf中的空间进行分配。该数组是alloc和afree两个函数私有的数组。由于函数alloc和afree处理的对象是指针而不是数组下标,因此,其它函数无需知道该数组的名字,这样,可以在包含alloc和afree的源文件中将该数组声明为static类型,使得它对外不可见。实际实现时,该数组甚至可以没有名字,它可以通过调用malloc函数或向操作系统申请一个指向无名存储块的指针获得。
allocbuf中的空间使用状况也是我们需要了解的信息。我们使用指针allocp指向allocbuf中的下一个空闲单元。当调用alloc申请n个字符的空间时,alloc检查allocbuf数组中有没有足够的剩余空间。如果有足够的空闲空间,则alloc返回allocp的当前值(即空闲块的开始位置),然后将allocp加n以使它指向下一个空闲区域。如果空闲空间不够,则alloc返回0。如果p在allocbuf的边界之内,则afree(p)仅仅只是将allocp的值设置为p(参见图5-6)。
一般情况下,同其它类型的变量一样,指针也可以初始化。通常,对指针有意义的初始化值只能是0或者是表示地址的表达式,对后者来说,表达式所代表的地址必须是在此前已定义的具有适当类型的数据的地址。例如,声明
将allocp定义为字符类型指针,并将它初始化为allocbuf的起始地址,该起始地址是程序执行时的下一个空闲位置。上述语句也可以写成下列形式:
staticchar*allocp=&allocbuf[0];这是因为该数组名实际上就是数组第0个元素的地址。
下列if测试语句:
检查是否有足够的空闲空间以满足n个字符的存储空间请求。如果空闲空间足够,则分配存储空间后allocp的新值至多比allocbuf的尾端地址大1。如果存储空间的申请可以满足,alloc将返回一个指向所需大小的字符块首地址的指针(注意函数本身的声明)。如果申请无法满足,alloc必须返回某种形式的信号以说明没有足够的空闲空间可供分配。C语言保证,
0永远不是有效的数据地址,因此,返回值0可用来表示发生了异常事件。在本例中,返回值
0表示没有足够的空闲空间可供分配。
指针与整数之间不能相互转换,但0是惟一的例外:常量0可以赋值给指针,指针也可以和常量0进行比较。程序中经常用符号常量NULL代替常量0,这样便于更清晰地说明常量0是指针的一个特殊值。符号常量NULL定义在标准头文件<stddef.h>中。我们在后面部分经常会用到NULL。
类似于
的条件测试语句表明指针算术运算有以下几个重要特点。首先,在某些情况下对指针可以进行比较运算。例如,如果指针p和q指向同一个数组的成员,那么它们之间就可以进行类似于==、!=、<、>=的关系比较运算。如果p指向的数组元素的位置在q指向的数组元素位置之前,那么关系表达式
p<q
的值为真。任何指针与0进行相等或不等的比较运算都有意义。但是,指向不同数组的元素的指针之间的算术或比较运算没有定义。(这里有一个特例:指针的算术运算中可使用数组最后一个元素的下一个元素的地址。)
其次。我们从前面可以看到,指针可以和整数进行相加或相减运算。例如,结构p+n
表示指针p当前指向的对象之后第n个对象的地址。无论指针p指向的对象是何种类型,上述结论都成立。在计算p+n时,n将根据p指向的对象的长度按比例缩放,而p指向的对象的长度则取决于p的声明。例如,如果int类型占4个字节的存储空间,那么在int类型的计算中,对应的n将按4的倍数来计算。
指针的减法运算也是有意义的:如果p和q指向相同数组中的元索,且p<q,那么q-p+1就是位于p和q指向的元索之间的元素的数目。我们由此可以编写出函数strlen的另一个版本,如下所示:
在上述程序段的声明中,指针p被初始化为指向s,即指向该字符串的第一个字符。whi1e循环语句将依次检查字符串中的每个字符,直到遇到标识字符数组结尾的字符'\0'为止。由于p是指向字符的指针,所以每执行一次p++,p就将指向下一个字符的地址,p-s则表示已经检查过的字符数,即字符串的长度。(字符串中的字符数有可能超过int类型所能表示的最大范围。头文件<stddef.h>中定义的类型ptrdiff_t足以表示两个指针之间的带符号差值。但是,我们在这里使用size_t作为函数strlen的返回值类型,这样可以与标准库中的函数版本相匹配。Size_t是由运算符sizeof返回的无符号整型。)
指针的算术运算具有一致性:如果处理的数据类型是比字符型占据更多存储空间的浮点类型,并且p是一个指向浮点类型的指针,那么在执行p++后,p将指向下一个浮点数的地址。因此,只需要将alloc和afree函数中所有的char类型替换为float类型,就可以得到一个适用于浮点类型而非字符型的内存分配函数。所有的指针运算都会自动考虑它所指向的对象的长度。
有效的指针运算包括相同类型指针之间的赋值运算;指针同整数之间的加法或减法运算;指向相同数组中元素的两个指针间的减法或比较运算;将指针赋值为0或指针与0之间的比较运算。其它所有形式的指针运算都是非法的,例如两个指针间的加法、乘法、除法、移位或屏蔽运算;指针同float或double类型之间的加法运算;不经强制类型转换而直接将指向一种类型对象的指针赋值给指向另一种类型对象的指针的运算(两个指针之一是void*类型的情况除外)。
5.5.字符指针与函数
字符串常量是一个字符数组,
在字符串的内部表示中,字符数组以空字符'\0'结尾,所以,程序可以通过检查空字符找到字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大1。
字符串常量最常见的用法也许是作为函数参数,
当类似于这样的一个字符串出现在程序中时,实际上是通过字符指针访问该字符串的。在上述语句中,printf接受的是一个指向字符数组第一个字符的指针。也就是说,字符串常量可通过一个指向其第一个元素的指针访问。
除了作为函数参数外,字符串常量还有其它用法。
将把一个指向该字符数组的指针赋值给pmessage。该过程并没有进行字符串的复制,而只是涉及到指针的操作。C语言没有提供将整个字符串作为一个整体进行处理的运算符。
为了更进一步地讨论指针和数组其它方面的问题,下面以标准库中两个有用的函数为例来研究它们的不同实现版本。第一个函数strcpy(s,t)把指针t指向的字符串复制到指针s指向的位置。如果使用语句s=t实现该功能,其实质上只是拷贝了指针,而并没有复制字符。为了进行字符的复制,这里使用了一个循环语句。strcpy函数的第1个版本是通过数组方法实现的,如下所示:
为了进行比较,下面是用指针方法实现的strcpy函数:
因为参数是通过值传递的,所以在strcpy函数中可以以任何方式使用参数s和t。在此,s和t是方便地进行了初始化的指针,循环每执行一次,它们就沿着相应的数组前进一个字符,直到将t中的结束符'\0'复制到s为止。
实际上,strcpy函数并不会按照上面的这些方式编写。经验丰富的程序员更喜欢将它编写成下列形式:
在该版本中,s和t的自增运算放到了循环的测试部分中。表达式*t++的值是执行自增运算之前t所指向的字符。后缀运算符++表示在读取该字符之后才改变t的值。同样的道理,在s执行自增运算之前,字符就被存储到了指针s指向的旧位置。该字符值同时也用来和空字符'\0'进行比较运算,以控制循环的执行。最后的结果是依次将t指向的字符复制到s指向的位置,直到遇到结束符'\0'为止(同时也复制该结束符),
为了更进一步地精炼程序,我们注意到,表达式同'\0'的比较是多余的,因为只需要判断表达式的值是否为0即可。因此,该函数可进一步写成下列形式:
该函数初看起来不太容易理解,但这种表示方法是很有好处的,我们应该掌握这种方法,C语言程序中经常会采用这种写法。
标准库(<string.h>)中提供的函数strcpy把目标字符串作为函数值返回。
我们研究的第二个函数是字符串比较函数strcmp(s,t)。该函数比较字符串s和t,并且根据s按照字典顺序小于、等于或大于t的结果分别返回负整数、0或正整数。该返回值是s和t由前向后逐字符比较时遇到的第一个不相等字符处的字符的差值。
下面用是指针方式实现的strcmp函数:
由于++和--既可以作为前缀运算符,也可以作为后缀运算符,所以还可以将运算符*与运算符++和--按照其它方式组合使用,但这些用法并不多见。例如,下列表达式
在读取指针p指向的字符之前先对p执行自减运算。事实上,下面的两个表达式:
*p++=val;/*将val压入栈*/
val=*--p;/*将栈顶元素弹出到val中*/是进栈和出栈的标准用法。更详细的信息,请参见4.3节。
头文件<string.h>中包含本节提到的函数的声明,另外还包括标准库中其它一些字符串处理函数的声明。
的字符串复制到s指向的字符串的尾部。
练习5-4编写函数strend(s,t)。如果字符串t出现在字符串s的尾部,该函数返回1;否则返回0。
练习5-5实现库函数strncpy、strncat和strncmp,它们最多对参数字符串中
的前n个字符进行操作。例如,函数strncpy(s,t,n)将t中最多前n个字符复制到s中。更详细的说明请参见附录B。
练习5-6采用指针而非数组索引方式改写前面章节和练习中的某些程序,例如getline(第1、4章),atoi、itoa以及它们的变体形式(第2、3、4章),reverse(第3章),strindex、getop(第4章)等等。
5.6.指针数组以及指向指针的指针
由于指针本身也是变量,所以它们也可以像其它变量一样存储在数组中。下面通过编写UNIX程序sort的一个简化版本说明这一点。该程序按字母顺序对由文本行组成的集合进行排序。
我们在第3章中曾描述过一个用于对整型数组中的元素进行排序的shell排序函数,并在第4章中用快速排序算法对它进行了改进。这些排序算法在此仍然是有效的,但是,现在处理的是长度不一的文本行。并且与整数不同的是,它们不能在单个运算中完成比较或移动操作。我们需要一个能够高效、方便地处理可变长度文本行的数据表示方法。
我们引入指针数组处理这种问题。如果待排序的文本行首尾相连地存储在一个长字符数组中,那么每个文本行可通过指向它的第一个字符的指针来访问。这些指针本身可以存储在一个数组中。这样,将指向两个文本行的指针传递给函数strcmp就可实现对这两个文本行的比较。当交换次序颠倒的两个文本行时,实际上交换的是指针数组中与这两个文本行相对应的指针,而不是这两个文本行本身(参见图5-8)。
这种实现方法消除了因移动文本行本身所带来的复杂的存储管理和巨大的开销这两个孪生问题。
排序过程包括下列3个步骤:
读取所有输入行
对文本行进行排序按次序打印文本行
通常情况下,最好将程序划分成若干个与问题的自然划分相一致的函数,并通过主函数控制其它函数的执行。关于对文本行排序这一步,我们稍后再做说明,现在主要考虑数据结构以及输入和输出函数。
输入函数必须收集和保存每个文本行中的字符,并建立一个指向这些文本行的指针的数组。它同时还必须统计输入的行数,因为在排序和打印时要用到这一信息。由于输入函数只能处理有限数目的输入行,所以在输入行数过多而超过限定的最大行数时,该函数返回某个用于表示非法行数的数值,例如-1。
输出函数只需要按照指针数组中的次序依次打印这些文本行即可。
在该例子中,指针数组1ineptr的声明是新出现的重要概念:char*lineptr[MAXLINES];
它表示1ineptr是一个具有MAXLINES个元素的一维数组,其中数组的每个元素是一个指向字符类型对象的指针。也就是说,lineptr[i]是一个字符指针,而*lineptr[i]是该指针指向的第i个文本行的首字符。
由于1ineptr本身是一个数组名,因此,可按照前面例子中相同的方法将其作为指针使用,这样,writelines函数可以改写为:
(注意这里的数组变量lineptr可以改变值)
循环开始执行时,*lineptr指向第一行,每执行一次自增运算都使得lineptr指向下一行,同时对nlines进行自减运算。
在明确了输入和输出函数的实现方法之后,下面便可以着手考虑文本行的排序问题了。在这里需要对第4章的快速排序函数做一些小改动:首先,需要修改该函数的声明部分;其次,需要调用strcmp函数完成文本行的比较运算。但排序算法在这里仍然有效,不需要做任何改动。
5.7.多维数组
C语言提供了类似于矩阵的多维数组,但实际上它们并不像指针数组使用得那样广泛。本节将对多维数组的特性进行介绍。
我们考虑一个日期转换的问题,把某月某日这种日期表示形式转换为某年中第几天的表示形式,反之亦然。例如,3月1日是非闰年的第60天,是闰年的第61天。在这里,我们定义下列两个函数以进行日期转换:函数day_of_year将某月某日的日期表示形式转换为某一年中第几天的表示形式,函数month_day则执行相反的转换。因为后一个函数要返回两个值,所以在函数month_day中,月和日这两个参数使用指针的形式。例如,下列语句:
我们在前面的章节中曾讲过,逻辑表达式的算术运算值只可能是0(为假时)或者1(为真时)。因此,在本例中,可以将逻辑表达式leap用做数组daytab的下标。
数组daytab必须在函数day_of_year和month_day的外部进行声明,这样,这两个函数都可以使用该数组。这里之所以将daytab的元素声明为char类型,是为了说明在char类型的变量中存放较小的非字符整数也是合法的。
到目前为止,daytab是我们遇到的第一个二维数组。在C语言中,二维数组实际上是一种特殊的一维数组,它的每个元素也是一个一维数组。因此,数组下标应该写成
除了表示方式的区别外,C语言中二维数组的使用方式和其它语言一样。数组元素按行存储,因此,当按存储顺序访问数组时,最右边的数组下标(即列)变化得最快。
数组可以用花括号括起来的初值表进行初始化,二维数组的每一行由相应的子列表进行初始化。在本例中,我们将数组daytab的第一列元素设置为0,这样,月份的值为1~12,而不是0~11。由于在这里存储空间并不是主要问题,所以这种处理方式比在程序中调整数组的下标更加直观。
如果将二维数组作为参数传递给函数,那么在函数的参数声明中必须指明数组的列数。数组的行数没有太大关系,因为前面已经讲过,函数调用时传递的是一个指针,它指向由行向量构成的一维数组,其中每个行向量是具有13个整型元素的一维数组。在该例子中,传递给函数的是一个指向很多对象的指针,其中每个对象是由13个整型元素构成的一维数组。因此,如果将数组daytab作为参数传递给函数f,那么f的声明应该写成下列形式:这种声明形式表明参数是一个指针,它指向具有13个整型元素的一维数组。因为方括号[]的优先级高于*的优先级,所以上述声明中必须使用圆括号。如果去掉括号,则声明变成
int*daytab[13]
这相当于声明了一个数组,该数组有13个元素,其中每个元素都是一个指向整型对象的指针。一般来说,除数组的第一维(下标)可以不指定大小外,其余各维都必须明确指定大小。
我们将在5.12节中进一步讨论更复杂的声明。
练习5-8函数day_of_year和month_day中没有进行错误检查,请解决该问题。
5.8.指针数组的初始化
考虑这样一个问题:编写一个函数month_name(n),它返回一个指向第n个月名字的字符串的指针。这是内部static类型数组的一种理想的应用。month_name函数中包含一个私有的字符串数组,当它被调用时,返回一个指向正确元素的指针。本节将说明如何初始化该名字数组。
指针数组的初始化语法和前面所讲的其它类型对象的初始化语法类似:
其中,name的声明与排序例子中lineptr的声明相同,是一个一维数组,数组的元素为字符指针。name数组的初始化通过一个字符串列表实现,列表中的每个字符串赋值给数组相应位置的元素。第i个字符串的所有字符存储在存储器中的某个位置,指向它的指针存储在name[i]中。由于上述声明中没有指明name的长度,因此,编译器编译时将对初值个数进行统计,并将这一准确数字填入数组的长度。
5.9.指针与多维数组
对于C语言的初学者来说,很容易混淆二维数组与指针数组之间的区别,比如上面例子中的name。假如有下面两个定义:
inta[10][20];
int*b[10];
那么,从语法角度讲,a[3][4]和b[3][4]都是对一个int对象的合法引用。但a是一个真正的二维数组,它分配了200个int类型长度的存储空间,并且通过常规的矩阵下标计算公式20×row+col(其中,row表示行,col表示列)计算得到元素a[row][col]的位置。但是,对b来说,该定义仅仅分配了10个指针,并且没有对它们初始化,它们的初始化必须以显式的方式进行,比如静态初始化或通过代码初始化。假定b的每个元素都指向一个具有20个元素的数组,那么编译器就要为它分配200个int类型长度的存储空间以及10个指针的存储空间。指针数组的一个重要优点在于,数组的每一行长度可以不同,也就是说,b的每个元素不必都指向一个具有20个元素的向量,某些元素可以指向具有2个元素的向量,某些元素可以指向具有50个元素的向量,而某些元素可以不指向任何向量。
尽管我们在上面的讨论中都是借助于整型进行讨论,但到目前为止,指针数组最频繁的用处是存放具有不同长度的字符串,比如函数month_name中的情况。结合下面的声明和图形化描述,我们可以做一个比较。下面是指针数组的声明和图形化描述(参见图5-9):
按照C语言的约定,argv[0]的值是启动该程序的程序名,因此argc的值至少为1。
如果argc的值为1,则说明程序名后面没有命令行参数。在上面的例子中,argc的值为3,argv[0]、argv[1]和argv[2]的值分别为“echo”、“hello,”,以及“world”。第一个可选参数为argv[1],而最后一个可选参数为argv[argc-1]。另外,ANSI标准要求argv[argc]的值必须为一空指针(参见图5-11)。
在处理每个可选参数之前,argc执行自减运算,argv执行自增运算。循环语句结束时,如果没有错误,则argc的值表示还没有处理的参数数目,而argv则指向这些未处理参数中的第一个参数。因此,这时argc的值应为1,而*argv应该指向模式。注意,*++argv是一个指向参数字符串的指引,因此(*++argv)[0]是它的第一个字符(另一种有效形式是**++argv)。因为[]与操作数的结合优先级比*和++高,所以在上述表达式中必须使用圆括号,否则编译器将会把该表达式当做*++(argv[0])。实际上,我们在内层循环中就使用了表达式*++argv[0],其目的是遍历一个特定的参数串。在内层循环中,表达式*++argv[0]对指针argv[0]进行了自增运算。
很少有人使用比这更复杂的指针表达式。如果遇到这种情况,可以将它们分为两步或三步来理解,这样会更直观一些。
练习5-10编写程序expr,以计算从命令行输入的逆波兰表达式的值,其中每个运算符或操作数用一个单独的参数表示。例如,命令
expr234+*
将计算表达式2×(3+4)的值。
练习5-11修改程序entab和decab(第1章练习中编写的函数),使它们接受一组作为参数的制表符停止位。如果启动程序时不带参数,则使用默认的制表符停止位设置。
练习5-12对程序entab和detab的功能做一些扩充,以接受下列缩写的命令:entab–m+n
表示制表符从第m列开始,每隔n列停止。选择(对使用者而言)比较方便的默认行为。
练习5-13编写程序tail,将其输入中的最后n行打印出来。默认情况下,n的值为10,但可通过一个可选参数改变n的值,因此,命令
tail-n
将打印其输入的最后n行。无论输入或n的值是否合理,该程序都应该能正常运行。编
写的程序要充分地利用存储空间;输入行的存储方式应该同5.6节中排序程序的存储方式一样,而不采用固定长度的二维数组。
5.11.指向函数的指针
在C语言中,函数本身不是变量,但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。为了说明指向函数的指针的用法,我们接下来将修改本章前面的排序函数,在给定可选参数-n的情况下,该函数将按数值大小而非字典顺序对输入行进行排序。
排序程序通常包括3部分:判断任何两个对象之间次序的比较操作、颠倒对象次序的交换操作、一个用于比较和交换对象直到所有对象都按正确次序排列的排序算法。由于排序算法与比较、交换操作无关,因此,通过在排序算法中调用不同的比较和交换函数,便可以实现按照不同的标准排序。这就是我们的新版本排序函数所采用的方法。
我们在前面讲过,函数strcmp按字典顺序比较两个输入行。在这里,我们还需要一个以数值为基础来比较两个输入行,并返回与strcmp同样的比较结果的函数numcmp。这些函数在main之前声明,并且,指向恰当函数的指针将被传递给qsort函数。在这里,参数的出错处理并不是问题的重点,我们将主要考虑指向函数的指针问题。
5.12.复杂声明
该程序的目的旨在说明问题,并不想做得尽善尽美,所以对dcl有很多限制,它只能处理类似于char或int这样的简单数据类型,而无法处理函数中的参数类型或类似于const这样的限定符。它不能处理带有不必要空格的情况。由于没有完备的出错处理,因此它也无法处理无效的声明。这些方面的改进留给读者做练习。
下面是该程序的全局变量和主程序:
第6章结构
结构是一个或多个变量的集合,这些变量可能为不同的类型,为了处理的方便而将这些变量组织在一个名字之下。(某些语言将结构称为“记录”,比如Pascal语言。)由于结构将一组相关的变量看作一个单元而不是各自独立的实体,因此结构有助于组织复杂的数据,特别是在大型的程序中。
工资记录是用来描述结构的一个传统例子。每个雇员由一组属性描述,如姓名、地址、
社会保险号、工资等。其中的某些属性也可以是结构,例如姓名可以分成几部分,地址甚至工资也可能出现类似的情况。C语言中更典型的一个例子来自于图形领域:点由一对坐标定义,矩形由两个点定义,等等。
ANSI标准在结构方面最主要的变化是定义了结构的赋值操作——结构可以拷贝、赋值、传递给函数,函数也可以返回结构类型的返回值。多年以前,这一操作就已经被大多数的编译器所支持,但是,直到这一标准才对其属性进行了精确定义。在ANSI标准中,自动结构和数组现在也可以进行初始化。
6.1.结构的基本知识
我们首先来建立一些适用于图形领域的结构。点是最基本的对象,假定用x与y坐标表示它,且x、y的坐标值都为整数(参见图6-1)
图6-1
我们可以采用结构存放这两个坐标,其声明如下:
structpoint{
intx;
inty;
};
关键字struct引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字struct后面的名字是可选的,称为结构标记(这里是point)。结构标记用于为结构命名,在定义之后,结构标记就代表花括号内的声明,可以用它作为该声明的简写形式。
结构中定义的变量称为成员。结构成员、结构标记和普通变量(即非成员)可以采用相
同的名字,它们之间不会冲突,因为通过上下文分析总可以对它们进行区分。另外,不同结构中的成员可以使用相同的名字,但是,从编程风格方面来说,通常只有密切相关的对象才会使用相同的名字。
struct声明定义了一种数据类型。在标志结构成员表结束的右花括号之后可以跟一个变量表,这与其它基本类型的变量声明是相同的。例如:
struct{...}x,y,z;
从语法角度来说,这种方式的声明与声明intx,y,z;
具有类似的意义。这两个声明都将x、y与z声明为指定类型的变量,并且为它们分配存储空间。
如果结构声明的后面不带变量表,则不需要为它分配存储空间,它仅仅描述了一个结构的模板或轮廓。但是,如果结构声明中带有标记,那么在以后定义结构实例时便可以使用该标记定义。例如,对于上面给出的结构声明point,语句
structpointpt;
定义了一个structpoint类型的变量pt。结构的初始化可以在定义的后面使用初值表进行。初值表中同每个成员对应的初值必须是常量表达式,例如:
structpointmaxpt={320,200};
自动结构也可以通过赋值初始化,还可以通过调用返回相应类型结构的函数进行初始化。在表达式中,可以通过下列形式引用某个特定结构中的成员:
结构名.成员
其中的结构成员运算符“.”将结构名与成员名连接起来。例如,可用下列语句打印点pt的坐标:
printf("%d,%d",pt.x,pt.y);
结构可以嵌套。
结构rect包含两个point类型的成员。。
6.2.结构与函数
结构的合法操作只有几种:作为一个整体复制和赋值,通过&运算符取地址,访问其成员。其中,复制和赋值包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。可以用一个常量成员值列表初始化结构,自动结构也可以通过赋值进行初始化。
为了更进一步地理解结构,我们编写几个对点和矩形进行操作的函数。至少可以通过3种可能的方法传递结构:一是分别传递各个结构成员,二是传递整个结构,三是传递指向结构的指针。这3种方法各有利弊。
首先来看一下函数makepoint,它带有两个整型参数,并返回一个point类型的结构:
注意,参数名和结构成员同名不会引起冲突。事实上,使用重名可以强调两者之间的关系。
现在可以使用makepoint函数动态地初始化任意结构,也可以向函数提供结构类型的参数。
其中,函数的参数和返回值都是结构类型。之所以直接将相加所得的结果赋值给p1,而没有使用显式的临时变量存储,是为了强调结构类型的参数和其它类型的参数一样,都是通过值传递的。
下面来看另外一个例子。
将增加len的值,而不是增加p的值,这是田为,其中的隐含括号关系是++(p->len)。可以使用括号改变结合次序。例如:(++p)->len将先执行p的加1操作,再对len执行操作;而(p++)->len则先对len执行操作,然后再将p加1(该表达式中的括号可以省略)。
同样的道理,*p->str读取的是指针str所指向的对象的值;*p->str++先读取指针str指向的对象的值,然后再将str加1(与*s++相同);(*p->str)++将指针str指向的对象的值加1;*p++->str先读取指针str指向的对象的值,然后再将p加1。
6.3.结构数组
考虑编写这样一个程序,它用来统计输入中各个C语言关键字出现的次数。我们需要用一个字符串数组存放关键字名,一个整型数组存放相应关键字的出现次数。一种实现方法是,使用两个独立的数组keyword和keycount分别存放它们,如下所示
char*keyword[NKEYS];
intkeycount[NKEYS];
我们注意到,这两个数组的大小相同,考虑到该特点,可以采用另一种不同的组织方式,也就是我们这里所说的结构数组。每个关键字项包括一对变量:
char*word;
intcout;
这样的多个变量对共同构成一个数组。我们来看下面的声明:
structkey{
char*word;
intcount;
}keytab[NKEYS];
它声明了一个结构类型key,并定义了该类型的结构数组keytab,同时为其分配存储空间。数组keytab的每个元素都是一个结构。上述声明也可以写成下列形式:
structkey{
char*word;
intcount;
};
structkeykeytab[NKEYS];
因为结构keytab包含一个固定的名字集合,所以,最好将它声明为外部变量,这样,只需要初始化一次,所有的地方都可以使用。这种结构的初始化方法同前面所述的初始化方法类似——在定义的后面通过一个用圆括号括起来的初值表进行初始化,如下所示:
structkey{
char*word;intcount;
}keytab[]={
"auto",0,
"break",0,
"case",0,
"char",0,
"const",0,
"continue",0,"default",0,/*...*/
"unsigned",0,"void",0,
"volatile",0,"while",0
};
与结构成员相对应,初值也要按照成对的方式列出。更精确的做法是,将每一行(即每个结构)的初值都括在花括号内,如下所示:
{"auto",0},
{"break",0},
{"case",0},
但是,如果初值是简单变量或字符串,并且其中的任何值都不为空,则内层的花括号可以省略。通常情况下,如果初值存在并且方括号[]中没有数值,编译程序将计算数组keytab中的项数。
函数getword将在稍后介绍,这里只需要了解它的功能是每调用一次该函数,将读入一个单词,并将其复制到名字为该函数的第一个参数的数组中。
NKEYS代表keytab中关键字的个数。尽管可以手工计算,但由机器实现会更简单、更安全,当列表可能变更时尤其如此。一种解决办法是,在初值表的结尾处加上一个空指针,然后循环遍历keytab,直到读到尾部的空指针为止。
但实际上并不需要这样做,因为数组的长度在编译时已经完全确定,它等于数组项的长度乘以项数,因此,可以得出项数为:
Keytab的长度/structkey的长度
C语言提供了一个编译时(compile-time)一元运算符sizeof,它可用来计算任一对象的长度。表达式
sizeof对象以及
sizeof(类型名)
将返回一个整型值,它等于指定对象或类型占用的存储空间字节数。(严格地说,sizeof的返回值是无符号整型值,其类型为size_t,该类型在头文件<stddef.h>中定义。)其中,对象可以是变量、数组或结构;类型可以是基本类型,如int、double,也可以是派生类型,如结构类型或指针类型。
在该例子中,关键字的个数等于数组的长度除以单个元素的长度。下面的#define语句使用了这种方法设置NKEYS的值:
#defineNKEYS(sizeofkeytab/sizeof(structkey))另一种方法是用数组的长度除以一个指定元素的长度,如下所示:
#defineNKEYS(sizeofkeytab/sizeof(keytab[0]))使用第二种方法,即使类型改变了,也不需要改动程序。
条件编译语句#if中不能使用sizeof,因为预处理器不对类型名进行分析。但预处理器并不计算#define语句中的表达式,因此,在#define中使用sizeof是合法的。
下面来讨论函数getword。我们这里给出一个更通用的getword函数。该函数的功能已超出这个示例程序的要求,不过,函数本身并不复杂。getword从输入中读取下一个单词,单词可以是以字母开头的字母和数字串,也可以是一个非空白符字符。函数返回值可能是单词的第一个字符、文件结束符EOF或字符本身(如果该字符不是字母字符的话)。
getword函数使用了第4章中的函数getch和ungetch。当读入的字符不属于字母数字的集合时,说明getword多读入了一个字符。随后,调用ungetch将多读的一个字符放回到输入中,以便下一次调用使用。Getword还使用了其它一些函数:isspace函数跳过空白符,isalpha函数识别字母,isalnum函数识别字母和数字。所有这些函数都定义在标准头文件<ctype.h>中。
练习6-1上述getword函数不能正确处理下划线、字符串常量、注释及预处理器控制指令。请编写一个更完善的getword函数。
6.4.指向结构的指针
为了进一步说明指向结构的指针和结构数组,我们重新编写关键字统计程序,这次采用指针,而不使用数组下标。
keytab的外部声明不需要修改,但main和binsearch函数必须修改。修改后的程序如下:
keytab的外部声明不需要修改,但main和binsearch函数必须修改。修改后的程序如下:
这里需要注意几点。首先,binsearch函数在声明中必须表明:它返回的值类型是一个指向structkey类型的指针,而非整型,这在函数原型及binsearch函数中都要声明。如果binsearch找到与输入单词匹配的数组元素,它将返回一个指向该元素的指针,否则返回NULL。
其次,keytab的元素在这里是通过指针访问的。这就需要对binsearch做较大的修改。
在这里,low和high的初值分别是指向表头元素的指针和指向表尾元素后面的一个元素的指针。
这样,我们就无法简单地通过下列表达式计算中间元素的位置:mid=(low+high)/2/*WRONG*/
这是因为,两个指针之间的加法运算是非法的。但是,指针的减法运算却是合法的,high-low的值就是数组元素的个数,因此,可以用下列表达式:
mid=low+(high-low)/2
将mid设置为指向位于high和low之间的中间元素的指针。
对算法的最重要修改在于,要确保不会生成非法的指针,或者是试图访问数组范围之外的元素。问题在于,&tab[-1]和&tab[n]都超出了数组tab的范围。前者是绝对非法的,而对后者的间接引用也是非法的。但是,C语言的定义保证数组末尾之后的第一个元素(即&tab[n])的指针算术运算可以正确执行。
主程序main中有下列语句:
for(p=keytab;p<keytab+NKEYS;p++)
如果p是指向结构的指针,则对p的算术运算需要考虑结构的长度,所以,表达式p++执行时,将在p的基础上加上一个正确的值,以确保得到结构数组的下一个元素,这样,上述测试条件便可以保证循环正确终止,
但是,千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要求,所以,结构中可能会出现未命名的“空穴“(hole)。例如,假设char类型占用一个字节,int类型占用4个字节,则下列结构:
struct{
charc;inti;
};
可能需要8个字节的存储空间,而不是5个字节。使用sizeof运算符可以返回正确的对象长度。
最后,说明一点程序的格式问题:当函数的返回值类型比较复杂时(如结构指针),例如structkey*binsearch(char*word,structkey*tab,intn)
很难看出函数名,也不太容易使用文本编辑器找到函数名。我们可以采用另一种格式书写上述语句:
structkey*
binsearch(char*word,structkey*tab,intn)
具体采用哪种写法属于个人的习惯问题,可以选择自己喜欢的方式并始终保持自己的风格。
6.5.自引用结构
假定我们需要处理一个更一般化的问题:统计输入中所有单词的出现次数。因为预先不知道出现的单词列表,所以无法方便地排序,并使用折半查找;也不能分别对输入中的每个单词都执行一次线性查找,看它在前面是否已经出现,这样做,程序的执行将花费太长的时间。(更准确地说,程序的执行时间是与输入单词数目的二次方成比例的。)我们该如何组织这些数据,才能够有效地处理一系列任意的单词呢?
一种解决方法是,在读取输入中任意单词的同时,就将它放置到正确的位置,从而始终保证所有单词是按顺序排列的。虽然这可以不用通过在线性数组中移动单词来实现,但它仍然会导致程序执行的时间过长。我们可以使用一种称为二叉树的数据结构来取而代之。
每个不同的单词在树中都是一个节点,每个节点包含:
.一个指向该单词内容的指针
.一个统计出现次数的计数值
.一个指向左子树的指针
.一个指向右子树的指针
任何节点最多拥有两个子树,也可能只有一个子树或一个都没有。
对节点的所有操作要保证,任何节点的左子树只包含按字典序小于该节点中单词的那些单词,右子树只包含按字典序大于该节点中单词的那些单词。图6-3是按序插入句子“nowisthetimeforallgoodmentocometotheaidoftheirparty”中各单词后生成的树。
图6-3
要查找一个新单词是否已经在树中,可以从根节点开始,比较新单词与该节点中的单词。若匹配,则得到肯定的答案。若新单词小于该节点中的单词,则在左子树中继续查找,否则在右子树中查找。如在搜寻方向上无子树,则说明新单词不在树中,并且,当前的空位置就是存放新加入单词的正确位置。因为从任意节点出发的查找都要按照同样的方式查找它的一个子树,所以该过程是递归的。相应地,在插入和打印操作中使用递归过程也是很自然的事情。
我们再来看节点的描述问题。最方便的表示方法是表示为包括4个成员的结构:
structtnode{/*thetreenode:*/
char*word;/*pointstothetext*/
intcount;/*numberofoccurrences*/
structtnode*left;
structtnode*right;};
/*leftchild*/
/*rightchild*/
这种对节点的递归的声明方式看上去好像是不确定的,但它的确是正确的。一个包含其自身实例的结构是非法的,但是,下列声明是合法的:
structtnode*left;
它将left声明为指向tnode的指针,而不是tnode实例本身。
我们偶尔也会使用自引用结构的一种变体:两个结构相互引用。具体的使用方法如下:
structt{
...
structs*p;/*ppointstoans*/
};
structs{
...
structt*q;/*qpointstoat*/
};
如下所示,整个程序的代码非常短小。当然,它需要我们前面编写的一些程序的支持,比如getword等。主函数通过getword读入单词,并通过addtree函数将它们插入到树中。
#include<stdio.h>
#include<ctype.h>
#include<string.h>
#defineMAXWORD100
structtnode*addtree(structtnode*,char*);
voidtreeprint(structtnode*);
intgetword(char*,int);
/*wordfrequencycount*/
main()
{
structtnode*root;
charword[MAXWORD];
root=NULL;
while(getword(word,MAXWORD)!=EOF)
if(isalpha(word[0]))
root=addtree(root,word);
treeprint(root);
return0;
}
函数addtree是递归的。主函数main以参数的方式传递给该函数的一个单词将作为树的最顶层(即树的根)。在每一步中,新单词与节点中存储的单词进行比较,随后,通过递归调用addtree而转向左子树或右子树。该单词最终将与树中的某节点匹配(这种情况下计数值加1),或遇到一个空指针(表明必须创建一个节点并加入到树中)。若生成了新节点,则addtree返回一个指向新节点的指针,该指针保存在父节点中。
structtnode*talloc(void);char*strdup(char*);
/*addtree:addanodewithw,atorbelowp*/
structtreenode*addtree(structtnode*p,char*w)
{
intcond;
if(p==NULL){/*anewwordhasarrived*/
p=talloc();/*makeanewnode*/
p->word=strdup(w);
p->count=1;
p->left=p->right=NULL;
}elseif((cond=strcmp(w,p->word))==0)
p->count++;/*repeatedword*/
elseif(cond<0)/*lessthanintoleftsubtree*/
p->left=addtree(p->left,w);
else/*greaterthanintorightsubtree*/
p->right=addtree(p->right,w);
returnp;
}
新节点的存储空间由子程序talloc获得。talloc函数返回一个指针,指向能容纳一个树节点的空闲空间。函数strdup将新单词复制到某个隐藏位置(稍后将讨论这些子程序)。计数值将被初始化,两个子树被置为空(NULL)。增加新节点时,这部分代码只在树叶部分执行。该程序忽略了对strdup和talloc返回值的出错检查(这显然是不完善的)。
treeprint函数按顺序打印树。在每个节点,它先打印左子树(小于该单词的所有单词),然后是该单词本身,最后是右子树(大于该单词的所有单词)。如果你对递归操作有些疑惑的话,不妨在上面的树中模拟treeprint的执行过程。
/*treeprint:in-orderprintoftreep*/
voidtreeprint(structtnode*p)
{
if(p!=NULL){
treeprint(p->left);
printf("%4d%s\n",p->count,p->word);
treeprint(p->right);
}
}
这里有一点值得注意:如果单词不是按照随机的顺序到达的,树将变得不平衡,这种情况下,程序的运行时间将大大增加。最坏的情况下,若单词已经排好序,则程序模拟线性查找的开销将非常大。某些广义二叉树不受这种最坏情况的影响,在此我们不讨论。
在结束该例子之前,我们简单讨论一下有关存储分配程序的问题。尽管存储分配程序需要为不同的对象分配存储空间,但显然,程序中只会有一个存储分配程序。但是,假定用一个分配程序来处理多种类型的请求,比如指向char类型的指针和指向structtnode类型的指针,则会出现两个问题。第一,它如何在大多数实际机器上满足各种类型对象的对齐要求(例如,整型通常必须分配在偶数地址上),第二,使用什么样的声明能处理分配程序必须能返回不同类型的指针的问题?
对齐要求一般比较容易满足,只需要确保分配程序始终返回满足所有对齐限制要求的指针就可以了,其代价是牺牲一些存储空间。第5章介绍的alloc函数不保证任何特定类型的对齐,所以,我们使用标准库函数malloc,它能够满足对齐要求。第8章将介绍实现malloc函数的一种方法。
对于任何执行严格类型检查的语言来说,像malloc这样的函数的类型声明总是很令人头疼的问题。在C语言中,一种合适的方法是将malloc的返回值声明为一个指向void类型的指针,然后再显式地将该指针强制转换为所需类型。malloc及相关函数声明在标准头文件<stdlib.h>中。因此,可以把talloc函数写成下列形式:
#include<stdlib.h>
/*talloc:makeatnode*/structtnode*talloc(void){
return(structtnode*)malloc(sizeof(structtnode));}
strdup函数只是把通过其参数传入的字符串复制到某个安全的位置。它是通过调用malloc函数实现的:
char*strdup(char*s)/*makeaduplicateofs*/
{
char*p;
p=(char*)malloc(strlen(s)+1);/*+1for'\0'*/
if(p!=NULL)
strcpy(p,s);
returnp;
}
在没有可用空间时,malloc函数返回NULL,同时,strdup函数也将返回NULL,strdup函数的调用者负责出错处理。
调用malloc函数得到的存储空间可以通过调用free函数释放以重用。详细信息请参见第7章和第8章。
练习6-2编写一个程序,用以读入一个C语言程序,并按字母表顺序分组打印变量名,要求每一组内各变量名的前6个字符相同,其余字符不同。字符串和注释中的单词不予考虑。请将6作为一个可在命令行中设定的参数。
练习6-3编写一个交叉引用程序,打印文档中所有单词的列表,并且每个单词还有一个列表,记录出现过该单词的行号。对the、and等非实义单词不予考虑。
练习6-4编写一个程序,根据单词的出现频率按降序打印输入的各个不同单词,并在每个单词的前面标上它的出现次数。
6.6.表查找
为了对结构的更多方面进行深入的讨论,我们来编写一个表查找程序包的核心部分代码。这段代码很典型,可以在宏处理器或编译器的符号表管理例程中找到。例如,考虑#define语句。当遇到类似于
#defineIN1
之类的程序行时,就需要把名字IN和替换文本1存入到某个表中。此后,当名字IN出现在某些语句中时,如:
statet=IN;就必须用1来替换IN。
以下两个函数用来处理名字和替换文本。install(s,t)函数将名字s和替换文本t记录到某个表中,其中s和t仅仅是字符串。lookup(s)函数在表中查找s,若找到,则返回指向该处的指针;若没找到,则返回NULL。
该算法采用的是散列查找方法——将输入的名字转换为一个小的非负整数,该整数随后将作为一个指针数组的下标。数组的每个元素指向某个链表的表头,链表中的各个块用于描述具有该散列值的名字。如果没有名字散列到该值,则数组元素的值为NULL(参见图6-4)。
图6-4
链表中的每个块都是一个结构,它包含一个指向名字的指针、一个指向替换文本的指针以及一个指向该链表后继块的指针。如果指向链表后继块的指针为NULL,则表明链表结束。
structnlist{/*tableentry:*/
structnlist*next;/*nextentryinchain*/
char*name;/*definedname*/
char*defn;/*replacementtext*/
};
相应的指针数组定义如下:
#defineHASHSIZE101
staticstructnlist*hashtab[HASHSIZE];/*pointertable*/
散列函数hash在lookup和install函数中都被用到,它通过一个for循环进行计算,每次循环中,它将上一次循环中计算得到的结果值经过变换(即乘以31)后得到的新值同字符串中当前字符的值相加(*s+31*hashval),然后将该结果值同数组长度执行取模操作,其结果即是该函数的返回值。这并不是最好的散列函数,但比较简短有效。
/*hash:formhashvalueforstrings*/
unsignedhash(char*s)
{
unsignedhashval;
for(hashval=0;*s!='\0';s++)
hashval=*s+31*hashval;
returnhashval%HASHSIZE;
}
由于在散列计算时采用的是无符号算术运算,因此保证了散列值非负。
散列过程生成了在数组hashtab中执行查找的起始下标。如果该字符串可以被查找到,
则它一定位于该起始下标指向的链表的某个块中。具体查找过程由lookup函数实现。如果lookup函数发现表项已存在,则返回指向该表项的指针,否则返回NULL。
/*lookup:lookforsinhashtab*/
structnlist*lookup(char*s)
{
structnlist*np;
for(np=hashtab[hash(s)];np!=NULL;np=np->next)
if(strcmp(s,np->name)==0)
returnnp;/*found*/
returnNULL;/*notfound*/
}
lookup函数中的for循环是遍历一个链表的标准方法,如下所示:
for(ptr=head;ptr!=NULL;ptr=ptr->next)
...
install函数借助lookup函数判断待加入的名字是否已经存在。如果已存在,则用新的定义取而代之;否则,创建一个新表项。如无足够空间创建新表项,则install函数返回NULL。
structnlist*lookup(char*);
char*strdup(char*);
/*install:put(name,defn)inhashtab*/
structnlist*install(char*name,char*defn){
structnlist*np;unsignedhashval;
if((np=lookup(name))==NULL){/*notfound*/
np=(structnlist*)malloc(sizeof(*np));
if(np==NULL||(np->name=strdup(name))==NULL)
returnNULL;
hashval=hash(name);
np->next=hashtab[hashval];
hashtab[hashval]=np;
}else/*alreadythere*/
free((void*)np->defn);/*freepreviousdefn*/
if((np->defn=strdup(defn))==NULL)
returnNULL;
returnnp;
}
练习6-5编写函数undef,它将从由lookup和install维护的表中删除一个变量
及其定义。
练习6-6以本节介绍的函数为基础,编写一个适合C语言程序使用的#define处理器的简单版本(即无参数的情况)。你会发现getch和ungetch函数非常有用。
6.7.类型定义(typedef)
C语言提供了一个称为typedef的功能,它用来建立新的数据类型名,例如,声明
typedefintLength;
将Length定义为与int具有同等意义的名字。类型Length可用于类型声明、类型转换等,它和类型int完全相同,例如:
Lengthlen,maxlen;
Length*lengths[];类似地,声明
typedefchar*String;
将String定义为与char*或字符指针同义,此后,便可以在类型声明和类型转换中使用String,例如:
Stringp,lineptr[MAXLINES],alloc(int);intstrcmp(String,String);
p=(String)malloc(100);
注意,typedef中声明的类型在变量名的位置出现,而不是紧接在关键字typedef之后。typedef在语法上类似于存储类extern、static等。我们在这里以大写字母作为typedef定义的类型名的首字母,以示区别。
这里举一个更复杂的例子:用typedef定义本章前面介绍的树节点。如下所示:typedefstructtnode*Treeptr;
typedefstructtnode{/*thetreenode:*/
char*word;/*pointstothetext*/
intcount;/*numberofoccurrences*/
structtnode*left;/*leftchild*/
structtnode*right;/*rightchild*/
}Treenode;
上述类型定义创建了两个新类型关键字:Treenode(一个结构)和Treeptr(一个指向该结构的指针)。这样,函数talloc可相应地修改为:
Treeptrtalloc(void)
{
return(Treeptr)malloc(sizeof(Treenode));
}
这里必须强调的是,从任何意义上讲,typedef声明并没有创建一个新类型,它只是为某个已存在的类型增加了一个新的名称而已。typedef声明也没有增加任何新的语义:通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。实际上,typedef类似于#define语句,但由于typedef是由编译器解释的,因此它的文本替换功能要超过预处理器的能力。例如:
typedefint(*PFI)(char*,char*);
该语句定义了类型PFI是“一个指向函数的指针,该函数具有两个char*类型的参数,返回值类型为int”,它可用于某些上下文中,例如,可以用在第5章的排序程序中,如下所示:
PFIstrcmp,numcmp;
除了表达方式更简洁之外,使用typedef还有另外两个重要原因。首先,它可以使程序参数化,以提高程序的可移植性。如果typedef声明的数据类型同机器有关,那么,当程序
移植到其它机器上时,只需改变typedef类型定义就可以了。一个经常用到的情况是,对于各种不同大小的整型值来说,都使用通过typedef定义的类型名,然后,分别为各个不同的宿主机选择一组合适的short、int和long类型大小即可。标准库中有一些例子,例如size_t和ptrdiff_t等。
typedef的第二个作用是为程序提供更好的说明性——Treeptr类型显然比一个声明为指向复杂结构的指针更容易让人理解。
6.8.联合
联合是可以(在不同时刻)保存不同类型和长度的对象的变量,编译器负责跟踪对象的长度和对齐要求。联合提供了一种方式,以在单块存储区中管理不同类型的数据,而不需要在程序中嵌入任何同机器有关的信息。它类似于Pascal语言中的变体记录。
我们来看一个例子(可以在编译器的符号表管理程序中找到该例子)。假设一个常量可能是int、f1oat或字符指针。特定类型的常量值必须保存在合适类型的变量中,然而,如果该常量的不同类型占据相同大小的存储空间,且保存在同一个地方的话,表管理将最方便。这就是联合的目的——一个变量可以合法地保存多种数据类型中任何一种类型的对象。其语法基于结构,如下所示:
unionu_tag{
intival;
floatfval;
char*sval;
}u;
变量u必须足够大,以保存这3种类型中最大的一种,具体长度同具体的实现有关。这些类型中的任何一种类型的对象都可赋值给u,且可使用在随后的表达式中,但必须保证是一致的:读取的类型必须是最近一次存入的类型。程序员负责跟踪当前保存在联合中的类型。如果保存的类型与读取的类型不一致,其结果取决于具体的实现。
可以通过下列语法访问联合中的成员:
联合名.成员或
联合指针->成员
它与访问结构的方式相同。如果用变量utype跟踪保存在u中的当前数据类型,则可以像下面这样使用联合:
if(utype==INT)
printf("%d\n",u.ival);
if(utype==FLOAT)
printf("%f\n",u.fval);
if(utype==STRING)
printf("%s\n",u.sval);
else
printf("badtype%dinutype\n",utype);
联合可以使用在结构和数组中,反之亦可。访问结构中的联合(或反之)的某一成员的表示法与嵌套结构相同。例如,假定有下列的结构数组定义:
struct{
char*name;
intflags;
intutype;
union{
intival;
floatfval;
char*sval;
}u;
}symtab[NSYM];
可以通过下列语句引用其成员ival:symtab[i].u.ival
也可以通过下列语句之一引用字符串sval的第一个字符:
*symtab[i].u.sval
symtab[i].u.sval[0]
实际上,联合就是一个结构,它的所有成员相对于基地址的偏移量都为0,此结构空间要大到足够容纳最“宽”的成员,并且,其对齐方式要适合于联合中所有类型的成员。对联合允许的操作与对结构允许的操作相同:作为一个整体单元进行赋值、复制、取地址及访问其中一个成员。
联合只能用其第一个成员类型的值进行初始化,因此,上述联合u只能用整数值进行初始化。
第8章的存储分配程序将说明如何使用联合来强制一个变量在特定类型的存储边界上对齐。
6.9.位字段
在存储空间很宝贵的情况下,有可能需要将多个对象保存在一个机器字中。一种常用的方法是,使用类似于编译器符号表的单个二进制位标志集合。外部强加的数据格式(如硬件设备接口)也经常需要从字的部分值中读取数据。
考虑编译器中符号表操作的有关细节。程序中的每个标识符都有与之相关的特定信息,例如,它是否为关键字,它是否是外部的且(或)是静态的,等等。对这些信息进行编码的最简洁的方法就是使用一个char或int对象中的位标志集合。
通常采用的方法是,定义一个与相关位的位置对应的“屏蔽码”集合,如:
#defineKEYWORD01
#defineEXTRENAL02
#defineSTATIC04
或
enum{KEYWORD=01,EXTERNAL=02,STATIC=04};
这些数字必须是2的幂。这样,访问这些位就变成了用第2章中描述的移位运算、屏蔽运算及补码运算进行简单的位操作。
下列语句在程序中经常出现:
flags|=EXTERNAL|STATIC;
该语句将flags中的EXTERNAL和STATIC位置为1,而下列语句:flags&=~(EXTERNAL|STATIC);
则将它们置为0。并且,当这两位都为0时,下列表达式:
if((flags&(EXTERNAL|STATIC))==0)...的值为真。
尽管这些方法很容易掌握,但是,C语言仍然提供了另一种可替代的方法,即直接定义和访问一个字中的位字段的能力,而不需要通过按位逻辑运算符。位字段(bit-field),或简称字段,是“字”中相邻位的集合。“字”(word)是单个的存储单元,它同具体的实现有关。例如,上述符号表的多个#define语句可用下列3个字段的定义来代替:
struct{
unsignedintis_keyword:1;unsignedintis_extern:1;unsignedintis_static:1;
}flags;
这里定义了一个变量flags,它包含3个一位的字段。冒号后的数字表示字段的宽度(用二进制位数表示)。字段被声明为unsignedint类型,以保证它们是无符号量。
单个字段的引用方式与其它结构成员相同,例如:flags.is_keyword、flags.is_extern等等。字段的作用与小整数相似。同其它整数一样,字段可出现在算术表达式中。因此,上面的例子可用更自然的方式表达为:
flags.is_extern=flags.is_static=1;该语句将is_extern和is_static位置为1。下列语句:
flags.is_extern=flags.is_static=0;将is_extern和is_static位置为0。下列语句:
if(flags.is_extern==0&&flags.is_static==0)
...
用于对is_extern和is_static位进行测试。
字段的所有属性几乎都同具体的实现有关。字段是否能覆盖字边界由具体的实现定义。字段可以不命名,无名字段(只有一个冒号和宽度)起填充作用。特殊宽度0可以用来强制在下一个字边界上对齐。
某些机器上字段的分配是从字的左端至右端进行的,而某些机器上则相反。这意味着,尽管字段对维护内部定义的数据结构很有用,但在选择外部定义数据的情况下,必须仔细考虑哪端优先的问题。依赖于这些因素的程序是不可移植的。字段也可以仅仅声明为int,为了方便移植,需要显式声明该int类型是signed还是unsigned类型。字段不是数组,并且没有地址,因此对它们不能使用&运算符。
第7章输入与输出
输入/输出功能并不是C语言本身的组成部分,所以到目前为止,我们并没有过多地强调它们。但是,程序与环境之间的交互比我们在前面部分中描述的情况要复杂很多,本章将讲述标准库,介绍一些输入/输出函数、字符串处理函数、存储管理函数与数学函数,以及其它一些C语言程序的功能。本章讨论的重点将放在输入/输出上。
ANSI标准精确地定义了这些库函数,所以,在任何可以使用C语言的系统中都有这些函数的兼容形式。如果程序的系统交互部分仅仅使用了标准库提供的功能,则可以不经修改地从一个系统移植到另一个系统中。
这些库函数的属性分别在十多个头文件中声明,前面已经遇到过一部分,如<stdio.h>、<string.h>和<ctype.h>。我们不打算把整个标准库都罗列于此,因为我们更关心如何使用标准库编写C语言程序。附录B对标准库进行了详细的描述。
7.1.标准输入/输出
我们在第1章中讲过,标准库实现了简单的文本输入/输出模式。文本流由一系列行组成,每一行的结尾是一个换行符。如果系统没有遵循这种模式,则标准库将通过一些措施使得该系统适应这种模式。例如,标准库可以在输入端将回车符和换行符都转换为换行符,而在输出端进行反向转换。
最简单的输入机制是使用getchar函数从标准输入中(一般为键盘)一次读取一个字符:intgetchar(void)
getchar函数在每次被调用时返回下一个输入字符。若遇到文件结尾,则返回EOF。符号常量EOF在头文件<stdio.h>中定义,其值一般为-1,但程序中应该使用EOF来测试文件是否结束,这样才能保证程序同EOF的特定值无关。
在许多环境中,可以使用符号<来实现输入重定向,它将把键盘输入替换为文件输入:如果程序prog中使用了函数getchar,则命令行
prog<infile
将使得程序prog从输入文件infile(而不是从键盘)中读取字符。实际上,程序prog本身并不在意输入方式的改变,并且,字符串"<infile"也并不包含在argv的命令行参数中。如果输入通过管道机制来自于另一个程序,那么这种输入切换也是不可见的。比如,在某些系统中,下列命令行:
otherprog|prog
将运行两个程序otherprog和prog,并将程序otherprog的标准输出通过管道重定向到程序prog的标准输入上。
函数
intputchar(int)
用于输出数据。putchar(c)将字符c送至标准输出上,在默认情况下,标准输出为屏幕显示。如果没有发生错误,则函数putchar将返同输出的字符;如果发生了错误,则返回EOF。同样,通常情况下,也可以使用“>输出文件名”的格式将输出重定向到某个文件中。例如,
如果程序prog调用了函数putchar,那么命令行prog>输出文件名
将把程序prog的输出从标准输出设备重定向到文件中。如果系统支持管道,那么命令行prog|anotherprog
将把程序prog的输出从标准输出通过管道重定向到程序anotherprog的标准输入中。
函数printf也向标准输出设备上输出数据。我们在程序中可以交叉调用函数putchar和printf,输出将按照函数调用的先后顺序依次产生。
使用输入/输出库函数的每个源程序文件必须在引用这些函数之前包含下列语句#include<stdio.h>
当文件名用一对尖括号<和>括起来时,预处理器将在由具体实现定义的有关位置中查找指定的文件(例如,在UNIX系统中,文件一般放在目录/usr/include中)。
许多程序只从一个输入流中读取数据,并且只向一个输出流中输出数据。对于这样的程序,只需要使用函数getchar、putchar和printf实现输入/输出即可,并且对程序来说已经足够了。特别是,如果通过重定向将一个程序的输出连接到另一个程序的输入,仅仅使用这些函数就足够了。例如,考虑下列程序lower,它用于将输入转换为小写字母的形式:
#include<stdio.h>
#include<ctype.h>
main()/*lower:convertinputtolowercase*/{
intc
while((c=getchar())!=EOF)
putchar(tolower(c));
return0;
}
函数tolower在头文件<ctype.h>中定义,它把大写字母转换为小写形式,并把其它字符原样返回。我们在前面提到过,头文件<stdio.h>中的getchar和putchar“函数”以及<ctype.h>中的tolower“函数”一般都是宏,这样就避免了对每个字符都进行函数调用的开销。我们将在8.5节介绍它们的实现方法。无论<ctype.h>中的函数在给定的机器上是如何实现的,使用这些函数的程序都不必了解字符集的知识。
练习7-1编写一个程序,根据它自身被调用时存放在argv[0]中的名字,实现将大
写字母转换为小写字母或将小写字母转换为大写字母的功能。
7.2.格式化输出——printf函数
输出函数printf将内部数值转换为字符的形式。前面的有关章节中已经使用过该函数。
下面只讲述该函数最典型的用法,附录B中给出了该函数完整的描述。intprintf(char*format,arg1,arg2,...);
函数printf在输出格式format的控制下,将其参数进行转换与格式化,并在标准输出设备上打印出来。它的返回值为打印的字符数。
格式字符串包含两种类型的对象:普通字符和转换说明。在输出时,普通字符将原样不动地复制到输出流中,而转换说明并不直接输出到输出流中,而是用于控制printf中参数的转换和打印,每个转换说明都由一个百分号字符(即%)开始,并以一个转换字符结束。在字符%和转换字符中间可能依次包含下列组成部分:
.负号,用于指定被转换的参数按照左对齐的形式输出。
.数,用于指定最小字段宽度。转换后的参数将打印不小于最小字段宽度的字段。如果有必要,字段左边(如果使用左对齐的方式,则为右边)多余的字符位置用空格填充以保证最小字段宽。
.小数点,用于将字段宽度和精度分开。
.数,用于指定精度,即指定字符串中要打印的最大字符数、浮点数小数点后的位数、整型最少输出的数字数目。
.字母h或l,字母h表不将整数作为short类型打印,字母l表示将整数作为long类型打印。
表7-1列出了所有的转换字符,如果%后面的字符不是一个转换说明,则该行为是未定义的。
表7-1printf函数基本的转换说明
字符参数类型:输出形式
d,iint类型;十进制数
oint类型;无符号八进制数(没有前导0)
x,Xint类型;无符号十六进制数(没有前导0x或0X),10~15分别用abcdef或ABCDEF表示
uint类型;无符号十进制数
cint类型;单个字符
schar*类型;顺序打印字符串中的字符,直到遇到'\0'或已打印了由精度指定的字符数为止
fdouble类型;十进制小数[-]m.dddddd,其中d的个数由精度指定(默认值为6)
e,Edouble类型;[-]m.dddddde±xx或[-]m.ddddddE±xx,其中d的个数由精度指定(默认值为6)
g,Gdouble类型;如果指数小于-4或大于等于精度,则用%e或%E格式输出,否则用%f格式输出。尾部的0和小数点不打印
pvoid*类型;指针(取决于具体实现)
%不转换参数;打印一个百分号%
在转换说明中,宽度或精度可以用星号*表示,这时,宽度或精度的值通过转换下一参数(必须为int类型)来计算。例如,为了从字符串s中打印最多max个字符,可以使用下列语句:
printf("%.*s",max,s);
前面的章节中已经介绍过大部分的格式转换,但没有介绍与字符串相关的精度。下表说明了在打印字符串"hello,world"(12个字符)时根据不同的转换说明产生的不同结果。我们在每个字段的左边和右边加上冒号,这样可以清晰地表示出字段的宽度。
:%s:
:%10s:
:%.10s:
:%-10s:
:%.15s:
:%-15s:
:%15.10s:
:%-15.10s:
:hello,world::hello,world::hello,wor:
:hello,world::hello,world:
:hello,world:
:hello,wor:
:hello,wor:
注意:函数printf使用第一个参数判断后面参数的个数及类型。如果参数的个数不够或者类型错误,则将得到错误的结果。请注意下面两个函数调用之间的区别:
printf(s);/*FAILSifscontains%*/
printf("%s",s);/*SAFE*/
函数sprintf执行的转换和函数printf相同,但它将输出保存到一个字符串中:intsprintf(char*string,char*format,arg1,arg2,...);
sprintf函数和printf函数一样,按照format格式格式化参数序列arg1、arg2、…,但它将输出结果存放到string中,而不是输出到标准输出中。当然,string必须足够大以存放输出结果。
练习7-2编写一个程序,以合理的方式打印任何输入。该程序至少能够根据用户的习惯以八进制或十六进制打印非图形字符,并截断长文本行。
7.3.变长参数表
本节以实现函数printf的一个最简单版本为例,介绍如何以可移植的方式编写可处理变长参数表的函数。因为我们的重点在于参数的处理,所以,函数minprintf只处理格式字符串和参数,格式转换则通过调用函数printf实现。
函数printf的正确声明形式为:intprintf(char*fmt,...)
其中,省略号表示参数表中参数的数量和类型是可变的。省略号只能出现在参数表的尾部。因为minprintf函数不需要像printf函数一样返回实际输出的字符数,因此,我们将它声明为下列形式:
voidminprintf(char*fmt,...)
编写函数minprintf的关键在于如何处理一个甚至连名字都没有的参数表。标准头文件<stdarg.h)中包含一组宏定义,它们对如何遍历参数表进行了定义。该头文件的实现因不同的机器而不同,但提供的接口是一致的。
va_list类型用于声明一个变量,该变量将依次引用各参数。在函数minprintf中,我们将该变量称为ap,意思是“参数指针”。宏va_start将ap初始化为指向第一个无名参数的指针。在使用ap之前,该宏必须被调用一次。参数表必须至少包括一个有名参数,va_start将最后一个有名参数作为起点。
每次调用va_arg,该函数都将返回一个参数,并将ap指向下一个参数。va_arg使用一个类型名来决定返回的对象类型、指针移动的步长。最后,必须在函数返回之前调用va_end,以完成一些必要的清理工作。
基于上面这些讨论,我们实现的简化printf函数如下所示:#include<stdarg.h>
/*minprintf:minimalprintfwithvariableargumentlist*/
voidminprintf(char*fmt,...)
{
va_listap;/*pointstoeachunnamedarginturn*/char*p,*sval;
intival;
doubledval;
va_start(ap,fmt);/*makeappointto1stunnamedarg*/
for(p=fmt;*p;p++){
if(*p!='%'){putchar(*p);continue;
}
switch(*++p){case'd':
ival=va_arg(ap,int);printf("%d",ival);
break;
case'f':
dval=va_arg(ap,double);
printf("%f",dval);
break;
case's':
for(sval=va_arg(ap,char*);*sval;sval++)
putchar(*sval);
break;
default:
putchar(*p);
break;
}
}
va_end(ap);/*cleanupwhendone*/}
练习7-3改写minprintf函数,使它能完成printf函数的更多功能。
7.4.格式化输入——scanf函数
输入函数scanf对应于输出函数printf,它在与后者相反的方向上提供同样的转换功能。具有变长参数表的函数scanf的声明形式如下:
intscanf(char*format,...)
scanf函数从标准输入中读取字符序列,按照format中的格式说明对字符序列进行解释,并把结果保存到其余的参数中。格式参数format将在接下来的内容中进行讨论。其它所有参数都必须是指针,用于指定经格式转换后的相应输入保存的位置。和上节讲述printf一样,本节只介绍scanf函数最有用的一些特征,而并不完整地介绍。
当scanf函数扫描完其格式串,或者碰到某些输入无法与格式控制说明匹配的情况时,该函数将终止,同时,成功匹配并赋值的输入项的个数将作为函数值返回,所以,该函数的
返回值可以用来确定已匹配的输入项的个数。如果到达文件的结尾,该函数将返回EOF。注意,返回EOF与0是不同的,0表示下一个输入字符与格式串中的第一个格式说明不匹配。下一次调用scanf函数将从上一次转换的最后一个字符的下一个字符开始继续搜索。
另外还有一个输入函数sscanf,它用于从一个字符串(而不是标准输入)中读取字符序列:
intsscanf(char*string,char*format,arg1,arg2,...)
它按照格式参数format中规定的格式扫描字符串string,并把结果分别保存到arg1、arg2、…这些参数中。这些参数必须是指针。
格式串通常都包含转换说明,用于控制输入的转换。格式串可能包含下列部分:
.空格或制表符,在处理过程中将被忽略。
.普通字符(不包括%),用于匹配输入流中下一个非空白符字符。
.转换说明,依次由一个%、一个可选的赋值禁止字符*、一个可选的数值(指定最大字段宽度)、一个可选的h、l或L字符(指定目标对象的宽度)以及一个转换字符组成。
转换说明控制下一个输入字段的转换。一般来说,转换结果存放在相应的参数指向的变量中。但是,如果转换说明中有赋值禁止字符*,则跳过该输入字段,不进行赋值。输入字段定义为一个不包括空白符的字符串,其边界定义为到下一个空白符或达到指定的字段宽度。这表明scanf函数将越过行边界读取输入,因为换行符也是空白符。(空白符包括空格符、横向制表符、换行符、回车符、纵向制表符以及换页符)。
转换字符指定对输入字段的解释。对应的参数必须是指针,这也是C语言通过值调用语义所要求的。表7-2中列出了这些转换字符。
表7-2scanf函数的基本转换说明
字符输入数据;参数类型
d十进制整数;int*类型
i整数;int*类型,可以是八进制(以0开头)或十六进制(以0x或0X开头)
o八进制整数(可以以0开头,也可以不以0开头);int*类型
u无符号十进制整数;unsignedint*类型
x十六进制整数(可以0x或0X开头,也可以不以0x或0X开头);int*类型
c字符;char*类型,将接下来的多个输入字符(默认为1个字符)存放到指定位置。该转换规范通常不跳过空白符。如果需要读入下一个非空白符,可以使用%1s
s字符串(不加引号);char*类型,指向一个足以存放该字符串(还包括尾部的字符'\0')的字符数组。字符串的末尾将被添加一个结束符'\0'
e,f,g浮点数,它可以包括正负号(可选)、小数点(可选)及指数部分(可选);float*类型
%字符%;不进行任何赋值操作
转换说明d、i、o、u及x的前面可以加上字符h或l。前缀h表明参数表的相应参数是一个指向short类型而非int类型的指针,前缀l表明参数表的相应参数是一个指向long类型的指针。类似地,转换说明e、f和g的前面也可以加上前缀l,它表明参数表的相应参数是一个指向double类型而非float类型的指针。
来看第一个例子。我们通过函数scanf执行输入转换来改写第4章中的简单计算器程序,
如下所示:
#include<stdio.h>
main()/*rudimentarycalculator*/
{
doublesum,v;
sum=0;
while(scanf("%lf",&v)==1)
printf("\t%.2f\n",sum+=v);
return0;
}
假设我们要读取包含下列日期格式的输入行:
25Dec1988
相应的scanf语句可以这样编写:
intday,year;
charmonthname[20];
scanf("%d%s%d",&day,monthname,&year);
因为数组名本身就是指针,所以,monthname的前面没有取地址运算符&。
字符字面值也可以出现在scanf的格式串中,它们必须与输入中相同的字符匹配。因此,我们可以使用下列scanf语句读入形如mm/dd/yy的日期数据:
intday,month,year;
scanf("%d/%d/%d",&month,&day,&year);
scanf函数忽略格式串中的空格和制表符。此外,在读取输入值时,它将跳过空白符(空格、制表符、换行符等等)。如果要读取格式不固定的输入,最好每次读入一行,然后再用sscanf将合适的格式分离出来读入。例如,假定我们需要读取一些包含日期数据的输入行,日期的格式可能是上述任一种形式。我们可以这样编写程序:
while(getline(line,sizeof(line))>0){
if(sscanf(line,"%d%s%d",&day,monthname,&year)==3)
printf("valid:%s\n",line);/*25Dec1988form*/
elseif(sscanf(line,"%d/%d/%d",&month,&day,&year)==3)
printf("valid:%s\n",line);/*mm/dd/yyform*/
else
printf("invalid:%s\n",line);/*invalidform*/}
scanf函数可以和其它输入函数混合使用。无论调用哪个输入函数,下一个输入函数的调用将从scanf没有读取的第一个字符处开始读取数据。
注意,scanf和sscanf函数的所有参数都必须是指针。最常见的错误是将输入语句写成下列形式:
scanf("%d",n);正确的形式应该为:
scanf("%d",&n);
编译器在编译时一般检测不到这类错误。
练习7-4类似于上一节中的函数minprintf,编写scanf函数的一个简化版本。
练习7-5改写第4章中的后缀计算器程序,用scanf函数和(或)sscanf函数实现输入以及数的转换。
7.5.文件访问
到目前为止,我们讨论的例子都是从标准输入读取数据,并向标准输出输出数据。标准输入和标准输出是操作系统自动提供给程序访问的。
接下来,我们编写一个访问文件的程序,且它所访问的文件还没有连接到该程序。程序cat可以用来说明该问题,它把一批命名文件串联后输出到标准输出上。cat可用来在屏幕上打印文件,对于那些无法通过名字访问文件的程序来说。它还可以用作通用的输入收集器。例如,下列命令行:
catx.cy.c
将在标准输出上打印文件x.c和y.c的内容。
问题在于,如何设计命名文件的读取过程呢?换句话说,如何将用户需要使用的文件的外部名同读取数据的语句关联起来。
方法其实很简单。在读写一个文件之前,必须通过库函数fopen打开该文件。fopen用类似于x.c或y.c这样的外部名与操作系统进行某些必要的连接和通信(我们不必关心这些细节),并返回一个随后可以用于文件读写操作的指针。
该指针称为文件指针,它指向一个包含文件信息的结构,这些信息包括:缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等。用户不必关心这些细节,因为<stdio.h>中已经定义了一个包含这些信息的结构FILE。在程序中只需按照下列方式声明一个文件指针即可:
FILE*fp;
FILE*fopen(char*name,char*mode);
在本例中,fp是一个指向结构FILE的指针,并且,fopen函数返回一个指向结构FILE的
指针。注意,FILE像int一样是一个类型名,而不是结构标记。它是通过typedef定义的(UNIX系统中fopen的实现细节将在8.5节中讨论)。
在程序中,可以这样调用fopen函数:fp=fopen(name,mode);
fopen的第一个参数是一个字符串,它包含文件名。第二个参数是访问模式,也是一个字符串,用于指定文件的使用方式。允许的模式包括:读(“r”)、写(“w”)及追加(“a”)。某些系统还区分文本文件和二进制文件,对后者的访问需要在模式字符串中增加字符“b”。
如果打开一个不存在的文件用于写或追加,该文件将被创建(如果可能的话)。当以写方式打开一个已存在的文件时,该文件原来的内容将被覆盖。但是,如果以追加方式打开一个文件,则该文件原来的内容将保留不变。读一个不存在的文件会导致错误,其它一些操作也可能导致错误,比如试图读取一个无读取权限的文件。如果发生错误,fopen将返回NULL。
(可以更进一步地定位错误的类型,具体方法请参见附录B.1节中关于错误处理函数的讨论。)
文件被打开后,就需要考虑采用哪种方法对文件进行读写。有多种方法可供考虑,其中,getc和putc函数最为简单。getc从文件中返回下一个字符,它需要知道文件指针,以确定对哪个文件执行操作:
intgetc(FILE*fp)
getc函数返回fp指向的输入流中的下一个字符。如果到达文件尾或出现错误,该函数将返回EOF,
putc是一个输出函数,如下所示:intputc(intc,FILE*fp)
该函数将字符c写入到fp指向的文件中,并返回写入的字符。如果发生错误,则返回EOF。类似于getchar和putchar,getc和putc是宏而不是函数。
启动一个C语言程序时,操作系统环境负责打开3个文件,并将这3个文件的指针提供给该程序。这3个文件分别是标准输入、标准输出和标准错误,相应的文件指针分别为stdin、stdout和stderr,它们在<stdio.h>中声明。在大多数环境中,stdin指向键盘,而stdout和stderr指向显示器。我们从7.1节的讨论中可以知道,stdin和stdout可以被重定向到文件或管道。
getchar和putchar函数可以通过getc、putc、stdin及stdout定义如下:
#definegetchar()getc(stdin)
#defineputchar(c)putc((c),stdout)
对于文件的格式化输入或输出,可以使用函数fscanf和fprintf。它们与scanf和printf函数的区别仅仅在于它们的第一个参数是一个指向所要读写的文件的指针,第二个参数是格式串。如下所示:
intfscanf(FILE*fp,char*format,...)
intfprintf(FILE*fp,char*format,...)
掌握这些预备知识之后,我们现在就可以编写出将多个文件连接起来的cat程序了。该程序的设计思路和其它许多程序类似。如果有命令行参数,参数将被解释为文件名,并按顺序逐个处理。如果没有参数,则处理标准输入。
#include<stdio.h>
/*cat:concatenatefiles,version1*/
main(intargc,char*argv[])
{
FILE*fp;
voidfilecopy(FILE*,FILE*)
if(argc==1)/*noargs;copystandardinput*/
filecopy(stdin,stdout);
else
while(--argc>0)
if((fp=fopen(*++argv,"r"))==NULL){
printf("cat:can'topen%s\n,*argv);
return1;
}else{
}
filecopy(fp,stdout);
fclose(fp);
}
return0;
/*filecopy:copyfileifptofileofp*/
voidfilecopy(FILE*ifp,FILE*ofp)
{
intc;
while((c=getc(ifp))!=EOF)
putc(c,ofp);
}
文件指针stdin与stdout都是FILE*类型的对象。但它们是常量,而非变量。因此不能对它们赋值。
函数
intfclose(FILE*fp)
执行和fopen相反的操作,它断开由fopen函数建立的文件指针和外部名之间的连接,并释放文件指针以供其它文件使用。因为大多数操作系统都限制了一个程序可以同时打开的文件数,所以,当文件指针不再需要时就应该释放,这是一个好的编程习惯,就像我们在cat程序中所做的那样。对输出文件执行fclose还有另外一个原因:它将把缓冲区中由putc函数正在收集的输出写到文件中。当程序正常终止时,程序会自动为每个打开的文件调用fclose函数。(如果不需要使用stdin与stdout,可以把它们关闭掉。也可以通过库函数freopen重新指定它们。)
7.6.错误处理——stderr和exit
cat程序的错误处理功能并不完善。问题在于,如果因为某种原因而造成其中的一个文件无法访问,相应的诊断信息要在该连接的输出的末尾才能打印出来。当输出到屏幕时,这种处理方法尚可以接受,但如果输出到一个文件或通过管道输出到另一个程序时,就无法接受了。
为了更好地处理这种情况,另一个输出流以与stdin和stdout相同的方式分派给程序,即stderr。即使对标准输出进行了重定向,写到stderr中的输出通常也会显示在屏幕上。
下面我们改写cat程序,将其出错信息写到标准错误文件上。#include<stdio.h>
/*cat:concatenatefiles,version2*/
main(intargc,char*argv[])
{
FILE*fp;
voidfilecopy(FILE*,FILE*);
char*prog=argv[0];/*programnameforerrors*/
if(argc==1)/*noargs;copystandardinput*/
filecopy(stdin,stdout);
else
while(--argc>0)
if((fp=fopen(*++argv,"r"))
fprintf(stderr,"%s:can't
prog,*argv);
exit(1);
==NULL){
open%s\n",
}else{
filecopy(fp,stdout);
fclose(fp);
}
if(ferror(stdout)){
fprintf(stderr,"%s:errorwritingstdout\n",prog);
exit(2);
}
exit(0);
}
该程序通过两种方式发出出错信息。首先,将fprintf函数产生的诊断信息输出到stderr上,因此诊断信息将会显示在屏幕上,而不是仅仅输出到管道或输出文件中。诊断信息中包含argv[0]中的程序名,因此,当该程序和其它程序一起运行时,可以识别错误的来源。
其次,程序使用了标准库函数exit,当该函数被调用时,它将终止调用程序的执行。任何调用该程序的进程都可以获取exit的参数值,因此,可通过另一个将该程序作为子进程的程序来测试该程序的执行是否成功。按照惯例,返回值0表示一切正常,而非0返回值通常表示出现了异常情况。exit为每个已打开的输出文件调用fclose函数,以将缓冲区中的所有输出写到相应的文件中。
在主程序main中,语句returnexpr等价于exit(expr)。但是,使用函数exit有一个优点,它可以从其它函数中调用,并且可以用类似于第5章中描述的模式查找程序查找这些调用。
如果流fp中出现错误,则函数ferror返回一个非0值。intferror(FILE*fp)
尽管输出错误很少出现,但还是存在的(例如,当磁盘满时),因此,成熟的产品程序应该检查这种类型的错误。
函数feof(FILE*)与ferror类似。如果指定的文件到达文件结尾,它将返回一个非
0值。
intfeof(FILE*fp)
在上面的小程序中,我们的目的是为了说明问题,因此并不太关心程序的退出状态,但对于任何重要的程序来说,都应该让程序返回有意义且有用的值。
7.7.行输入和行输出
标准库提供了一个输入函数fgets,它和前面几章中用到的函数getline类似。char*fgets(char*line,intmaxline,FILE*fp)
fgets函数从fp指向的文件中读取下一个输入行(包括换行符),并将它存放在字符数组
line中,它最多可读取maxline-1个字符。读取的行将以'\0'结尾保存到数组中。通常情况下,fgets返回line,但如果遇到了文件结尾或发生了错误,则返回NULL(我们编写的getline函数返回行的长度,这个值更有用,当它为0时意味着已经到达了文件的结尾)。
输出函数fputs将一个字符串(不需要包含换行符)写入到一个文件中:intfputs(char*line,FILE*fp)
如果发生错误,该函数将返回EOF,否则返回一个非负值。
库函数gets和puts的功能与fgets和fputs函数类似,但它们是对stdin和stdout进行操作。有一点我们需要注意,gets函数在读取字符串时将删除结尾的换行符('\n'),而puts函数在写入字符串时将在结尾添加一个换行符。
下面的代码是标准库中fgets和fputs函数的代码,从中可以看出,这两个函数并没有什么特别的地方。代码如下所示:
/*fgets:getatmostncharsfromiop*/
char*fgets(char*s,intn,FILE*iop)
{
registerintc;
registerchar*cs;
cs=s;
while(--n>0&&(c=getc(iop))!=EOF)
if((*cs++=c)=='\n')
break;*cs='\0';
return(c==EOF&&cs==s)?NULL:s;}
/*fputs:putstringsonfileiop*/
intfputs(char*s,FILE*iop)
{
intc;
while(c=*s++)
putc(c,iop);
returnferror(iop)?EOF:0;
}
ANSI标准规定,ferror在发生错误时返回非0值,而fputs在发生错误时返回EOF,其它情况返回一个非负值。
使用fgets函数很容易实现getline函数:
/*getline:readaline,returnlength*/
intgetline(char*line,intmax)
{
if(fgets(line,max,stdin)==NULL)return0;
else
returnstrlen(line);}
练习7-6编写一个程序,比较两个文件并打印它们第一个不相同的行。
练习7-7修改第5章的模式查找程序,使它从一个命名文件的集合中读取输入(有文件名参数时),如果没有文件名参数,则从标准输入中读取输入。当发现一个匹配行时,是否应该将相应的文件名打印出来?
练习7-8编写一个程序,以打印一个文件集合,每个文件从新的一页开始打印,并且打印每个文件相应的标题和页数。
7.8.其它函数
标准库提供了很多功能各异的函数。本节将对其中特别有用的函数做一个简要的概述。更详细的信息以及其它许多没有介绍的函数请参见附录B。
7.8.1.字符串操作函数
前面已经提到过字符串函数strlen、strcpy、strcat和strcmp,它们都在头文件<string.h>中定义。在下面的各个函数中,s与t为char*类型,c与n为int类型。
strcat(s,t)将t指向的字符串连接到s指向的字符串的末尾
strncat(s,t,n)将t指向的字符串中前n个字符连接到s指向的字符串的末尾
strcmp(s,t)根据s指向的字符串小于(s<t)、等于(s==t)或大于(s>t)t
指向的字符串的不同情况,分别返回负整数、0或正整数
strncmp(s,t,n)同strcmp相同,但只在前n个字符中比较
strcpy(s,t)将t指向的字符串复制到s指向的位置
strncpy(s,t,n)将t指向的字符串中前n个字符复制到s指向的位置strlen(s)返回s指向的字符串的长度
strchr(s,c)在s指向的字符串中查找c,若找到,则返回指向它第一次出现的位
置的指针,否则返回NULL
strrchr(s,c)在s指向的字符串中查找c,若找到,则返回指向它最后一次出现的
位置的指针,否则返回NULL
7.8.2.字符类别测试和转换函数
头文件<ctype.h>中定义了一些用于字符测试和转换的函数。在下面各个函数中,c是一个可表示为unsignedchar类型或EOF的int对象。该函数的返回值类型为int。
isalpha(c)若c是字母,则返回一个非0值,否则返回0
isupper(c)若c是大写字母,则返回一个非0值,否则返回0
islower(c)若c是小写字母,则返回一个非0值,否则返回0
isdigit(c)若c是数字,则返回一个非0值,否则返回0
isalnum(c)若isalpha(c)或isdigit(c),则返回一个非0值,否则返回0
isspace(c)若c是空格、横向制表符、换行符、回车符,换页符或纵向制表符,
则返回一个非0值
toupper(c)返回c的大写形式
tolower(c)返回c的小写形式
7.8.3.ungetc函数
标准库提供了一个称为ungetc的函数,它与第4章中编写的函数ungetch相比功能更受限制。
intungetc(intc,FILE*fp)
该函数将字符c写回到文件fp中。如果执行成功,则返回c,否则返回EOF。每个文件只能
接收一个写回字符。ungetc函数可以和任何一个输入函数一起使用,比如scanf、getc或getchar。
7.8.4.命令执行函数
函数system(char*s)执行包含在字符申s中的命令,然后继续执行当前程序。s的内容在很大程度上与所用的操作系统有关。下面来看一个UNIX操作系统环境的小例子。语句
system("date");
将执行程序date,它在标准输出上打印当天的日期和时间。system函数返回一个整型的状态值,其值来自于执行的命令,并同具体系统有关。在UNIX系统中,返回的状态是exit的返回值。
7.8.5.存储管理函数
函数malloc和calloc用于动态地分配存储块。函数malloc的声明如下:void*malloc(size_tn)
当分配成功时,它返回一个指针,设指针指向n字节长度的未初始化的存储空间,否则返回NULL。函数calloc的声明为
void*calloc(size_tn,size_tsize)
当分配成功时,它返回一个指针,该指针指向的空闲空间足以容纳由n个指定长度的对象组成的数组,否则返回NULL。该存储空间被初始化为0。
根据请求的对象类型,malloc或calloc函数返回的指针满足正确的对齐要求。下面的例子进行了类型转换:
int*ip;
ip=(int*)calloc(n,sizeof(int));
free(p)函数释放p指向的存储空间,其中,p是此前通过调用malloc或calloc函数得到的指针。存储空间的释放顺序没有什么限制,但是,如果释放一个不是通过调用malloc或calloc函数得到的指针所指向的存储空间,将是一个很严重的错误。
使用已经释放的存储空间同样是错误的。下面所示的代码是一个很典型的错误代码段,它通过一个循环释放列表中的项目:
for(p=head;p!=NULL;p=p->next)/*WRONG*/free(p);
正确的处理方法是,在释放项目之前先将一切必要的信息保存起来,如下所示:
for(p=head;p!=NULL;p=q){
q=p->next;
free(p);
}
8.7节给出了一个类似于malloc函数的存储分配程序的实现。该存储分配程序分配的存储块可以以任意顺序释放。
7.8.6.数学函数
头文件<math.h>中声明了20多个数学函数。下面介绍一些常用的数学函数,每个函数带有一个或两个double类型的参数,并返回一个double类型的值。
sin(x)x的正弦函数,其中x用弧度表示
cos(x)x的余弦函数,其中x用弧度表示
atan2(y,x)y/x的反正切函数,其中,x和y用弧度表示
exp(x)指数函数ex
log(x)x的自然对数(以e为底),其中,x>0
log10(x)x的常用对数(以10为底),其中,x>0
pow(x,y)计算xy的值
sqrt(x)x的平方根(x≥0)
fabs(x)x的绝对值
7.8.7.随机数发生器函数
函数rand()生成介于0和RAND_MAX之间的伪随机整数序列。其中RAND_MAX是在头文件<stdlib.h>中定义的符号常量。下面是一种生成大于等于0但小于1的随机浮点数的方法:
#definefrand()((double)rand()/(RAND_MAX+1.0))
(如果所用的函数库中已经提供了一个生成浮点随机数的函数,那么它可能比上面这个函数具有更好的统计学特性。)
函数srand(unsigned)设置rand函数的种子数。我们在2.7节中给出了遵循标准的rand和srand函数的可移植的实现。
练习7-9类似于isupper这样的函数可以通过某种方式实现以达到节省空间或时间的目的。考虑节省空间或时间的实现方式。
第8章UNIX系统接口
UNIX操作系统通过一系列的系统调用提供服务,这些系统调用实际上是操作系统内的函数,它们可以被用户程序调用。本章将介绍如何在C语言程序中使用一些重要的系统调用。如果读者使用的是UNIX,本章将会对你有直接的帮助,这是因为,我们经常需要借助于系统调用以获得最高的效率,或者访问标准库中没有的某些功能。但是,即使读者是在其它操作系统上使用C语言,本章的例子也将会帮助你对C语言程序设计有更深入的了解。不同系统中的代码具有相似性,只是一些细节上有区别而已。因为ANSIC标准函数库是以UNIX系统为基础建立起来的,所以,学习本章中的程序还将有助于更好地理解标准库。
本章的内容包括3个主要部分,输入/输出、文件系统和存储分配。其中,前两部分的内容要求读者对UNIX系统的外部特性有一定的了解。
第7章介绍的输入/输出接口对任何操作系统都是一样的。在任何特定的系统中,标准库函数的实现必须通过宿主系统提供的功能来实现。接下来的几节将介绍UNIX系统中用于输入和输出的系统调用,并介绍如何通过它们实现标准库。
8.1.文件描述符
在UNIX操作系统中,所有的外围设备(包括键盘和显示器)都被看作是文件系统中的文件,因此,所有的输入/输出都要通过读文件或写文件完成。也就是说,通过一个单一的接口就可以处理外围设备和程序之间的所有通信。
通常情况下,在读或写文件之前,必须先将这个意图通知系统,该过程称为打开文件。如果是写一个文件,则可能需要先创建该文件,也可能需要丢弃该文件中原先已存在的内容。系统检查你的权力(该文件是否存在?是否有访问它的权限?),如果一切正常,操作采统将向程序返回一个小的非负整数,该整数称为文件描述符。任何时候对文件的输入/输出都是通过文件描述符标识文件,而不是通过文件名标识文件。(文件描述符类似于标准库中的文件指针或MS-DOS中的文件句柄。)系统负责维护已打开文件的所有信息,用户程序只能通过文件描述符引用文件,
因为大多数的输入/输出是通过键盘和显示器来实现的,为了方便起见,UNIX对此做了特别的安排。当命令解释程序(即“shell”)运行一个程序的时候,它将打开3个文件,对应的文件描述符分别为0,1,2,依次表示标准输入,标准输出和标准错误。如果程序从文件0中读,对1和2进行写,就可以进行输/输出而不必关心打开文件的问题。
程序的使用者可通过<和>重定向程序的I/O:prog<输入文件名>输出文件名
这种情况下,shell把文件描述符0和1的默认赋值改变为指定的文件。通常,文件描述符2仍与显示器相关联,这样,出错信息会输出到显示器上。与管道相关的输入/输出也有类似的特性。在任何情况下,文件赋值的改变都不是由程序完成的,而是由shell完成的。只要程序使用文件0作为输入,文件1和2作为输出,它就不会知道程序的输入从哪里来,并输出
到哪里去。
8.2.低级I/O——read和write
输入与输出是通过read和write系统调用实现的。在C语言程序中,可以通过函数read和write访问这两个系统调用。这两个函数中,第一个参数是文件描述符,第二个参数是程序中存放读或写的数据的字符数组,第三个参数是要传输的字节数。
intn_read=read(intfd,char*buf,intn);
intn_written=write(intfd,char*buf,intn);
每个调用返回实际传输的字节数。在读文件时,函数的返回值可能会小于请求的字节数。如果返回值为0,则表示已到达文件的结尾;如果返回值为-1,则表示发生了某种错误。在写文件时,返回值是实际写入的字节数。如果返回值与请求写入的字节数不相等,则说明发生了错误。
在一次调用中,读出或写入的数据的字节数可以为任意大小。最常用的值为1,即每次读出或写入1个字符(无缓冲),或是类似于1024~4096这样的与外围设备的物理块大小相应的值。用更大的值调用该函数可以获得更高的效率,因为系统调用的次数减少了。
结合以上的讨论,我们可以编写一个简单的程序,将输入复制到输出,这与第1章中的复制程序在功能上相同。程序可以将任意输入复制到任意输出,因为输入/输出可以重定向到任何文件或设备。
#include"syscalls.h"
main()/*copyinputtooutput*/
{
charbuf[BUFSIZ];
intn;
while((n=read(0,buf,BUFSIZ))>0)
write(1,buf,n);
return0;
}
我们已经将系统调用的函数原型集中放在一个头文件syscalls.h中,因此,本章中的程序都将包含该头文件。不过,该文件的名字不是标准的。
参数BUFSIZ也已经在syscalls.h头文件中定义。对于所使用的操作系统来说,该值是一个较合适的数值。如果文件大小不是BUFSIZ的倍数,则对read的某次调用会返回一个较小的字节数,write再按这个字节数写,此后再调用read将返回0。
为了更好地掌握有关概念,下面来说明如何用read和write构造类似于getchar、putchar等的高级函数。例如,以下是getchar函数的一个版本,它通过每次从标准输入读入一个字符来实现无缓冲输入。
#include"syscalls.h"
/*getchar:unbufferedsinglecharacterinput*/
intgetchar(void)
{
charc;
return(read(0,&c,1)==1)?(unsignedchar)c:EOF;}
其中,c必须是一个char类型的变量,因为read函数需要一个字符指针类型的参数(&c)。在返回语句中将c转换为unsignedchar类型可以消除符号扩展问题。
getchar的第二个版本一次读入一组字符,但每次只输出一个字符。#include"syscalls.h"
/*getchar:simplebufferedversion*/
intgetchar(void)
{
staticcharbuf[BUFSIZ];staticchar*bufp=buf;staticintn=0;
if(n==0){/*bufferisempty*/
n=read(0,buf,sizeofbuf);
bufp=buf;
}
return(--n>=0)?(unsignedchar)*bufp++:EOF;}
如果要在包含头文件<stdio.h>的情况下编译这些版本的getchar函数,就有必要用#undef预处理指令取消名字getchar的宏定义,因为在头文件中,getchar是以宏方式实现的。
8.3.open、creat、close和unlink
除了默认的标准输入、标准输出和标准错误文件外,其它文件都必须在读或写之前显式地打开。系统调用open和creat用于实现该功能。
open与第7章讨论的fopen相似,不同的是,前者返回一个文件描述符,它仅仅只是一个int类型的数值。而后者返回一个文件指针。如果发生错误,open将返回-1。
#include<fcntl.h>
intfd;
intopen(char*name,intflags,intperms);
fd=open(name,flags,perms);
与fopen一样,参数name是一个包含文件名的字符串。第二个参数flags是一个int类型的值,它说明以何种方式打开文件,主要的几个值如下所示:
ORDONLY
_
OWRONLY
_
ORDWR
_
以只读方式打开文件以只写方式打开文件以读写方式打开文件
在SystemVUNIX系统中,这些常量在头文件<fcntl.h>中定义,而在Berkeley(BSD)版本中则在<sys/file.h>中定义。
可以使用下列语句打开一个文件以执行读操作:fd=open(name,O_RDONLY,0);
在本章的讨论中,open的参数perms的值始终为0。
如果用open打开一个不存在的文件,则将导致错误。可以使用creat系统调用创建新文件或覆盖已有的旧文件,如下所示:
intcreat(char*name,intperms);fd=creat(name,perms);
如果creat成功地创建了文件,它将返回一个文件描述符,否则返回-1。如果此文件已存在,creat将把该文件的长度截断为0,从而丢弃原先已有的内容。使用creat创建一个已存在的文件不会导致错误。
如果要创建的文件不存在,则creat用参数perms指定的权限创建文件。在UNIX文件系统中,每个文件对应一个9比特的权限信息,它们分别控制文件的所有者、所有者组和其他成员对文件的读、写和执行访问。因此,通过一个3位的八进制数就可方便地说明不同的权限,例如,0755说明文件的所有者可以对它进行读、写和执行操作,而所有者组和其他成员只能进行读和执行操作。
下面通过一个简化的UNIX程序cp说明creat的用法。该程序将一个文件复制到另一个文件。我们编写的这个版本仅仅只能复制一个文件,不允许用目录作为第二个参数,并且,目标文件的权限不是通过复制获得的,而是重新定义的。
该程序创建的输出文件具有固定的权限0666。利用8.6节中将要讨论的stat系统调用,可以获得一个已存在文件的模式,并将此模式赋值给它的副本。
注意,函数error类似于函数printf,在调用时可带变长参数表。下面通过error函
数的实现说明如何使用printf函数家族的另一个成员vprintf。标准库函数vprintf函数与printf函数类似,所不同的是,它用一个参数取代了变长参数表,且此参数通过调用va_start宏进行初始化。同样,vfprintf和vsprintf函数分别与fprintf和sprintf函数类似。
一个程序同时打开的文件数是有限制的(通常为20)。相应地,如果一个程序需要同时处理许多文件,那么它必须重用文件描述符。函数close(intfd)用来断开文件描述符和已打开文件之间的连接,并释放此文件描述符,以供其它文件使用。close函数与标准库中的fclose函数相对应,但它不需要清洗(flush)缓冲区。如果程序通过exit函数退出或从主程序中返回,所有打开的文件将被关闭。
函数unlink(char*name)将文件name从文件系统中删除,它对应于标准库函数remove。
练习8-1用read、write、open和close系统调用代替标准库中功能等价的函数,重写第7章的cat程序,并通过实验比较两个版本的相对执行速度。
8.4.随机访问——lseek
输入/输出通常是顺序进行的:每次调用read和write进行读写的位置紧跟在前一次操作的位置之后。但是,有时候需要以任意顺序访问文件,系统调用lseek可以在文件中任意移动位置而不实际读写任何数据:
longlseek(intfd,longoffset,intorigin);
将文件描述符为fd的文件的当前位置设置为offset,其中,offset是相对于orgin指定的位置而言的。随后进行的读写操作将从此位置开始,origin的值可以为0、1或2,分别用于指定offset从文件开始、从当前位置或从文件结束处开始算起。例如,为了向一个文件的尾部添加内容(在UNIXshell程序中使用重定向符>>或在系统调用fopen中使用参数“a”),则在写操作之前必须使用下列系统调用找到文件的末尾:
lseek(fd,0L,2);
若要返回文件的开始处(即反绕),则可以使用下列调用:lseek(fd,0L,0);
请注意,参数一致。
0L也可写为(long)0,或仅仅写为0,但是系统调用lseek的声明必须保持
使用lseek系统调用时,可以将文件视为一个大数组,其代价是访问速度会慢一些。例如,下面的函数将从文件的任意位置读入任意数目的字节,它返回读入的字节数,若发生错误,则返回-1。
lseek系统调用返回一个long类型的值,此值表示文件的新位置,若发生错误,则返回-1。标准库函数fseek与系统调用lseek类似,所不同的是,前者的第一个参数是FILE*类型,且在发生错误时返回一个非0值。
8.5.实例——fopen和getc函数的实现
下面以标准库函数fopen和getc的一种实现方法为例来说明如何将这些系统调用结合起来使用。
我们回忆一下,标准库中的文件不是通过文件描述符描述的,而是使用文件指针描述的。文件指针是一个指向包含文件各种信息的结构的指针,该结构包含下列内容:一个指向缓冲区的指针,通过它可以一次读入文件的一大块内容;一个记录缓冲区中剩余的字符数的计数器;一个指向缓冲区中下一个字符的指针;文件描述符;描述读/写模式的标志;描述错误状态的标志等。
描述文件的数据结构包含在头文件<stdio.h>中,任何需要使用标准输入/输出库中函数的程序都必须在源文件中包含这个头文件(通过#include指令包含头文件)。此文件也被库中的其它函数包含。在下面这段典型的<stdio.h>代码段中,只供标准库中其它函数所使用的名字以下划线开始,因此一般不会与用户程序中的名字冲突。所有的标准库函数都遵循该约定。
宏getc一般先将计数器减1,将指针移到下一个位置,然后返回字符。(前面讲过,一个长的#define语句可用反斜杠分成几行。)但是,如果计数值变为负值,getc就调用函数_fillbuf填充缓冲区,重新初始化结构的内容,并返回一个字符。返回的字符为unsigned类型。以确保所有的字符为正值。
尽管在这里我们并不想讨论一些细节,但程序中还是给出了putc函数的定义,以表明它的操作与getc函数非常类似,当缓冲区满时,它将调用函数_flushbuf。此外,我们还在其中包含了访问错误输出、文件结束状态和文件描述符的宏。
下面我们来着手编写函数fopen。fopen函数的主要功能是打开文件,定位到合适的位置,设置标志位以指示相应的状态。它不分配任何缓冲区空间,缓冲区的分配是在第一次读文件时由函数_fillbuf完成的。
该版本的fopen函数没有涉及标准C的所有访问模式,但是,加入这些模式并不需要增加多少代码。特别是,该版本的fopen不能识别表示二进制访问方式的b标志,这是因为,在UNIX系统中这种方式是没有意义的。同时,它也不能识别允许同时进行读和写的+标志。
对于某一特定的文件,第一次调用getc函数时计数值为0,这样就必须调用一次函数_fillbuf。如果_fillbuf发现文件不是以读方式打开的,它将立即返回EOF;否则,它将试图分配一个缓冲区(如果读操作是以缓冲方式进行的话)。
建立缓冲区后,_fillbuf调用read填充此缓冲区,设置计数值和指针,并返回缓冲区中的第一个字符。随后进行的_fillbuf调用会发现缓冲区已经分配。
该结构中flag部分的初值表明,将对stdin执行读操作、对stdout执行写操作、对stderr执行缓冲方式的写操作。
类似于函数lseek,所不同的是,该函数中的fp是一个文件指针而不是文件描述符,且返回值是一个int类型的状态而非位置值。编写函数fseek,并确保该函数与库中其它函数使用的缓冲能够协同工作。
8.6.实例——目录列表
我们常常还需要对文件系统执行另一种操作,以获得文件的有关信息,而不是读取文件的具体内容。目录列表程序便是其中的一个例子,比如UNIX命令ls,它打印一个目录中的文件名以及其它一些可选信息,如文件长度、访问权限等等。MS-DOS操作系统中的dir命令也有类似的功能。
由于UNIX中的目录就是一种文件,因此,ls只需要读此文件就可获得所有的文件名。但是,如果需要获取文件的其它信息,比如长度等,就需要使用系统调用。在其它一些系统中,甚至获取文件名也需要使用系统调用,例如在MS-DOS系统中即如此。无论实现方式是否同具体的系统有关,我们需要提供一种与系统无关的访问文件信息的途径。
以下将通过程序fsize说明这一点。fsize程序是ls命令的一个特殊形式,它打印命令行参数表中指定的所有文件的长度。如果其中一个文件是目录,则fsize程序将对此目录递归调用自身。如果命令行中没有任何参数,则fsize程序处理当前目录。
我们首先回顾UNIX文件系统的结构。在UNIX系统中,目录就是文件,它包含了一个文件名列表和一些指示文件位置的信息。“位置”是一个指向其它表(即i结点表)的索引。文件的i结点是存放除文件名以外的所有文件信息的地方。目录项通常仅包含两个条目:文件名和i结点编号。
遗憾的是,在不同版本的系统中,目录的格式和确切的内容是不一样的。因此,为了分离出不可移植的部分,我们把任务分成两部分。外层定义了一个称为Dirent的结构和3个函数opendir、readdir和closedir,它们提供与系统无关的对目录项中的名字和i结点编号的访问。我们将利用此接口编写fsize程序,然后说明如何在与Version7和SystemVUNIX系统的目录结构相同的系统上实现这些函数。其它情况留作练习。
结构Dirent包含i结点编号和文件名。文件名的最大长度由NAMZ_MAX设定,NAME_MAX的值由系统决定。opendir返回一个指向称为DIR的结构的指针,该结构与结构FILE类似,它将被readdir和closedir使用。所有这些信息存放在头文件dirent.h中。
系统调用stat以文件名作为参数,返回文件的i结点中的所有信息;若出错,则返回-1。如下所示: