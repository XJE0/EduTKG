清华大学出版社
（京）新登字巧8号
内容简介
《数据结构C谙版）是为“数据结构”课程编写的教材，也可作为学习数据结构及其算法的C程序设汁的参考教材。
本书的前半都分从抽象数类型的角度词论各种基本类型的数据结构及其应用；后半部分主要讨论查找和排序的各种实现方法及其综合分斫比较。其内容和章节编排与] 992年4月出版的《数据结构以第0版）基一致，但在车书中屮突出了抽象数据类型的概念。全书卞用类C语訁作为数结陶和算法的描述语言。
本书概念表述严懣．逻辑推理严密，语言精炼，用词达意并有配套出版的《数据结构题集洹'语言版既便于教学，又埂自学。
本后附有光盘，光盘中含有可在DOS环境一卜运行的以类C语言瞄还的“数倨结构算法动态模拟助教学软件，以及卜运行的以类PASCAL或类C两种语言描述的“数据结构算法动态模拟辅助教学執件'
本书可作为计算机类专业或信息类川关专业的车科或专料教材，也可伊从事门算机主与用」一作的科技工作者参考。
版权所有，翻印必究。
本书封面貼有清华大学出版社激光防伪标签，无标签者不得销售。
书名：数据结构（C语訁版）作名．严蔚敏昊伟民编菩
出版者：清华大学出版社（北京清华大学学研大厦岫阝编0084）
htlp：/?'www.甲．tslnghlta.edu/ cn
责任编辑：范素畛印刷者：北京密厶胶印厂
发行者：新华书店总店北京发行所
本！7800 092 016印张！21.5字数：493 T字版 次2002矸9月第1版2002年9月第1次印刷
ISBN 7一9006 22一2 印 数： 0001一5000
定 价：30，佣元（含盘）
“数据结构”是计算机程序设计的要理论技术基础，它不仅是计算机学科的核心课程，而且已成为其他理工专业的热门选修课。本书是为“数据结构”课程编写的教材，其内容选取符合教学大纲要求，并兼顾学科的广度和深度，适用面广。
本书的第1章综述數据、数据结构和抽象数据类型等基本概念；第2章至第7章从抽象数据类型的角度，分别讨论线性表、栈、队列、串、数组、广义表、树和二叉树以及图等基本类型的数据结构及其应用；第8章综合介绍操作系统和编i羊程序中涉及的动态存储管理的基本技术；第9章至第11章讨论查找和排序，除了介绍各种实现方法之外，并着重从时问上进行定性或定的分析和比较；第1 2章介绍常用的文件结构。用过《数据结枘》（第二版）的读者容易看出，本书内容和章节编排与1992年4月出版的《数据结构》（第二版）基本一致，但在本书中更突出了抽象数据类型的概念。对每一种数据结构，都分别给出相应的抽象数据类型规范．说明和实现方法、，
全书中采用类0语訁作为數据结构和算法的描读语吉，在对數据的存储结构和算法进行描述时，尽量考虑C语言的特色，如利用數组的动态分配实现顺序存储结构等。虽然C语言不是抽象数据类型的理想描述工具，但鉴于目前和近一、两年内，“面向对象程序设计”并非数据结构的先修课程，故本书未直接采用类和对象等设施，而是从C语言中精选了一个核心子集，并增添 C ++语言的引用调用参数传递方式等，构成了一个类C描述语言。它使本书对各种抽象数据类型的定义和实现简明清晰，既不拘泥于C语言的细节，又容易转撫成能上机执行的C或C ++程序。
从课程性质上讲，“数据结构”是一冂专业技术基础课。它的教学要求是学会分析研究计算机加工的数据结构的特性，以便为应用涉及的数据选择适当的逻辑结构、存储结构及其相应的算法，并初步掌握算法的时间分析和空间分析的技术：，另一方面，本课程的学习过程也是复杂程序设计的训练过，要求学生编写的程序结构清楚和正确易读，符合软件工程的规范。如果说高级语言程序设计课程对学生进行了结构化程序设计（程序抽象）的初步驯练的话，那么数据结构课程就要培养他们的数据抽象能力。本书将用规范的数学语言描逑数据结构的定义，以突出其数学特性，同时，通过若于数据结构应用实例，引导学生学习数据类型的使用，为今后学习面向对象的簪序设计作一些铺垫。
本书可作为计算机专业的本科或专科教材，也可以作为信息类相关专业的选修教材，讲授学时可为50至80。教师可根据学时、专业和学生的实际情况，选讲或不讲目录页中带×的章节，甚至删去第5，8，1 1和] 2章。本书文字通俗、简明易懂、粳于自学，也可供从事计算机应用等工作的科技人员参考。只需掌握程序设计基本技术便可学习本书。若具有离散数学和概率论的知识，则对书中某些内客更易理解。如果将本书《數据结构》（C语版）和《數艍结构以第苤版）作为关于数据结构及其算法的C和Pascal程序设计的对照教材，则有助于快速陡深刻地掌握这两种语言。
与本书配套的还有《数据结构题集》（C语言版），由清华人学出版社出版书中提供配套的习迦和实刁题，并可作为学习指导手册。严蔚敏吴伟民清华火学计葬机科学与技术系华南师范大学计算机科学系
1996年7月 目 录
第1章 绪论，．
1 . 1 什么是数据结构 1．2 基本概念和术语
I. 3 抽象数据类型的表小与实现
l . 4 算法和算法分析“，
]，4．1算法
1. 1. 2箅法设计的要求．
I . el，3算法效率的度量，
L40算法的存储空间需求．第2章 线性表
2，1线性表的类型定义，，'
2，2线性表的顺序表示和实现，，
2．3线性表的链式表示和实现
2．30线性僻表，
2就2循环僻表
2．3．3双向链表．
2，4一儿多项式的表小及相加“ 第3章栈和队列
3，1
3．2
· 3．3
3國
' 3，5
3．l. 1抽象数据类型栈的定义．土1 . 2栈的表小和实理．栈的应用举例“．
3．2．1数制转换．
3．2．2括号匹配的检验
3，2．3行编辑程序
3．2．4迷宫求解
3．2，5表达式求值栈与递归的实现
队列．
3．4．1抽象数据类型队列的定义．
3．4 . 2链队列一一队列的链式表示和实现
3，4．3循环队列．一队列的顺序表示和实现
第4章串，
串类型的定一
．70
串的表示和实现．
。72
?1. 2，1定长顺序存储表示
4，乙2堆分配存储表示
4．2，3串的块链存储表示
，73
悯，3
串的模式匹配算法
4、30求子串位的定位函数司“（S，T中”产 d . 3．2模式匹配的一种改进算法．
．79
4．4
串操作应用举例
．84
上4，1文本编辑
' 4，4，2建立词索引表， ．86
第5章数组和广义表．
数组的定义，
5《2
数组的顺序表示和实现“．
5，3
矩阵的压缩存储．
5，3．1特殊矩阵，
．95
稀疏矩阵，
．96
5，4
广义表的定义．
，] 06
5，5
广义表的存储结构
．109
00；
元多项式的表示
．1 10
“ 5．7
广义表的涕归算法．
5，7，1求广义表的深度 · 1 1 3
5，7．2复制广义表 · 1 1 5 5．7．3建立广义表的存储结构 “ 115 第章树和二叉树，， ．] 1 8
6，1 树的定义和基本术语 ．1 18 6．2 二叉树
6．2．1二叉树的定义“ ．121
6．2．2二叉树的性质“ 123
6．2．3二叉树的存储结构． ．126
3 遍历二叉树和线索二叉树 “ 1 2 8
6，3．1遍历二叉树，， ．128 6．3，2线索二叉树“ · ．132 树和森林 ．1 3 5
离散事件模拟 · 65 6．4．1
6以，2
6，4，3
树的存储结构 135 森林与二叉树的转换．“ 13 7 树和森林的遍历“， ．138 ' 6，5 6．6
' 6，1
' 6．8 第7章
7．1 7．2
7，3
7树与等价问题，赫去显树及其应用
6．6．1最优二叉树（赫夫曼树）．赫夫曼编码回溯法与树的遍历树的汁数．图，．图的定义和术语．图的存储结构．
7，2，1数组表示法“，
7．2，2邻接表“．
7．2，3十字链表“ 7，2，4邻接多重表“ 图的遍历唟3．1深度优先攫索一 7，3．2广度优先搜索．，图的连通性问题
7．4、1无向图的连通分量和生成树．
o．4．2有向图的强连通分量“ 7．，0《最小生成树“．
．7．、t. 4关节点和重通分量一有向无环图及其应用 7 · 5，1拓扑排序．” 7．5，2关键路径' " 最短路径．
09 凵1 ．凵4
凵9
，1 5 6
．160
· 1 6 ]
．163
．1 6 4
．1 6 6
，1 6 7
．169 ·以0
．170
．1 7 2
．03
．1 7 9
．180
· ] 8 3
．1 867．6．]从某个源点到其余各顶点的最短路径，“
7．6．2每一对顶点之间的最短路径一 } 90第8章动态存储管理，，
8．] 概述“
8．2 可利用空间表及分配方法'
8，3 边界标识法“
8，3，1可利用空间表的结构，
& 3．2分配算法“，
8．3．3回收算法“
8．4 伙伴系统
8园．1 可利用空间表的结构．
8．4，2 分配算法．．
8园，3 回收算法，，，．3
1明
．195
@ 1 9 8
．1 9 8
．1 9 9
．2 0 1
。203
．203
．204
，205 一& 5无用单丿L收集一& 6存槠紧缩．第9章查找．，静态查找表
9，10顺序表的查找．，
9，1 . 2有序表的查找“
' 9．1. 3静态树表的查找，，
9，1.4索引顺序表的查找一
9．2 动态查找表
9．巳1 一叉排序树和平衡二叉树．
9，2，2 B一树和B」'树．
" 9．2．3 键树“，
9，3 哈希表，
9，3．]
什么是哈希表，
9．3、2
哈希函数的构造方法，
9．3．3
处理冲突的方法一
9，3
哈希表的查找及其分析“．
第庫 内部排序
] 0．1
概述，，
10，2
插人排序“
世2，1直接插人排序一地2．2其他插人排序一
1 0．2．3希尔排序．
] 3
快速排序“ 选择排序“
地4，1简单选择排序“ 1 0．4．2树形选择排序一地4．3堆排序“
1 0 . 5
归并排序“
．6
基数排序．
1 0，6．1多关字的排序“，地6，2链式基数排序“ '
10．7 各种内部排序方法的比较讨论，．第11章 外部排序
1 1 .
外存信息的存取．
1 1. 2
外部排序的方法
．1 1 . 3
多路平衡归并的实现．
· 1 1, 4
置换一选择排序
· 205 了2
．2 } 4
．2 ] 6
· 216
，2 18 ．222 · 225 ．226 · 227 ．238
，2 7
，25 }
．253
，256
· 259
· 263
．265
，265
，266
．272
．278
．2 7 9
283
“ 284
．286
．288 ．2 9 3 ．293 295
．297
，299 ．“
第12章 1巳1 理．2
2．3
1 2．1
1 2，5 1巳6
附录A名词索引附录数索引参考书目．，第1章绪论
自] 946年第，台门算机问世以来算机产业的飞速发展已远远超出人们对它的预料，在某些生产线上．甚至几秒钟就能生产出一台微型计算机，产量猛增，价格低廉，这就使得它的应用范围迅速扩展。如今．计算机己深人到人类社会的各个领域。计算机的应用已不再局限于科学计算，而更多地用于控制、管理及数据处理等非数值计算的处理工作。与此相应，计算机加工处理的刈象山纯粹的数值发展到字符、表格和图像等各种具有一定结构的数据，这就给程序设计带来一些新的问题。为了编写出一个“好”的程序，必须分析待处理的对象的特性以及各处理对象之间存在的关系。这就是“数据结构”这门学科形成和发展的背景。
1 . 1什么是数据结构
一般来说，用计算机解决一个具体问题时，大致需要经过下列几个步骤：首先要从具体问题抽象出一个适当的数学模型，然后没计一个解此数学模型的算法，最后编出程序、进行测试、调整直至得到最终解答。寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间含有的关系，然后用数学的语言加以描述、例如，求解梁架结构中应力的数学模型为线性方程组；预报人口增长情况的数学模型为微分方程。然而，更多的非数值计算问颗无法用数学方程加以描述，下面请看3个例子。
例曰图书馆的书目检索系统自动化同题。当你想借阅一本参考书但不知道书库中是否有的时候；或者，当你想找某“方面的参考卜而不知图书馆内有哪些这方面的书时，你都需要到图书馆去查阅图书目录卡片。在图书馆内有各种名目的卡片：有按书名编排的、有按作者编排的、还有按分类编排的，等等。若利用计算机实现自动检索，则计算机处理的对象便是这些目录卡片上的书目信息。列在一张卡片上的一本书的书目信息可由登录号、书名、作者名、分类号、出版单位和出版时间等若干项组成，每一本书都有惟一的一个登录号，但不同的书自之间可能有相同的书名，或者有相同的作者名，或者有相同的分类号。由此，在书目自动检索系统中可以建立一张按登录号顺序排列的书目文件和3 张分别按书名、作者名和分类号顺序排列的索引表，如图1, ]所示。由这四张表构成的文件便是书目自动检索的数学模型，计算机的主要操作便是按照某个特定要求（如给定书名）对书目文件进行查询。诸如此类的还有查号系统自动化、仓库账目管理等。在这类文档管理的数学模型中，计算机处理的对象之间通常存在着是一种最简单的线性关系，这类数学模型可称谓线性的数据结构
例1一2计算机和人对弈问题。计算机之所以能和人对弈是因为有人将对弈的策略事先已存人汁算机。由于对弈的过程是在一定规则下随机进行的，所以，为使计算机能灵活对弈就须对对弈过程中所，自可能发生的清况以及相应的刈策都考虑周全，并狷，一个等数学
o田，山〕3疒
樊映川华罗庚
001，
L
理论力学
的3，
誑刂国03．
代数
1，
线性
栾汝书
闻4，
图I .〕图书目录文件示例
“好”的棋手在对弈时不仅要看棋盘当时的状态，还应能预测棋局发展的趋势，甚至最后结局。因此，在对弈问中，计算枞操作的对象是对弈过程中可能出现的棋盘状态一称为格局。例如图1. 2（a）所示为井字棋山的一个格局，而格局之间的关系是由比赛规则决定的。通常，这个关系不是线性的，因为从一个棋盘格局可以派生出几个格局，例如从图
1. 2（a）所示的格局可以派生出5个格局，如图i . 2（b）所示，而从每一个新的格局又可派生出4个可能出现的格局“因此，若将从对弈开始到结束的过程中所有可能出现的格局都画在一张图上，则可得到一棵倒长的“树”。'`树根”是对弈开始之前的棋盘格局，而所有的“叶子”就是可能出现的结局，对弈的过程就是从树根沿树杈到某个叶子的过程、“树” 可以是某些非数值计算问题的数学模型，它也是一种数据结构。
0
(a)棋盘格局示例以b）对弈树的局部“
例1．3多叉路口交通幻的管理问题。通常，在十字交叉路口只需设红、绿两色的交通灯使可保持止卞的交秩序，而在多叉路凵需设丿L种色的交讪灯才能既使车辆相互之间不碰撞，又能达到车辆的最大流通。假设有一个如图1? 3（a）所示的五叉路口，其中C 和E为靼行道。在路凵有13条可行的通路，其中有的可以同时通行，如A一B和E一C，井字棋由两人对赛。棋盘为3这3的方格．当一方的3个棋子占同．行、或同一列、或同一对角线时便为而有的不能同时通行，如E一B和A一D。那么，在路口应如何设置交通灯进行车辆的管理呢？(b)
图I. 3 五叉路口交通管理示意图
（五叉路口；（的表示通路的图
通常，这类交通、道路问题的数学模型是一种称谓“图”的数据结构。例如在此例的问题中，可以图中一个顶点表示一条通路，而通路之间互相矛盾的关系以两个顶点之间的连线表示。如在图1.3（b）中，每个圆圈表示图1. 3@所示五叉路口上的一条通路，两个圆之间的连线表示这两个圆圈表小的两条通路不能同时通行。设置交通灯的问题等价为对图的顶点的染色问题，要求对图一上的每个顶点染一种颜色，并且要求有线相连的两个顶点不能具有相同顱色，而总的颜色种类应尽可能地少。图1. 3（b）所示为一种染色结果，圆圈中的数字表示交通灯的不同颜色，例如3号色灯亮时只有D艹A和D艹B两条路可
综上3个例子可见，描述这类非数值计算问题的数学模型不再是数学方程，而是诸如表、树和图之类的数据结构。因此，简单说来，数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等的学科。
《数据结构》作为一门独立的课程在国外是从1968年才开始设立的“在这之前，它的某些内容曾在其他课程，如表处理语言中有所阐述。1968年在美国一些大学的计算机系的教学计划中，虽然把《数据结构》规定为一门课程，但对课程的范围仍没有作明确规定。当时，数据结构几平和图论，特别是和表、树的理论为同义语。随后，数据结构这个概念被扩充到包括网络、集合代数论、格、关系等方曲，从而变成了现在称之为《离散结构》的内容。然而，由于数据必须在汁算机中进行处理，因此，不仅考虑数据本身的数学性质，而且还必须考虑数据的存储结构，这就进一步扩大了数据结构的内容。近年来，随着数据库系统的不断发展，在数据结构课程中又增加了文件管理（特别是大型文件的组织等）的内容。
1％8年美国唐·欧．克努特教授开创了数据结构的最初体系，他所著的《计算机程序没计技巧》第一卷《基本算法》是第一本较系统地阐述数据的逻辑结构和存储结构及其操作的著作。从20世纪60年代末到70年代初，出现了大型程序，软件也相对独立，结构程序设到成为程序设诅方法学的主要内容，人们就越来越重视数据结构，认为程序设计的实质是对确定的问题选择一种好的结构，加上设计一种好的算法。从20世纪70年代中期到80年代初，各种版本的数据结构著作就相继出现。
目前在我国誣数据结构》也已经不仅仅是计算机专业的教学门划中的核心课程之一而且是其他非计算机专业的主要选修课程之《数据结构》在计算机科学中是一门综合性的专业基础课；数据结构的研究不仅涉及到计算机硬件（特别是编码理论、存储装置和存取方法等）的研究范围，面且和计算机软件的研究有着更密切的关系，无论是编译程序还是操作系统，都涉及到数据元素在存储器中的分配问题在研究信息裣索时也必须考虑如何组织数据，以便查找和存取数据元素更为方便。因此，可以认为数据结构是介于数学、计算机硬件和计算机软件三者之间的一门核心课程（如图匚4所小）。在计算机科
学中，数据结构不仅是一般程序设计（恃别是 图1.4《数据结构》所处的地位非数值计算的程序设计）的基础，而目．是设计
和实现编译程序、操作系统、数据库系统及其他系统程序和人型应用程序的重要基础
值得注意的是，数据结构的发展并未终结，一方面，面向各专门领域中特殊问题的数据结构得到研究和发展，如多维图形数据结构等：另一方面，从抽象数据类型的观点来讨论数据结构，已成为一种新的趋势，越来越被人们所重视“
l . 2基本概念和术语
在本节中，我们将对一些概念和术语赋以确定的含义，以便与读者取得“共同的语訁生这些概念和术语将在以后的章节中多次出现
数据(Da@是对客观事物的符号表示，在计算机科学中是指所有能输人到计算机中并被计算机程序处理的符号的总称。它是计算机程序加工的“原料”。例如，一个利用数值分析方法解代数方程的程序，其处理对象是整数和实数：一个编译程序或文字处理程序的处理对象是字符串。因此．对计算机科学而言，数据的含义极为广泛，如图像、声音等都可以通过编码而归之于数据的范畴
数据元（Da Elem“t）是数据的基本单位，在计算机程序中通常作为一个整体进行考和处理“例如，例]一2中的“树”中的一个棋盘幣局，例1一3中的“图”中的一个圆圈都被称为一个数据元素。有时，一个数据元素可由若干个数据项（Data m）组成，例如，例中一本书的书目信息为一个数据元素，而书目信息中的每一项（如书名、作者名等）为一个数据项；数据项是数据的不可分割的最小单位
数据对象（DaLa (-)bject)是性质相同的数据元素的集合．是数据的一个子集。例
，整数数据对象是集合N一紳， ，到，字母字符数据对象是集合C— f'A，敵据结构山S “ “ cut．0是相互之间存在一种或多种特定关系的数据元素的集合。
这是本书对数据结构的一种简单解释叭从1. 1节中3个
例子可以看到，在任何问题中，数据元素都不是孤立存在
0
0
的，而是在它们之间存在着某种关系，这种数据元素相互之
集合 0 0
0
间的关系称为结构〈& ructure)o根据数据元素之间关系的
0
不同特性，通常有下列四类基本结构：0）集合结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关0（2）线性结构结构中的数倨元素之间存在一个对个的关系3）树形结构结构中的数据元素之间存在
个对多个的关系这4）图状结构或网状结构结构中的数据元素之间存在多个对多个的关系。图1, 5为上述4类基本结构的关系图。由于“集合”是数据元素之间关系极为松散的一种结构，因此也可用其他结构来表示它。
数据结构的形式定义为：数据结构是一个二元组
Data Structure = (D，S) 0．D
图1. 5四类基本结构关系图
其中：D是数据元素的有限集，s是D上关系的有限集。下面举两个简单例子说明之。
例]一4在计算机科学中，复数可取如下定义：复数是一种数据结构 Complex，。（0，R）
其中：0是含两个实数的集合{ cl “ 2：球：“．《0，而P是定义在集合C上的一种关系《01娌巪，其中有序偶〈cl》表示疒1是复数的实部“2是复数的虚部“
例1一5假设我们需要编制一个事务管理的程序，管理学校科学研究课题小组的各项事务，则首先要为程序的操作对象一课题小组设计一个数据结构。假设每个小组由 1位教师、]、3名研究生及1、6名本科生组成，小组成员之间的关系是：教师指导研究生，而由每位研究生指导一至两名本科生。则可以如下定义数据结构：
（1一3）其中：P一{ T，GL，
R =巛1，Re }
RI亠{〈T，G >《
上述数据结构的定义仅是对操作对象的一种数学描述，换句话说，是从操作对象抽象出来的数学模型。结构定义中的“关系"描述的是数据元素之间的逻辑关系，因此又称为 对于数据结构这个概念，至今尚耒有一个被致公认的宗义，不同的人在使用这个词时所表达的思有所
这和数学中的集合概念是．致的。
T表示导师，G表示岍咒生，5表小，、学生。
5
数据的逻辑结构然而，讨论数据结构的目的是为了在计算机中实现对它的操作，因此还需研究如何在计算机中表示它。
数据结构在计算机中的表示（又称映像）称为数据的物理结构，〖称存储结构。它包括数据元素的表示和关系的表示。在计算机中表示信息的最小单位是二进制数的一位，叫做位〈bit）。在计算机中，我们可以用一个由若干位组合起来形成的一个位串表示一个数据元素（如用．个字长的位串表示一个整数，用8位二进制数表示一个字符等），通常称这个位串为元素叭Element）或结点（N。de）。当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为数据域（Data Field)o因此，元素或结点可看成是数据元素在沣算机中的映像。
数据元素之间的关系在计算胡，中有两种不同的表示方法．顺序映像和非顺序映像，葑由此得到两种不同的存储结构顺序存储结构和链式存储构。顺序映像的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。例如，假设用两个字长的位串表示一个实数，则可以用地址相邻的4个字长的位串表示一个复数，如图1? 6 (a)为表示复数彐一3．0一2，31和之2一一0．7 + 4，的顺序存储结构；非顺序映像的特点是借助指示元素存儲地址的指针（“ “）表示数据元索之间的逻辑关系，如图6伟）为表示复数彐的链式存储结构，其中实部和虚部之间的关系用值为“ 0415 ”的指针来表示（04巧是虚部的存储地址）六数据的逻辑结构和物理结构是密切相关的两个方面，以后读者会看到，任何一个算法的设计取决于选定的数据（逻辑）结构，而算法的实现依賴于采用的存储结构。
o 们5
0611
o 们3
o们5
0300
0302
0632
0634
图1．6复数存储结构示意图
（的顶序存储结构#（链式存储结构
如何描述存储结构呢虽则存储结构涉及数据元素及其关系在存储器中的物理位置，但由于本书是在高级程序语訁的层次上讨论数据结构的操作，因此不能如上那样直接以内存地址来描述存储结构，但我们可以借用高级程序语言中提供的“数据类型"来描述本书中有时也把数据元素简称为元素，读者应从上下文去覡解分之。 庄实际应用中．像复数这类极简单的结不需妻采用式存结构，在此仅为了化讨论而作为假例引用之。
它，例如可以用所有高级程序语言中都有的“一维数组”类型来描述顺序存储结构，以C 语言提供的“指钅的来描述锖式存储结构自假如我们把C语言石成是一个执行C指令和 C数据类型的虚拟处器，那么本1刂中讨论的存储结构是数据结构在C虚拟处理器中的表示，不妨称它为虚拟存储结构
数据类型（Data Type）是和数据结构密切相关的一个概念，它最早出现在高级程序语言中，用以刻画（程序）操作对象的特性。在用高级程序语言编写的程序中，每个变量、常或表达式都有一个它所属的确定的数据类型。类型明显或含地规定了在程序执行期间：送式所有可能取值的范围，以及在这些值允许进行的操作。因此数据类型是祚值合和定义在这个值集上的一组操作的总称。例如，c语言中的整型变量，其值集为某个区间上的整数（区间大小依赖于不同的机器），定义在其卜的操作为：加、减、乘和取模等算术运算。
按“值"的不同特性，高级程序语言中的数据类型可分为两类：一类是非结构的原子类型。原子类型的值是不可分解的。如：c语言中的基本类型（整型、实型、字符型和枚举类型）、指针类型和空类型。另一类是结构类型。结构类型的值是山若干成分按某种结构组成的，因此是可以分解的，并且它的成分可以是非结构的，也可以是结构的“例如数组的值由若T"分量组成，每个分量可以是整数，也可以是数组等。在某种意义上，数据结构可以看成是“一组具有相同结构的值”，则结构类型可以看成由一种数据结构和定义在其上的一组操作组成
实际上，在计算机中，数据类型的概念并非局限于高级语言中，每个处理器枞包括计算机硬件系统、操作系统、高级语言、数据阼等）都提供了一组原子类型或结构类型。例如，一个门算机硬件系统通常含有“位”、“字节"、“字”等原子类型，它们的操作通过计尊机设计的一套指令系统直接由电路系统完成誦]高级程序语言提供的数据类型，其操作需通过编译器或解释器转化成低层即汇编语訁或机器语訁的数据类型来实现。引人“数据类型"的目的，从硬件的角度看，是作为解释汁算机内存中信息含义的一种手段，而对使用数据类型的用户来说，实现了信思的蔽，即将一切用户不必了解的细节都封装在类型中例如，用户在使用“整数"类型时，既不需要了解“整数"在计算机内部是如何表示的，也不需要知道其操作是如何实现的。如“两整数求和"，程序设计者注重的仅仅是其“数学上求和"的抽象特性，而不是其硬件的“位"操作如亻可进行。
抽象数据类型（Abstra画Data汾pe，简称ADT）是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特陸，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。
抽象数据类型和数据类型实质上是一个概念。例如，各个计算机都拥有的“整数"类型是一个抽象数据类型，尽管它们在不同处理器上实现的方法可以不同，但由于其定义的数学特性相同，在用户看来都是相同的。因此，“抽象"的意义在于数据类型的数学抽象特性。；〕在此備广义的处理器，包招刂机的硬糸统和软件系统“ 另一方面， 据 的范畴史广，它不再局限于前述各处理器中己定义并实现的数据类型（也可称这类数据类型为固有数据类型），还包括用户在设计软件系统时自己定义的数据类型。为了提高软件的复用率，在近代程序设计方法学中指出，一个软件練的框架应建立在数据之上，而不是建立在操作之上（后者是传统的软件设计方法所为即在构成软件系统的每个相对独立的模块上，定义一组数据和施于这些数据上的操作并在模块内部给出这些数据的表示及其臊作的细兯，而在模块外部使用的只禦丬数据和抽象的操作。显然，所定义的数据类型的抽象层次越高，含有该抽象数严前嫌模块的复用程度也就越高。
一个含抽象数据类型的软件模块常应包含定义、表示和实现3个部分，
如前所述，抽象数据类型的定义由一个值域和定义在该值域上的一组操作 、若按其值的不同特性．可细分为下列3种类型：
原子类型(Atomic Data Typ的属原子类型的变量的值是不可分解的。这类抽象数据类型较少，因为一般情况下，己有的固有数据类型足以满足需求。但有时也有必要定义新的原子数据类型，例如数位为100的整数。
固定聚合类型（Fi “ d一ag墅咪a@ Data Type)属该类型的变量，其值山确定数目的成分按某种结构组成。例如，复数是山两个实数依确定的次序关系构成
可变聚合类型(Variable\ggregate Data Type）和固定聚合类型相比较，构成可变聚合类型“值”的成分的数目不确定。例如，可定义一个“有序整数序列”的抽象数据类型，其中序列的长度是可变的。
显然，后两种类型可统称为结构类型。
和数据结构的形式定义相对应，抽象数据类型可用以下三元组表示
o丿，S，尸） 口一4）其中，D是数据对象、S是D上的关系集，P是对D的基本操作集。本书采用以下格式定义抽象数据类型：
，抽歙数据类型名{
数据对象：〈数据对象的定义》數据关系數据关豕的定义》蓽本操作基本作的定义》潷匿象数据类型名
其中，数据对象和数据关系的定义用伪码描述，基本操作的定义格式为
基本操作名（参数表）
初始条件初始条件描述、操作结果：〈操作结果描述》
基本操作有两种参数；赋值参数只为操作提供输人值；引用参数以&打头，除可提供输人值外，还将返回操作结果。．初始条件"描述了操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败．并返回相应出错信息。“操作结果"说明了操作正常完成之后，数据结构的变化状况和应返回的结果。若初始条件为空，则省略之
例于6 据 三元组的定义：
耵r Triplet. {
据对象= { el，e2．e3 !el迮2．e3 0 Elemset（定义了关系运算的某个集合）} 敷据关系；田《e厶的
基本操作；
InitTrip1et( &T. VI . 1/2，"3）
操作结果：构造了三丿L组T，元素el,e2和e3分别被賦以参数v ]，v?和v3的值， DestroyTr ipiet( &?T）
操作结果：一《元组T被销毁。初始条件0元组T已存在，1飞0 3。
操作结果：用e返回T的第元的值。
Put( &T，i ,e）
初始条件：二元组T己存在口《讼《3。
操作结果：改变T的第宝元的值为e。
IFiAscending( T）
初始条件0《《元组己存在。
操作结果：如果T的3个元素按升序排列，则返回]，否则返回叭 I$Degcending( T）
初始条件：三元组T己存在。
操作结果；如果T'的3个元索按降序卅列，则返回I，否则返回0。
Max( T, &心）
初始条亻1：一二元组T已存在
操作结果！用e返回'1'的3个元衷中的最大值。
Min( T. be）
初始条件：三元组T己存在。
操作结果：用0返回T的3个元素中的最小值。
页Tr 1
多形敵据类型(Polymorphic Data rype )是指其值的成分不确定的数据类型。例如，例1一6中定义的抽象数据类型T自p ] et，其元素刁、和e3可以是整数或字符或字符串，甚至更复杂地由多种成分构成（只要能进行关系运算即可然而，不论其元素具有何种特性，几素之间的关系相同．基本操作亦相同。从抽象数据类型的角度看，具有相同的数学抽象特性．故称之为多形数据类型。显然，需借助面向对象的程序设计语言如C “ 等实现之。本书中讨论的各种数据类大多是多形数据类型，限于本书采用类C语言作为描述工具，故只讨论含有确定成分的数据元素的情况。如例I一6中的Elem& t是某个确定的、将山用户自行定义的、含某个关系运算的数据对象。
1 . 3抽象数据类型的表示与实现
抽象数据类型可通过固有数据类型来表示和实现，即利用处理器中已存在的数据类型来说明新的结构，用己经实现的操作来组合新的操作。由于车书在高级程序设计语言
9
的虚拟层次上时论 的表示和实现，并且讨论的数据结构及其算法主要是面向读者，故采用介于伪码和〔：言之间的举C语言作为描述工貝，有时也用伪码描述
些只含抽象操作的抽象算法。这使得数据结构和算法的描述和讨论简明清晰．不拘泥于 C语言的细节，又能容易转换成C或者C “程序。
本书采用的类C语言精选了C陪的一个核心子集、同时作了若十扩充修改，增强了语訁的描述功能。以下对其作简要说明
( l )预定义常量和类型：
o函数结果状态代码
# define T瞓
# def{ne下Al．
*define 0K *define ERROR
# d f INFEASIBLE一]// status(# define )是函数的(OVERFLOW)类型，其值是函数结果状态代码 typedef int Statu3;
（2） 数据结构的表示（存储结构）用类型定义（typedef)描述。数据元素类型约定为 E@rnType，由用户在使用该数据类型时自行定义。
（3） 基本操作的算法都用以下形式的函数描述；
函类型函数名（数参数表）{
法说期语句序列
}永数名
除了函数的参数需要说明类型外，算法中使用的辅助变量可以不作变量说明，必要时对其作用给予注释。一般而羊a、b、c、d、e等用作数据元素名，i、j、k上m．n等用作整型变量名，p、q、r等用作指针变量名。当函数返回值为函数结果状态代码时，函数定义为a 类型。为了便于算法描述，除了值调用方式外，增添了C “语言的引用调用的参数传递方式。在形参表中，以&打头的参数即为引用参数。
（们赋值语句有
简单赋值变量名：表达式；
串联赋值变量名1艹变量名2 ：变量名k，表达式；
成组赋值（变量名，，，，，，量名幻表达式1，，，，．表达式k）；
结构名·结枘名
结构名值]，，“．值k）；
变量名00表达式；
变量名[起始下标·终止下标吓变名「起始下标一终止下标
交换赋值变名艹变量名礻
条件赋債变量名一条件表达式？表达式T表达式选择语句
条件语句1 if（表达式）浯句; 条件语句2讠f（表达式）语句；
10 ·开关语句I
廾关语句2
else i?句，辶℃h（表达式值i :语句序列1；break;
case {K n;浯句序列n; break； d “：语句序列n+ ]；
3witch { case条件]；语句序列]；break；
““条件n：语句序列n; breakJ d。f且：厝句序列n+ 1；（6）循环语句有
for语句
for（赋初值表达式序列；条件；峰改表达式序列）语句；
妯诅e语句
妯i（条件）语句
do-while i吾句
do {
语句序列：
》“h土1。（条件
（7） 结束语句有
函数结束语句
return表达式；
结束语句
break；
异常结束语句
exit'《异常代码）；
（8） 输人和输出语句有
输人语句?canf（[格式串六变景1．，，，，变0 n)；输出语句匹炻田〔格式申]，表达式0，，，表达式山通常省略格式申。
（的注释
单行注释文字序列 ( 10)基本数有
求最大值
的（表达式 ．，表达式n）
求最小值
nin（表达式1， ，，表达式n）
求绝对值
曲3（表达式）
求小足整数值
臼凶r（表达式）
求进位整数值
ceil（表达式）
判定文件结束
eof（文件变量）或cof
判定行结束
艹In（文件变量）或In
（1 1）逻辑运算约定
与运算& &；当A的值为0时．不冉对B求值。
或运算凵：对于瞓阳，当A的值为非0时，不再对B求值。
例1一7抽象数据类型巨甲0的表示和实现。
一采用动态分配的顺序存槠结钩 typed?f五№瞪TY卩0 / '由Tr讳t分配3个元素存储空间
慧本操作的函数原型说明
Status InitTriplet (Triplet Elemlype叫，Elenaype； 操作结果：构造了三九组1，元素el ? e2和e3分别被賦以参数VI、和vs的值。
Status DeserQYffriplet； 操作结果：三兀组被销毁
Status Get (Triplet T ' int (e)； '初始条件：三元组已有在，]到0《3。／/操作结果：用e返回T的第元的值。 Status put (Triplet &?T. int F.lemType e) ; 初始条件：三元组T己存在，性0《3。
/丿操作结果：改变T的第1兀的值为e。
Stet:uo 1%Ascending（Tri卫1 e L 0； 初始杀：三元组T已存在。
操作结果：如果T的3个元幸按升序排列，则返回]，否则返回
Status J*Desseending（Tc iplet T〕； 初始条件：三元组T已存在。 操作结果：如果的3个素按降序排列，则返回1，否则返回（〕。
Status Max（Trip〕.et T，ElemType ／7初始条件0元组已存在。作结果：用亡返回T的3个元素中的最人值。
Status Min (Triplet T. ElemType 初始条件0《元组T己存在。
作结果：用e返回T的：0、元素中的最小值。
一基本操作的实现
Status InitTriplet (Triplet FlemType，ElemTYPe v2，F'lemTvpe (;) { 构造三元组T．依次置T的个元素的初值为v ]，v2和v3a
T。(Ele?qTYpe诗）nanoa（3诗“。El TYP）；//分配3个丿L素的存储空间迳（！T)姒it（趾就；分阑存儲空间失败 T〔的 丷2； T「2 ] return 0
} InitTrip1eE
Statue Destroy'Trip)et (Triplet &的{ 销毁过元组T。
Free(T)； return OK；
）Destroy'Triplet
Status Get (Triplet T，i' ElemType (e) { // 1《i《3，用e返回T的第i元的值过(1<1土> 3）return ERROR;return 0队：
}汐cet
Status put int i? Elemlype 0）{ 汐这《3，置T的第1元的疽为釓 縊< 1！辶冫3）return E OR：return 0；
] 2
是/ Put
Status 1尋cer司in刂（Tripler的{
如果T的3个元素按序排列．则返回]．否则返回0、 return (TKO] < }汐IsAscending
Status IsDescendlng (Triplet T) {
如果的3个元素按降序排列，则返回后否则返回0。
return (TLC'] > * T 0）& & (TC11> = T[ 2」后
} IsDescending
Stotu3 Max (Iriplet &国{ 用e返回指向T的最大元幸的值
：T「2书？T「明：T骁兯
：( ( TCII 。TL2?-I)？T00 T〔2兯； OK；
以0
5上a上us Min (Triplet T' ElernType & {
//用e返回指向T的最小元素的值return OK；
00行n
1 . 4算法和算法分析
1. 4，1算法
算法（A《№ ri山）是对特定问题求解步骤的一种描述，它是指令的有跟序列，其中每一条指令表示一个或多个操作；此外，一个算法还具有下列5个重要特性：
（1） 有穷性一个算法必须总是（对任何合法的输人值）在执行有穷步之后结束，且每一步都可在有穷时间尘内完成；
（2） 确定性算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。
并且，在任何条件下，算法只有惟一的．条执行路径，即对于相同的输人只能得出相同的
（3） 可行性一个算法是能行的，即箅法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
（4） 输入一个箅法有零个或多个的输人，这些输入取自于某个特定的对象的集合。
输出一个算法有一个或多个的输出。这些输出是同输入有着某些特定关系
1.4，2算法设计的要求
通常设计一个“好"的算法应考虑达到以下目标。
（l)正确性．2(Correctness)算法应当满足具体问题的需求 通常一个大型问题的 在此，有穷的概念不是纯数学的．面是在实际上是合理的，可接受的 有关箅法正确性的严明．0阅书目[ 5，
1 3
需求，要以特定的规格说明方式给出，一个实习问题或练习题、往往就不那么严格，目前多数是用自然语0描述需求．它至少应当包拮对于输人、输出和加工处理等的明确的无歧义性的描述。设训或选择的算法应当能正确地反映这种需求，否则，算法的正确与否的衡量准则就不存在
止确一词的含义在通常的用法中有很人差别，大体可分为以小个层次：a，程序不含语法错误；b程序对于炖组输人数据能够得出满足规格说明要求的结果“程序对于精心选择的典型、苛刻而带有刁难性的几组输人数据能够得出满足规格说明要求的结果；（I.程序对于一切合法的输人数据都能产生满足规格说明要求的结果。显然，达到第d层意义下的正确是极为困难的，所有不同输人数据的数量大得惊人，逐一验证的方法是不现实的。对于大型软件需要进行专业测试，而一般情况下，通常以第c层意义的正确性作为衡量一个程序是否合格的标准。
（2） 可读性(Readability)算法主要是为了人的阋读与交流，其次才是机器执行。
可读性好有助于人对算法的理解；晦涩难懂的程序易于藏较多错误难以调试和修改。
（3） 健壮性（R陆吓当人数据非法时，法也能适当地作出反应或进行处理，而不会产生莫明其妙的输出结果。例如，一个求凸多边形面积的算法，是采用求各一角形面积之和的策略来解决问题的。当输人的坐标集合表示的是一个凹多边形时，不应继续讠．i算，而应报告输人出错。并且，处理出错的方法应是返回，个表示错误或错误世质的值，而不是打印错误信息或异常，并中止程序的执行，以便在更高的抽象层次上进行处理。
（的效率与低存储量需求讪俗地说，效率指的是算法执行时间。对于同一个问题如果有多个算法可以解决，执行时间短的算法效率高。存储是需求指算法执行过程中所需要的最人存储空间，效率与低存储量需求这两者都与问题的规模关。求100个人的平均分与求1 000个人的平均分所花的执行时间或运行空间显然有一定的差别。
1. 4，3箅法效率的度趾
算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间涌常两种方法！
o）事后统计的方法。因为很多i十算机内部都有计时功能，有的麸至可精确到毫秒级，不同算法的程序可通过一组或若干组相同的统计数据以分辨优劣。但这种方法有两个缺陷一是必须先运行依据算法编制的程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。因此人们常常采用另一种事前分析估算的方法。
（2）事前分析估算的力法、一个用高级程序语訁写的程序在计算机上运行时所消耗的时间取决于下列因素：
o 依据的算法选用何种策略；
o 问题的规模，例如求100以内还是I的0以内的素数
〔3）书写程序的语訂，对于同一个算法，实现语言的级别越高，执行效率就越低，
@编译程序所产生的机器代码的量；
@机器执行指令的速度。
显然，同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机L运行时，效率均不相同。这表明使用绝对的时间单位衡量算法的效率是不合适的撇开这些与计算机硬件、软件有关的因素，可以认为一个特定算法“运行工作量”的大小，只依赖于问题的规模（通常用整数量表示），或者说，它是问题规模的函数
一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。
例如，在如下所示的两个N／N矩阵相乘的算法中，“乘法”运算是“矩阵相乘问题” 的基本操作。整个算法的执行时间与该基本操作（乘法）重复执行的次数成正比，记作for（i =吓、< n；+忄2
for 0 “〕；羊0，0了j) {
扑到
for 0 k《n；±tk)
。0北j ] “跹璉k吓b〔k卫
一般情况下，算法中基本操作重复执行的次数是问题规模的某个函数不，D，算法的时间量度记作
T(n)亠0（不） 0一5）它表示随问题规模的增大，算法执行时间的增长率和不的的增长率相同，你做算法的渐近时间复杂度（Asympt丽c Time Complexity)，简称时间复杂度、
显然，被称做问题的基本操作的原操作应是其重复执行次数和算法的执行时间成正比的原操作，多数情况下它是最深层循环内的语句中的原操作，它的执行次数和包含它的厝句的频度相同。语句的频度（Frequency Count）指的是该语句重复执行的次数，例如：在下列3个程序段中，（c)〔Of 0 1《j < n；+ +的含基本操作“文增1 ”的语句的频度分别为1 “和，则这3个程序段的时间复杂度分别为0（1），00D和0@），分别称为常量阶、线性阶和平方阶。算法还可能旱现的时间复杂度有：对数阶00。g的，指数阶0（2 "）等。不同数量级时间复杂度的性状如图1- 7所示。
从图中可见，我们应该尽可能选用多项式阶0（是）的算法，而不希望用指数阶的算法。
一般情况下，对一个问题（或一类算法）只需选择一种基本操作来讨论算法的时间复
T(n)
3000
20
i000
图1满常见函數的噌长率
杂度即可，有时也需要同时考虑几种基本操作，甚至可以对不同的操作赋以不同权值，以反映执行不同操作所需的相对时间，这种做法便于综合比较解决同一问题的两种完全不同的算法。
由于算法的时间复杂度考虍的只是对于问题规模月的增长率，则在难以精确计算基本操作执行次数（或语句频度）的情况下，只需求出它关于“的增长率或阶即可。例如，在下列程序段中，
fo 0。2；i <甴+ 10
for（j = 2到0 “的@ + aCiI Cj]
语句，“ x的执行次数关于的增长率为是，它是语句频度表达式一一2）/ 2中增长快的项。
有的情况下，算法中基本操作重复执行的次数还随问题的愉人数据集不同而不同。
例如在下列起泡排序的算法中，
void bubble. sort(int a〔〕，int n)（
汐将a中整数序列重新排列成自小大有序的整数序列。
for 0 = n— change-曲《i 1 & & change;
0 for =(change ) i< (FALSE：)；+ + j)
（缸到> arj + 0）{矸j．卜一-缸j +凵；change = TR?E; }
} bubble- 90
“交换序列中相邻两个整数，为基本操作。当“中初始序列为自小至大有序，基本操作的执行次数为山当初始序列为自大至小有序时，基本操作的执行次数为” 0冖1) / 2。对这类算法的分析，一种解决的办法是计算它的平均值，即考虑它对所有可能的输人数据集的期望值，此时相应的时间复杂度为算法的平均时间复杂度。如假设口中初始输人数据可能出现利种的排列情况的概率相等，则起泡排序的平均时间复杂度T（一00的，然而，在很多情况下，各种输人数据集出现的概率难以确定，算法的平均时间复杂度也就难以确定。因此，另一种更可行也更常用的办法是讨论算法在最坏情况下的时间复杂度，即分析最坏清况以估算算法执行时间的一个《界。例如，上述起泡排序的最坏情况为“中 1 6 @
初始厅列为自人生小有序，则起泡排序算法在最坏情况下的时间复杂度为T00艹0的。
在本书以后各章中讨论的时间复杂度，除特别指明外，均指最坏情况下的时间复杂度。
实践中我们可以把事前估算和事后统计两种办法结合起来使用。以两个矩阵相乘为例，若上机运行两个] 0 × 10的矩阵相乘，执行时间为12ms，则由算法的时间复杂度
T(n) 00的可估算两个30〈31的矩阵相乘所需时间大致为（3010）3 · 12m5 358m
I .舂4算法的存储空间需求
类似于算法的时间复杂度，本书中以空间复杂度（Sp “ e C。mplexity）作为算法所需存储空间的量度．记作其中月为问题的规模（或大小）。一个上机执行的程序除了需要存储空间来寄存本身所用指令、常数、变量和输人数据外，也需要一些对数据进行操作的工作单儿和存储，些为实现计算所需信息的辅助空间。若输人数据所占空间只取决于问题本身，和算法无关，则只需要分析除输人和程序之外的额外空间，否则应同时考虑输人本身所需空间（和输入数据的表示形式有关）。若额外空间相对于输人数据量来说是常数，则称此算法为原地工作，第10章讨论的有些排序算法就属于这类。又如果所占空间量依赖丁特定的输人，则除特别指明外，均按最坏情况来分析
1 7
第2章线性表
从第2章至筇4章将讨论线性结构。线性结构的特点是：在数据元索的非空有限集中，（l)存在惟一的一个被称做“第一个”的数据元素；（2）存在惟一的一个被称做“最后一个”的数据元素以3）除第一个之外，集合中的每个数据元素均只有一个前驱；（，0除最后一个之外，集合中每个数据元素均只有一个后继
2，1线性表的类型定义
*?*(Linear List)是最常用且最简单的一种数据结构。简言之，一个线性表是艱个数据元素的有限序列。至于每个数据元素的具体含义，在不同的情况下各不相同，它可以是一个数或一个符号，也可以是一页书，甚至其他勇复杂的信息。例如，26个英文字母的字母表：
（A，B，C，，0 Z)
是一个线性表，表中的数据元素是单个字母字符。又如，某校从1978年到1983年各种型号的计算机拥有量的变化情况，可以用线性表的形式给出：
（6，1 7，28，5 0，9 2，讣8）
表中的数据元素是整数“
在稍复杂的线性表中，一个数据元素可以山若干个数据项山em）组成、在这种情况下，常把数据元素称为记录（Record），含有大量记录的线性表又称文件（Fi同。
例如，一个学校的学生健康情况登记表如图2．1所示，表中每个学生的情况为一个记录，它由姓名、学号、性别、年龄、班级和健康状况等6个数据项组成。
姓名
学号
性别
年龄
班级
康状况
王小林陈红
刘建平张立立
7 631
7 632
7吣633
7906
男女
计计叫计9 ] 计9 1
帥康
神经衰弱
图2．1学生健康情况登记表
综合上述3个例子可见，线性表中的数据元素可以是各种各样的，亻日同一线性表中的元素必定具有相同特性，即属同一数据对象，相邻数据元素之间存在着序偶关系。若将线性表记为
（2一I )
则表中“，I领先于以领先于的一产称“《是a，的直接前驱元素,a宀是的直接后继元素。当，一一1时“有且仅有一个直接后继，当i一2，3，．“，”时“有目仅有一个直接前驱。
线性表中儿翥的个数以，0均）定义为线性表的长度= 0时称为空表。在非空表中的每个数据儿素都有一个确定的位置，如是第一个数据元素，‰是最后一个数据元素“是第，个数据元素，称为数据元素“：在线性表中的位序。
线性表是一个相当灵活的数据结构，它的长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，还可进行插人和删除等。
抽象数据类型线性表的定义如下：数据对象．D = a, l a, e ElemSet, i 1，2，，n，n 0 } 数据关系：RI = { <甴一0甴>甴一0 D，i = 2，
基本操作：
InitLise.( &L）
操作结果：构造一个空的线性表0初始条件线性表L己存在。
操作结果毁线性表L。
ClearLigt〈&-L）
初始条件：线性表L已存在。
操作结果：将L料为空表。
巧引下mpt枞L）
初始条件：线性表L已存在。
襟作结果：若L为空表，则返回T間E，否则返回 Listl?er'lgfh( L）
初始条件：线性表L已存在。
操作结果：返回L中数据元素个数。初始杀件：线性表L已存在刁《1《凵就L“*h（L 操作结果：用0返回L中第1个数据元素的值。
儲0上eEl（巛e，compare()）
初始条件：线性表L己存在，地npare()是数据元素判定丞数。
操作结果：返回L中第1个与e满是关系com因reo的数据元素的位序．若这样的数据元素不存在，则返回值为0。
PriorE1esn( cur- e. pre e）初始条件性表乙已仃在
操作结果諾“。e是L的数据元素，且不是第一个，则用pre．e返回它的前驱，否则操作失败．pre e无定义。
NexLFTem( L，cm《e，& next．e）初始条件：线性表L已存在。
操作结果．若亡ur “是L的数据元素，且不是最后一个，则用e返回它的后，否则操作失败e “无定义。
Listlnseft( &陈讼e）
初始条付：线性表L己存在，区《L土stLen其h（L）。
操作结果：在L中第i个位置之前插人新的数据元素e，L的长度加]。
l'istDeletc(&L. i?巳〕
1 9 初始条件： 已存在且非空，1过i*L tie四th（L）。
操作结果：删除L的第个数据元素，并用e返回其值，L的长度减0
ListTraverse()'，v t(
初始条件：线性表L已存在。
搡作结果依次对的每个数据元素调用函数v“it（一旦v址0朱败，则作朱败 } ADT List
对主述定义的抽象数据类型线性表，还可进行一些史复杂的操作。如：将两个或两个以上的线性表合并成一个线性表；把一个线性表拆开成两个或两个以上的线性表；重新复制一个线性表等。
例2一1假设利用两个线性表LA和L月分别表示两个集合為和B（即：线性表中的数据元累即为集合中的成员），现要求一个新的集合“4 = AUB。这就要求对线性表作如下操作：扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插人到线性表LA中去。只要从线性表LB中依次取得每个数据元素，并依值在线性表LA 中进行查访，若不存在，则插人之。上述操作过程可用下列算法描述之。
void union(List &．，List. Tub) {
将所有在线性表lib中但不在隔中的数据元素插人到中
．len “ ListLength(G?h Lb. 1 “ = 0吡n h(l上〉0求线性表的长度 for（i 0 i <“ Lb-五叫i + +）{
Ge le．i.； ／/取Lb中第i个数据元素赋给e
0 LocateE1e111([n. e, equal)) + 1、Jen山，e)；
彦中不存在和e相同的数倨元紊，则插人之
} union
箅法2．1
例2一2 已知线性表0乁和LB中的数据元素按值非递减有序排列，现要求将LA和
LB归并为一个的线性表LC ,且LC中的数据元素仍按值非递减有序排列。例如，设
LA亠（3，5，8 ,10
LB =（2，6，8，9，11，1 5，20）
LC一（2，3，5．6，8，8，9，门，11，1 5，20）
从上述问题要求可知，L〔'中的数据元素或是LA中的数据元素，或是L月中的数据元素，则只要先设LC为空表，然后将L，A或LB中的元素逐个插人到LC中即可。为使 LC中元素按值非递减有序排列，可设两个指钅0和丿分别指向LA和L力中某个元素，若设下当前所指的元素为a，丿当前所指的元素为猕则当前应摘人到LC中的元素。为
当< b时 b当a >时 工“岫1 “表示．参数len的值先增]，然后再传递给数。若数学符号“在畛量名之后．则表示先将参数传递给函数，后参数的偵冉增1。以后均类同
显然，指针i和丿的初值均为1，在所脂元素插人LC之后，在LA或L月中顺序后移。上述归并算法如算法2．2所示b
void MergeList(List [．List Lb. I-ast &Lc) {
／7已知线性表和Lb中的数据元素按值非递减排列。
//归丌和Lb得到新的线性表，的数据元素也按值非递减排列。
InitList(Lc)
La len List.Length(）；陆．len = ListLength( lab)；
While（0、《0口“》&．& 0 Lb- len)) 0/和Lb均非空
CetE1em(La, i，后GetF.1em(Lb 辽()i <生b)) {L?gtlnsert(tc.
else (Listinsert(L?，，0，k，b))；
以h玉le (i <= La- Len) {
G国下lem（陆，i + +，(i)；Listlnsert(l/::，1忄k，(i)；
while (j < Lb- {
GetE1em(Lb. j + +，b-j)i Listlnsert(tc, + + k, (j)；
}丿MergeList
算法2，2
上述两个算法的间复杂度取决于抽象数据类型List定义中基本操作的执行时间。假如GctElem和这两个操作的执行时间和表长无关，L tateE丨em的执行时间和表长成上比，则算法2，1的时间复杂度为O(ListLength(LA) >< ListLength(LB))?? 法2．2的时间复杂度则为0（ListLength(LA)+ListLength(LB))o虽然算法2．2中含3 个、hi@循环语句，但只有当和丿均指向表中实际存在的数据儿素时，才能取得数据兀素的值并进行相互比较；并且当其中一个线性表的数据元素均已插人到线性表LC中后，只要将另外、个线性表中的剩余元素依次插人即可。因此，对于每一组具体的输人（L 和LB），后两个（whi@循环语句只执行一个循环体
2，2线性表的顺序表示和实现
线性表的顺序表小指的是用，组地址连续的存储单元依次存储线性表的数据元素。
假设线性表的每个元素需占用I个存储单元，并以所占的第一个单元的存储地址作为数据兀素的存储位置。则线性表中第i丰1个数据元素的存储位置LOC宀）和第i个数据元素的存储位置L阢飞0之间满足下列关系
℃ (atl 1）=丸以）+ /
一般来说，线性表的第个数据元素的存储位置为
一0买/ （2一2）
· 21
式中LOC（甴）是基地址。的第一个数据兀素的存储位置，通常称做线性表的起始位置或 线性表的这种机内表示称做线性表的顺序存储结构或顺序映像〔& quen山I Map ping)，涌常，称这种存储结构的线性表为顺序表。它的特点是，为表中相邻的元素和宀赋以相邻的存储位置L（℃）和L仪：十D。换句话说，以元素在计算机内“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。个数据元素的存储位置都和线性表的起始位置相差一个和数据元累在线性表中的位序成正比的常数（见图2．0。由此，只要确定了存线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构
存储地址 内存状态烈据元在线表中的位序
2
b +〈00
十一0 `
空闲
b& (rruxl?n— 1
图2．2线性表的顺序存储结构小意图
由于高级程序设计语言中的数组类型也有随机存取的特性，因此，通常都用数组来描述数据结构中的顺序存储结构。在此，由于线性表的长度可变，且所需最大存储空间随问题不同而不同，则在c语言中可用动态分配的一维数组，如下描述。线性表的动态分配顺序存储结构
*define MST INTT- SIZE 蜘0 //线性表存储空间的初始分配量
# define LISTINCREME?NT 蜘线性表存储空间的分配嗜量
typ?def社“c凵
ElemType elem； 存储空间基址 ligts(101酢)ize； 当前分配(汐'当前长度)的存储容量（以s e。f（E]-为单位）
在上述定义中，数组指针elem指示线性表的基地址．length指示线性表的当前长度。顺序表的初始化操作就是为顺序表分配一个予定义大小的数组空间，并将线性表的当前长度设为“旷（参见算法2， 3）。 “指示顺序表当前分配的存储空间大小 ， 一旦因插，人 ·
元累而空间不足小]，可进行再分配，即为顺序表增加一个大小为存储LISI'INCREMENT 个数据元素的空间。
Status Init-List Sq(SqList (L) { 构造一个空的线性表L.
L. el二（lem e )na110c(LIST- INIT- SIZE sizeof(E1emType)) i if（！L晕1 “）exit（0 RFLO； 存储分配失败 i ,，] ength 空表长度为0
L.listsize ；LEST INIT SIZE；初始存餘容 return 0&
)h" TnitLi$t- $刂
算法2，3
在这种存储结构中，容易实现线性表的某些操作，如随机存取第i个数据元素等。只是要特别注意的是，C语言中数组的下标从“ 0 ”开始，因此，若L是SqLi $ t类型的顺序表，则表中第i个数据元素是L. elem「下面重点讨论线性表的插人和删除两种操作在顺序存储表示时的实现方法“
如2口节中所述，线性表的插人操作是指在线性表的第i— l个数据元素和第7个数据元素之间插人一个新的数据元素，就是要使长度为雅的线性表变成长度为烈+ 1的线性表数据元素和之间的逻辑关系发生了变化“在线性表的顺序存储结构中，由于逻辑上相邻的数据元素在物理位置上也是相邻的，因此，除非i一烈+ 1，否则必须移动元素才能反映这个逻辑关系的变化。
序号数据 序号数据元挛 元素
擂人25 000000000 0000000
图2．3线性表插人前后的状况
〈的插人前“ -
(b)插人后一9
0 到
0000000
皿
000000
0
到
序号数据元素
图2线性表删除前后的状况
（a）删除前裎=
（b〕隊后ng- 7 例如，图2，3表示一个 在进行插人操作的前、后，其数据元素在存储空间中的位置变化。为了在线性表的第4和第5个元素之间插人一个值为25的数据元素，则需将第5个至第8个数据丿L素依次往后移动个位置。
一般情况下，在第的<这）个元素之前插人一个元素时，需将第”至第共”乛+
1)个元素向后移动一个位置，如算法2，4所示。
Statue Listlnsert- Sq(5qList &L? int ElecnT号{
／/在雕序线性表L中第i个位置之前插人新的元素e.
i的合法值为1<i<ListLength- sq(L)到
if（讠《 i > L到e四0，0 return ERROR;／' i值不合法
if（L · length 0= L．1 { //当前存储空间已满，增加分配 newbase苤(ElemType）r0a11吡〈L．，
（0后s以e + L'I$TINCREMFNP) (Eleanype))；
妊0 newbage) exit(OVERFLOW)；
／/存储分配失败
L. = newbase：
#籼基址
L. 1 Stsi `e += LISTINCREMENT;
//增加存储容量
q为橘人位置
for (p = &（疰length— 0后P《》。；q; 一p) s (p + D吓甴
周人位置及之后的元素右移
／7插人e
1 + ‰ length; return酬；
} ListLnserI- Sq
丿表长增]
算法2，4
反之，线性表的腑除操作是使长度为月的线性表变成长度为“一]的线性表
．，a 0刁，0．刁，
数据元素吓@和ar+l之间的i罗辑关系发生变化，为了在存储结构上反映这个变化，同样需要移动元素。如图2．4所示，为了删除第4个数据元素，必须将从第5个至第8个元素都依次往前移动一个位置。
一般情况下，删除第底区0 <的个元素时需将从第+ 1至第共一i)个元素依次向前移动一个位置．如算法2，5所示
Statu? ListDelete- &L? int ElemType (e) {
//在顺序线性表L中删除第i个元素，并用e返回其值 i的合法值为十《0《03 ” h sq(L)
（0 < 1） 0 > L. length)) return ERROR; // 值不合法
p为被删除兀素的位置汐被删除元素的值赋给表尾元素的位置
．被删除元素之后的元素左秭
一L. length； //表长减] return 0
，1、0一4
算法2．5
从算法2，4和2，5可见，当在顺序存储结构的线性表中某个位置上插人或删除一个数据元素时，其时间主要耗费在移动元素上（换句话说，移动元素的操作为预估算法时间复杂度的基本操作丛向移动元素的个数取决于插人或删除元素的位置。
假没是在第i个元素之前插人一个元素的概率，则在长度为的线性表中插人一个元素时所需移动元素次数的期望值（平均次数）为
（2，3）
假设q，是删除第i个元素的概率，则在长度为”的线性表中删除一个元素时所需移动元素次数的期望值（平均次数）为
（2司）
不失一般性，我们可以假定在线性表的任何位上插人或删除元素都是等概率的，即则式（2．3）和（2以）可分别简化为式（2．5）和（2．6) :
1
〉2一01一0一 2 （2一的
0
2
由式（2巧）和〈2。6）可见，在顺序存储结构的线性表中插人或删除一个数据元素，平均约移动表中一半元索。若表长为”，则算法Listlnsert Sq和ListDelete- Sq的时间复杂度为0（的。
现在我们来讨论2．1节中例》01和例2一2的操作在顺序存储结构的线性表中的实现方法和时间复杂度的分析。容易看出，顺序表的“求表长”和，取第记个数据元素的时间复杂度均为0（D．又这两个例子中进行的“插人”操作均在表尾进行，则不需要移动元素。因此，算法2．1的执行时间主要取决于查找数Lo eE [em的执行时间。在顺序表L 中查访是否存在和e相同的数据元素的最简便的方法是，令e和L中的数据元素逐个比较之，如算法2，6所示。从算法2．6中可见。基本操作是“进行两个元素之间的比较，，若 L中存在和e相同的元素，则比较次数为i(l<i<L. length)，否则为L. length'即算法 LocateElem-Sq的时间复杂度为0（匚length)。由此，对于顺序表后和Lb而言的时间复杂度为O(La. lengthxLb. length)。
玉n七LocateElem- Sq(SqList L' ElemType
Statue（compare)(E1emType.（
，7在顺序线性表L中查找第1个值与皂满足c。mpare()的元素的位序
，25 · 若找到，则返回其在L中的位序．否则返回3
// '的初值为第]个元素的位序 p 0 elem; /7 p的初值为第]个兀紊的存储位置证ile (i
if（土 L. length) retLun土 el se zeturn 0
}// I酞e “．为
算法2．6
对于“顺序表的合并”，则从算法2．2可直接写出形式上极其相似的算法2．7。显然，算法2，7中的基本操作为“元素賦值”，算法的时间复杂度为O(La. length l Lb. length)0
void MergeList- Sq(SqList，SqLi$t，L上）（ 已知序线性表和Lb的元素按值非递减排列
／／归并和Lb得到新的顺序线性表，@的元素也按值非递减排列
=，e10叼pb “ Lb.elem；
．length =，lengthT Lb.lengthi
凶。．el = (Elennypes )nalloc(rc. listeize * siz?of(ElemType))J
0 el “）“（睏）；存储分配失败
．la =，elemi，length- 1； pb-就= Lb. Lb. length-跽 while（<：pa- la就& & pb <；pb- 1a80 { 归并
h 10（闶<= pa- last) *pc++=； ／/插人的余元素 *hile ()b <苤pb- 1溆自0 pc++ = pb++； 插人陆的剩余元素 MergeList-
算法2，7
若对算法2．7中第一个循环语句的循环体作如下修改：以“开关语句”代替“条件语句”，即分出元素比较的第三种情况，当簧pa = pb时，只将两者中之一插人Lc，则该算法完成的操作和算法un n完全相同，而时间复杂度却不同。算法2．7之所以有线性的时间复杂度，其原因有二( 1 )由于La和Lb中元素依值递增（同一集合中元素不等) .则对 Lb中每个元素，不需要在La中从表头至表尾进行全程搜索）由于用新表Lc表示“并集”，则插人操作实际上是借助“复制”操作来完成的山。为得到元素依值递增（或递减）的有序表，可利用10．3节讨论的快速排序，其时间复杂度为0〔司。g的（其中”为待排序的元素个数）。由此可见，若以线性表表示集合并进行集合的各种运算，应先对表中元素进行排序
2，3线性表的链式表示和实现
从上一节的讨论中可见，线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此可以随机存取表中任．元素，它的存储位置可用一个简单、直观的公式来表示。然而，从另一方面来看，这个特点也铸成了这种存储结构的弱点：在作插人或删除操作时，需移动大量元素。本节我们将讨论线性表的另一种表示方法一一彘式存储结构，由丁它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的弱点，但同时也失去了顺序表可随机存取的优点。
2．3．]线性链表
线性表的彘式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素与其直接后继数据元素之间的谴辑关糸，对数据元素佑来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素砌的存储映像，称为结点（N。de）。它包括两个域:其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域指针域中存储的信息称做指针或链。
个结点0 < i <，D的存储映像）链结成一个縫表，即为线性表的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单
例如，图2．5所示为线性表
(ZHAO，QIAN,SUN，LI,ZHOU,WU，ZHENG，WANG)
的线性縫表存储结构，整个链表的存取必须从头指针开始进行，头指针指示彘表中第一个结点（即第一个数据元素的存储映像）的存储位置。同时，山于最后一个数据元素没有直接后继，则线性彘表中最后一个结点的指针为“空”（NULL）。
存储地址 数据城 指针壇
QIAN
13
头指针H
SUN
WANG
ZHAO
NULL
37
ZHENG
19
ZHOU
25
图2．5线性表示例
用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。换句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为非顺序映像或笛式映像。
通常我们把表画成用箭头相憐接的结点的序列，结点之间的箭头表示锖域中的指针。如图2．5的线性僻表可画成如图2．6所示的形式，这是因为在使用链表时，关心的只是它所表示的线性表中数据元素之间的逻辑顺序，而不是每个数据元素在存储器中的实际位置
H
图2，6线性链表的逻辑状态
由上述可见，单链表可由头指针惟一确定，在C语言中可用“结构指针”来描述。
一线忖表的单链表存餘结构一
上dof性u I氧记e { data;
4上ru酰Lnode
}就0d0，．
假设L是LinkList型的变量，则L为单憐表的头指针，它指向表中第一个结点。若 L为“空”（L一NULL)，则所表示的线性表为“空”表，其长度以为“零六有时，我们在单彘表的第一个结点之前附设一个结点，称之为头结点。头结点的数据域可以不存储任何信息，也可存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个结点的指针（即第一个元素结点的存储位置）。如图2．7（a）所示，此时，单链表的头指针指向头结点。若线性表为空表，则头结点的指针域为“空”，如图2，7（b）所示。图2．7带头结点的单縫表
（钔非空表：(b)空表
在线性表的顺序存储结构中，由于逻辑上相邻的两个元素在物理位置上紧邻，则每个元素的存储位置都可从线性表的起始位置计算得到。而在单表中，任何两个元素的存储位置之间没有固定的联系。然而，每个元素的存储位置都包含在其直接前驱结点的信息之中。假设p是指向线性表中第，个数据元素（结点（0：的指针，则P?>next是指向箫? + 1个数据元素〔结点00的指针。换句话说，若则t)?>ncxt?> data±±a、门。 由此，在单链表中．取得第i个数据元素必须从头指针出发寻找，因此，单链 (D结点a、指其数据域为的结点，而p结点则指指针p所指向的结点（即其存储位置存放在p中的结点）。以后均类同。
·
表是非随机存取的存储结构。下面我们看函数Ge正[ cm在单链表中的实现。
Status Cet.F,leJ11 1.（LinkLifit: L，in上i，ElemType & 0 { “' L为带头结点的单雷表的头摺针。
／7当第土个儿素存在时．其值赋给e并返回．否则返回ERROR
p过L—>next; -j 初始化，p指向第一个结点，j为汁数器
while (p & &〕(i) { ／/顺指钊向后查找，直到p指向第土个元素或p为空 p p—.>next;十十〕；
0 p卩j>i) return ERROR; /7第i个元素小存在
取第i个元素
return OK；
}// GetE1em匚
箅法2，8
算法2．8的基本操作是比较丿和并后移指针p，while循环体中的语句频度与被查元素在表中位置有关，若1《i <表长“，则频度为汾1，否则频度为幄，因此箅法2．8的时间复杂度为00D。
在单链表中 ， 又如甸实现 “插人" 和 “删 」一一「吲彐．·过 《「 ?跹」·，
除”操作呢？
假设我们要在线性表的两个数据元素
和b之间插人一个数据元素x，己知p为其
图2，8在单彘表中仙人结点时指针变化状况
单表存鍺结构中指向结点a的指针。如
(a)插人；（插人后
图2，8（a）所示。
为插人数据元素x，首先要生成一个数据域为x的结点，然后插人在单链表中。根据插人操作的逻辑定义，还需要修改结点a中的指针域，令其指向结点x，而结点x中的指针域应指向结点b从而实现二个兀素a，b和x之间逻辑关系的变化。插人后的单链表如图2，8伟）所示。假设s为指向结点x的指针，则上述指针修改用语句描述即为《
S一> next ” p一> next ; P —> next
反之，如图2，9所示在线性表中删除元素b时，为在单链表中实现元素a、b和c之间 P 逻辑关系的变化．仅需修改结点a中的指针域即 可。假设p为指向结点a的指针．则修改指针的语句为
图2．9在单縫表中删除结点时指针 P next ·，冫next —> next；
变化状况 可见，在己知链表中兀素插人或删除的确切位置的情况下，在单链表中插人或删除一个结点时，仅需修改指针而不需要移动元素。算法
2．9和箅法2．10分别为Listlnsert和LlstDelete在单菹表中的实现。
Status L（L'羡乙七玉n e) {
在带头结点的单链线性表L中第个位置之前插人元素e
P
while（p & <上一l )住+十〕；}寻找第]，一1个结点
· 29 · （！p日j >一l) return ERROR;
／/ i小于]或者大于表长
(LinkLi$t) ?alloc（sizeof；
生成新结点
$一》da上e; 自一二、
汐插人L中
*next = S;
return 0下；
}// Linstlnsert L
算法2，9
Listnelete- LCLinkLi3t &巛&的{
在带头结点的单链线性表L中，删除第i个元素，并由e返回其值
“h 1晦(p >next & & i < i）（寻找第土个结点，并令p指向其前趋 p = p一>吣仁；
if（！(p?next) j冫、0 return
R；#删除位置不合理
q = p?>、next；p?next q一冫、ne
e = free(q)；
return 0
)// ListDe1ete．L
胤除并释放结点
算法2，脚
容易看出，算法2．9和算法2，10的时回复杂度均为0（的。这是因为，为在下个结点之前插人一个新结点或删除第个结点，都必须首先找到第一1个结点，即需修改指针的结点，从算法2．8的讨论中，我们已经得知，它的时间复杂度为00D。
在算法2．9和2，10中，我们还分别引用了C语言中的两个标准函数malloc和
通常，在设有“指针”数据类型的高级语言中均存在与其相应的过程或函数。假设p和q 是LinkLiSt型的变量，则执行（凵nkL巧t)咀〈eof（LN。de））的作用是由系统生成一个LNode型的结点，同时将该结点的起始位置赋给指针变量p；反之，执行f№（q）的作用是由系统回收一个["Node型的结点，回收后的空间可以备作再次生成结点时用。因此，单表和顺序存储结构不同，它是一种动态结构。整个可用存储空间可为多个表共同享用，每个链表占用的空间不需预先分配划定，而是可以由系统应需求即时生成。因此，建立线性表的式存储结构的过程就是一个动态生成链表的过程。即从“空表"的初始状态起，依次建立各元素结点，并逐个插人链表算法2，11是一个从表尾到表头逆向建立单链表的算法，其时间复杂度为00D。
voidCreateLi3t L(LinkList, L，氢酰n)〈
逆位序输人n个元素的值，建立带表头结点的单链线性表L。
L kL凹Il仳(sizeof（瞓的）；
一> next一NULL 先建立一个带头结点的单链表
or（上= ni >山
P (LinkList) (sizeof (LNode))i 生成新结点
scanf( bp 到冫?data)； 输人元素值 L 0、?next//插人到表头
》／/ CreateList- L
算法 2，11
下面讨论如何将两个有序链表并为一个有序链表？
假设头指针为La和Lb的单链表分别为线性表LA和LB的存储结构，现要归并和Lb得到单链表Lc，按照2．1节中算法Me咪eL的思想，需设立3个指针pa、pb和 pc，其中pa和pb分别指向La表和] b表中当前待比较插人的结点，面pc指向Lc表中当前最后一个结点，若pa—>data<pb—>data，则将pa所指结点链接到pc所指结点之后，否则将pb所指结点链接到pc所指结点之后。显然，指针的初始状态为：当LA和LB为非空表时，pa和pb分别指向La和Lb表中第一个结点，否则为空；pc指向空表Lc中的头结点。由于链表的长度为隐含的，则第一个循环执行的条件是pa和pb皆非空，当其中一个为空时，说明有一个表的元素已归并完，则只要将另一个表的剩余段链接在四所指结点之后即可。由此得到归并两个单链表的算法，如算法2．12所示。
void MergeLi9t．〔（Li纛L上&，LinkLiEt &山，Li-nkL3名上&@〉{
己知单链线性表和Lb的元素按值非递减排列有
汐归并和得到新的单链线性表，的元素也按值非递减排列。
=妇 0 Pb Lb ?j>next:；
方用的头结点作为的头结点
*hilt (pa b& pb) { 辽（、0山<冲一0而t《a）{
凶 next pa;匹。；pa距pa?>next;
01 {凶．．> next
匹*next地 另/插人剩余段 free(t.b)l //释放陆的头结点
}汐MergeLigt- L
嘛法2」2
读者容易看出，算法2，12的时间复杂度和算法2，7相同，但空间复杂度不同。在归并两个链表为一个链表时，不需要另建新表的结点空间，而只需将原来两个链表中结点之间的关系解除，重新按元素值非递减的关系将所有结点链接成一个链表砷可。
有时，也可借用一维数组来描述线性链表，其类型说明，如下所示：
一线性表的静态单表存储结构
# d甙- MAXSLZB 1 0链表的最人长度
typedef struct〈
Elemmype妇t
Curi
，component，SLinkLiStCMAXSIZEl;
这种描述方法便于在不设“指针”类型的高级程序设计语言中使用链表结构。在如上描述的链表中，数组的．．个分量表示一个结点，同时用游标（指示器“ r）代替指针指示结点在数组中的相对位置。数组的第零分量可看成头结点，其指针域指示链表的第一个结点例如图2．]叭a〕中所示为和图2，5相同的线性表。这种存储结构仍需要预先分配一个较大的空间，但在作线性表的插人和删除操作时不需移动元素，仅需修改指针，故仍具有链式存储结构的主要优点。例如，图乙10（b）展示了图2．〕（a）所示线性表在插人数据元素 “ s用”和删除数据元素“ ZH NG ”之后的状况。为了和指针型描述的线樽表相区别，我们给这种用数组描述的链表起名叫静态表。
0
河
0
訓
000
河
00
图2．静态表示例
（的修改前的状态以b）修改后的状态
假设s为SLjnkList型变量，则乩明．“ r指示第一个结点在数组中的位置，若设《一 SCO-1.cur,)IFI s@．data存储线性表的第一个数据元素，且S田．cur指示第二个结点在数组中的位置，一般情况，若第个分量表示链表的第差个结点，则S〔i:. cur指示第]个结点的位置。因此在静态链表中实现线性表的操作和动态表相似，以整型游标代替动态指针p. cur的操作实为指针后移（类似于p一p > next），例如，在静态表中实现的定位函数LocateElem如算法2．13所示。
ca怔．SL( L t头e) {
／/在静态单线性表L中查找第1个值为e的元素“ 若找到，则返回它在L中的位序，古则返回
// i指示表中第一个结点
//在表中顺链查找
return 1：
} at 1 SL
算法2彐3
类似地可写出在静态表中实现插人和删除操作的算法。从图2．] 0的例了可见，指针修改的操作和前曲描述的羊链表中的插人和删除的算法2、荪2．10类似，所不同的是，需由用户自己实现m肅和free这两个函数。为了辨明数组中哪些分未被使用，解决的办法是将所有未被使用过以及被删除的分量用游标链成一个备用的链表，每当进行人时便可从备用链表上取得第一个结点作为待插人的新结点反之，在删除时将从镊表中删除下来的结点链接到备用表」一。
现以集合运算（A一步U（B一A）为例来词论静态表的算法。
例2刁假以山终端人集合元素，先建立表示集合A的静态苗表S，而后在输人集合B的元素的同时查找s表，若存在和B相同的元素，则从S表中删除之，否则将此元素插人S表。
为使算法清晰起见，我们先给出3个过程：l )将整个数组空间初始化成一个表；2）从备用空间取得一个结点）将空闲结点琏结到备用链表上，分别如算法2，14，2．巧和 2．1 6所示。
void InitSpace一SL( & space) {
将一维数组space中各分量链成一个备用表，“明．〔为头指针．eor @ 0；i <("表示空指针)MAXSIZE— l i ++ i) space〔瑟十吓 spacefM?XSIZE ·刂．以辽，0；
}//让斗ace．SL
法2以
int柯一（GLinkiui5h &阢划：的{
若备用空间表非空，则回分配的结点下标．舌则返回0 i $ pac矸0〕、
（№0[月．0u0 spacec刂．cur； return辑
}阳11的．就
算法2，15
void Free- SL(SLinkLigt & 8 ce．int k) {
//将下标为k的空闲结点回收到备用链表
space(kj.cur：spacer01, cut；：
》Free-，
算法2．
void difference( SL土蘸瞓& space，{
//依次输人集合A和B的元素，在一维数组ce中建立表示隼合（A一B）山B．．A）丿/的静态链表，s为其头指针、假设备用空间足够大描@“I明还“为其头指到。InitSpace- SL(space);
Ha1100．SL(gpaee)：
scanf()' n)： for ( j
Mal 10C SL( space)i scanf（spacec i」，data）；
//始化备用空间生成s的头结点
指向s的当前最后结巛汐输人A和B的元素个数建立集合的链表分配结点
//输人A的元素值
，33 ·
$pacecro.cu-r=；r = i ; 趵0。r space[rj、cur = 0； for ( j ／/插人到表尾
#尾结点的指针为空
//依次输人B的元素，若不在当前表中，则插人，否则才/删除scanf(b) ; p space(S).cur；汐' k指向集合中第一个结点疝过e (k卜spaceCrl.cur & & sp到，豳ta b) {才在当前表中查找
；spac过k丰0辽；
)Iwhile if (k space(rJ, 0u0 { 汐'当前表中不存在该元素，插人在r所指结点之后，且r 才的位置不变
“阿411区一$L（酆划ce后再仁矸、data = b； s呻0跹i〕-cur = 臼@ce〔，0吖生
el $ { 该元素己在表中，删除之 Cur = space[k_]，cu Free- SL(3pacet k)!
若删除的是r所指结点，则需修改尾指针
)//eJse
V/for
》difference
箅法207
在算法2口7中，只有一个处于双重循环中的循环体（在集合A中查找依次输人的 0，其最大循环次数为：外循环n次，内循环次，故算法2，17的时间复杂度为 a（0 Il) space(0 11）
6
S -0过0000 S 过恶0@g0000
迎
到
河(000) 也
也 过到
-河 0
图2口1 运算前的静态韃表
（表示的表Si (b)表示（4一U（B一的表5
图2，凵是算法2，17执行的示意图。假设集合A一，e，g，不的，b一五f)，则图2口]（的所示为输人集合A的元素之后建成的表S和备用空间链表的状况，图 2．Il（b）所示为个输入集合B的元素并在表S中依次插人删除插入、删除丿、后的状况。spaceC0]. cur为备用表的头指针“的值为六
2，3，2循环链表
循环链表（C以司“ Linked List)是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个皚表形成一个环。由此，从表中任一结点出发均可找到表中其他结点，如图2、12所示为单的循环链表。类似地，还可以有多重的循环彘表。图2，12单循环链表
（非空表，(b)空
循环表的操作和线性縫表基本一致，差别仅在于算法中的循环条件不是p或 p一 ， > next是否为空，而是它们是否等于头
指针。但有的时候，若在循环彘表中设立尾A 指针而不设头指针（如图2．13（a）所示），可
B
使某些操作简化。例如将两个线性表合并
成一个表时，仅需将一个表的表尾和另一个
(a)
表的表头和接。当线性表以图2．13（a）的
循环表作存储结构时，这个操作仅需改变A 两个指针值即可，运算时间为0（1）。合并
后的表如图2，13（b）所示。 (b)
2．3，3双向链表 图2．13仅设尾指针的循环链表
（的两个缸表（合并后的表
以上讨论的链式存储结构的结点中只
有一个指示直接后继的指针域，由此，从某个结点出发只能顺指针往后寻查其他结点。若要寻查结点的直接前趋，则需从表头指针出发。换句话说．在单链表中，NextElem的执行时间为0〈D，而prior em的执行时间为00D。为克服单链表这种单向性的缺点，可利用双向链表（D“ ble Linked List)。
顾名思义，在双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前趋，在C语言中可描述如下：
．线性表的双向链表存储结构
typedef I e {
struct(ElemType)还e pri(data；)or；
· 35，
struct 0 ode next；
}DuLNode,山kLi5t;
和单链的循环表类似，双向餷表也可以有循环表，如图2．14（的所示，表中存有两个环，图2．14（所示为只有一个表头结点的空表。在双向链表中，若d为指向表中某一
prior elcmcnt
L
图2．凵双向表示例
（的结点结构；（空的艰向循环表：（非空的双向循环表
结点的指针（即：d为Dul?inkList型变量），则显然有
d prior — d一〕> prior一，一〕> next 这个表示式恰当地反映了这种结构的特性。
在双向链表中，有些操作如；ListLcngth、GetElem和LocateEjern等仅需涉及一个方向的指针，则它们的算法描述和线性每表的操作相同，但在插人、删除时有很大的不同，在双向链表中需同时修改两个方向上的指针，图2，15和图2．16分别显示了删除和插人结点时褙针改的情况。它们的算法分别如算法209和208所示，两者的时间复杂度均为0〈” )a图2．15在双向彘表中删除结点时指针变化状况
图2，[ 6在双向链表中插人一个结点时指的变化状况
Status Li$E1nsert- DuL(DuLinkLiSt L，玉社i' Elemmype e) {
在带头结点的双链循环线性表[中第i个位置之前插人元素e，另0的合法值为} < i <表长0。
旺0（p GetFtenP DuL(L、的才在L中确定第个元素的位冒指针p rekurn ERROR； p:NULL'即第个元素不存在珏0 (s。return球RO g->data e;
一》、prior P一0p0．．：V?>prior =粼
p—>priot =
return 0和
} /7 ListinseEt- DuL
算法2．18
Status ListDe1ete- DuL(DuLinkList. &L. int i . ElemType (e) {
//删除带头结点的双链循环线性表L的第i个元素，i的合法值为！i《表长
0 (p = n吡0 “ 0）在L中确定第i个元素的位置指针p return 0诹 p?NULL，即第个元素不存在
e敷p—>data;free()>；return 0K；
)// ListDelete. DuL
算法2，19
从本（2．3）的时论中可见，由于链表在空间的合理利用上和插人、删除时不需要移动等的优点，因此在很多场合下，它是线性表的首选存储结构。然而，寫也存在着实现某些基本操作如求线性表的长度时不如顺序存储结构的缺点；另方面，由于在链表中，结点之间的关系用指针来表示，则数据元素在线性表中的“位序”的概念已淡化，而被数据元素在线性链表中的“位置”所代替。为此，从实际应用角度出发重新定义线性链表及其基本操作、
一个带头结点的线性表类型定义如下
d以?Eruct t№de 02结点类型 ElemType 山t山
gtxuct LNode 冥next;
》Link,騖PO $ it土0山
typ?def struct { #縫表类型
Link head，Ea到； 分别指向线性表中的头结点和最后一个结点 int 指示线性链表中数倨元素的个数 } LinkLi5ti
Statua MakeNode( Link &p，ElemType 0月
／/分配由p指向的值为e的结点，并返回0若分配失败，则返回ERROR void FreeNode( Link &p）：汐释放p所指结点
社u InitList( LinkLigt &L
另/构造一个空的线性链表L
S上DestroyLigt( LinkLi9t）；
／7硝毁线性表L，L不再存在骁酢un ClearLigt( LinkLis上&?L月
/7将线性縫表L重置为空表，并释放原链表的点空间巨旧InsFirst( Ll.nk h. Link s）；
／7己知h指向线性縫表的头结点，将所指结点插人在第一个结点之前 Status IF r（L h? L ”丧&q）；
已知h指向线性链表的头结点．删除表中的第一个结点并以g返回 Status Append（LinkList &〔，L土s ) :
将指针s所指（彼此以指针相链）的一串结点链接在线性表L的最后一个结点//之后，并改变锖表L的尾指针向新的尾结点
Status Remove（LinkLi.91: & 0 Link）； 删除线性链表L中的尾结点并以q返回，改变表的尾指针指向新的尾结点然乞u InsBefore（LinkList L. Link &?p? Link s
//已知p指向线性表L中的一个结点，将s所指结点插人在所指结点之前，
Stat／/sAfter（LinkList &?L? Link us &(并修改指们p指向新插人的结巛In)?p，L虫5 已知p指向线性链表L中的个结点，将s所指结点人在p所指结点之后， 并修改指针p指向新插人的结点
Status SetCurEle1t1（Link &?p，冂e) ; 己知p指向线性表中的一个结点，用e更新p所指结点中数据元素的值心0能T、@ GetCurE1?n（Li P）；汐已知p指向线性表中的一个结点，返回p所指结点中数据元素的值
Statue ListE?mpty（LinkList匚）；汐'若线性表L为空表，则返回，否则返回FALSE int Lietlength(匚L L 另/返回线性链表L中元素个数
00王on GetHead（LinkList: L肩 #返回线性锖表中头结点的位冒
Pog?tion Get[ngt（LinkList L）； 返回线性彘表〔中最后一个结点的位置
Position PriorPO$( LinkLi$t L ' Link P）； 已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置， 若无前驱，则返回NO就
Position（蘸?的；
／／己知p指向线性表L中的一个结点，返回p所指结点的直接后继的位置， 若无后，则返回
Status（L，int: Link & P）
//返回P指示线性表L中第个结点的位置并返回0K，i值小合法时返回ERROR
Pos玉001 IRjcateE1etn (LinkLisC ‰ F'leJtlType e，status（铎com@re）（E10n1、e，
//返回线性链表中第1个与e满足函数c“ “ 0判定关系元系的位置，
／／若不存在这样的元素，则返回NULL
Status ListTraverse(LinkList，statuR（蕢visit)()后
，7依次对L的每个元素调用函数到s巛一过vi ?t()失败，则操作失败。
在上述定义的线性表的基本操作中，除了DestroyList' Clear1 ist ' Remove? fore,PriorPos,LocatePos,LocateElem和[ istTraverse的时间复杂度和表长成正比之外，其他操作的时间复杂度都和表长无关，Append操作的时间复杂度则和插人的结点数成正比。利用这些基本操作，容易实现诸如在第i个元素之前插人元素或麒除第，个元素或合并两个线忭表等操作，如算法2，20和2，21所示。
Status LisEInsert- LCLinkLigt，ElemType e) {
，夕在带头结点的单线性表L的第支个元素之前插人元素。
（！[acat os ()' i? l ' h)) returnERROR;考' 1值不合法
（！Make-Node（到）return ERROR' 结点存储分配失败
InsFirst (), s) i／/对于从第i个结点开始的链表，第一I个结点是它的头结点
0；
，
}／7 Listlnsert- L
算法2．20
StatuB MergeList L(LinkList &.La. L山土亡Lb, L L st &
int（苦CO re)( lemT皂上1月
／7已知单线表和Lb的元素按值非递减排列。
“归并和Lb得到新的单链线性表〔。的元素也按值非递减悱列。
if 0 InitLi$t(IK:)) re上盯n ERROR; 存储空间分配失败
ha ”（“）；陆“ GetHead (14b)；／／和h.b分别指向和陆的头结点
一NextPos（山，№月pb “ NextPos ()b，(b); // pa和pb分别指向和Lb中当前结
"hile (pa&&pb) { 和就均非空
a = GetCurE1em (pa); b = GetCurE1em (pb)5，和b为两表中当前比较元素 if（（c“ re），b冫<；的〈a<b
DeLFLrst ()a，q) ; Append ()c，q)；pa elee {
NextPOS（，pa〕；
Dell?irst ()b，q)；Append（，q）；pb }/?漏le
NextP0fi ()b，(b)；
//滸接中剩余结点
01哋Append (Lc.pb)；
接Lb中剩余结点
FreeNode（后 FreeNOde ()b后
释放和的头结点
} MergeLi8t- L
算法2．21
算法2．20和算法2．2 ]分别为算法2．9和算法2．12的改写形式，它们的时间复杂度和前面讨论和同。
2，4一元多项式的表示及相加
符号多项式的操作，已经成为表处理的典型用例、在数学吓一个一元多项式丛00 可按升幂写成：它山” + 1个系数惟一确定。因此，在计算机里，它可用一个线性表P来表示每．，项的指数i隐含在其系数的序号里
假设0．（到是一元m次多项式，同样可用线性表Q来表示不失一般性，设忉<则两个多项式相加的结果&（一玖陆）+ 0，，(x）可用线性表 R表示：显然，我们可以对p、Q和R采用顺序存储结构，使得多项式相加的算法定义十分
洁。至此，一元多项式的表示及相加问题似乎已经解决了。然而，在通常的应用中，多项
· 39
式的次数可能很高且变化很大，使得顺序存储结构的最大长度很难确定。特别是在处理形如1首3 + 2m
的多项式时，就要用一长度为20 00 1的线性表来表示，表中仅有3个非零元素，这种对内存空间的浪费是应当擗免的，但是如果只存储非零系数项则显然必须同时存储相应的指数。
般情况下的一元”次多项式可写成
P脲．0一产一]狲的3十一+产‰ 其中泓是指数为0的项的非零系数，且满足
0
若用一个长度为加且每个元素有两个数据项〈系数项和指数项）的线性表
（2一8）便可惟一确定多项式P，：0）。在最坏情况下，裎+ 10；m）个系数都不为零，则比只存储每项系数的方案要多存储一倍的数据。但是，对于S（到类的多项式，这种表示将大人节省空间
对应于线性表的两种存储结构，由式（2．8）定义的一元多项式也可以有两种存储表示方法。在实际的应用程序中取用哪一种，则要视多项式作何种运算而定。若只对多项式进行“求值"等不改变多项式的系数和指数的运算，则采用类似于顺序表的顺序存储结构即可，否则应采用鲢式存储表示。本节中将主要讨论如何利用线性链表的基本操作来实现一元多项式的运算。
抽象数据类型一元多项式的定义如下：
P01 al {
数对象：D “ {ml〔TerrnSet，i。1，2， ?m，m 0
Ternset中的每个元素包含一个表示系数的实数和表示指数的数}
数据关系到< a“以>。a D．且a宀中的指数值<鉭中的指数值，性2，基本操作
Creatpolyn（&p.们〕
操作结果：输人项的系数和指数，建立一元多项式P。Destroypolyn（）
初始条件：一元多项式P己存在。
操作结果毁一元多项式數
PriXLtPOLyn（P）初始条件：一元多项式p己存在，澡作结果：打印输出一元多项式以
№1 Le凶1：h（P）初始条件：一元多项式p己存在。
操作结果：返回一元多项式P中的项数 Ad。1（&pa &Pb）初始条件．一元多项式和卟已存在操作结果：完成多项式相加运算．即：Pa
S社tr“匕P01（，&Pb）十Pb，并销毁一元多项式PE。初始条付：一元多项式pa和Pb已存在、
操作结果：完成多项式相减运算，即：；一，并销毁 ．元多项式PO《
MulriplyPol?fi（&Pb）初始条件：一几多项式腩和(I)己存在
操作结果:完成多项式相乘运算．即*Pa pa × Pb，并销毁元多项式p } Am Polyno玉1
实现上述定义的一元多项式，显然应采用链式存储结构。例如，图2口7中的两个线性链表分别表示一元多项式Ali（到一7卜缸十9十5x。和一元多项式（到一
22 一9。从图中可见，每个结点表示多项式中的一项。
A B
0
图207多项式表的单链存储结构
如何实现用这种线性表表示的多相式的加法运算？
根据。元多项式相加的运箅规贝对十两个一元多项式中所有指数相同的项，对应系数相加，若其和不为零，则构成“和多项式”中的一项，对于两个一元多项式中所有指数不相同的项，则分别复抄到“和多项式”中去。
在此，按照t述抽象数据类型p鳴n-中基本操作的定义，“和多项式”縫表中的结点无需另生成，而应该从两个多项式的链表中摘取。其运算规则如．的假设指针qa和分别指向多项式，A和多项式l*中当前进行比较的某个结点，则比较两个结点中的指数项，有下列3种情况：0指针所指结点的指数值《指针qb所指结点的指数值，则应摘取咿指针所指结点插人到“和多项式'岩表中去；的指针qa所指结点的指数值>指针 qb所指结点的指数值．则应摘取指针qb所指结点插人到“和多项式”鲢表中去；3）指钅i qa 所指结点的指数值：指针qb所指结点的指数值，则将两个结点中的系数相加，若和数不为零，则修改咿所指结点的系数值，同时释放所指结点；反之，从多项式A的鲢表中删除相应结点，并释放指针qa和qb所指结点。例如，由图2．17中的两个链表表示的多项式相加得到的“和多项式”钅连表如图2．18所示．图中的长方框表示已被释放的结点。
C
0
=匚二
图2．18相加得到的和多项式
上述多项式的相加过程和上一节讨论的归并两个有序表的过程极其类似，不同之处仅在于，后者在比较数据元素时只出现两种情况。因此，多项式相加的过程亦完全可以利用线性链表的基本操作来完成
需要附加说明的是．在2．3节末定义的线性链表类型适用于一般的线性表，而表小
元多项式的应该是有序链表。有序链表的基本操作定义与线性彘表有两处不同，一是上。cateEIern的职能不同，二是需增加按有序关系进行插人的操作Ord “ Il艹山现说明如下：
atug LocateElem (LinkList L，ElemType e? Position q， int《希Compare)(F,QernType, ClemType))i 汐若序链表L中存在与《满足判定数c“pa“ 0取值为0的元素，则g指示L中第一个／/值为e的结点的位置，并返回TR匪否则q指示第一个与e满足判定函数comp eo取
//瘡> 0的元东的前的位置，并返回FALSE
3 Orderlnsert〈LinkLi$t &?L，e，int（．compare)(Eleml.ype，； 按有判定函数鲡呷a“0的约定，将值为e的结点腼人到有序链表L的适当位置上例2．4抽象数据类型Polynomial的实现。
typed?f社0。凵项的表示，多项式的项作为虫Li的数据元素 f100t coef； 汐系数 iot 指欷
Elemrype;考'两个类型名：term用于车ADT'E1emType为LinkList的数据对象名
typedef LinkLi5t、旧1； 用带表头结点的有序表表示多式
一基本操作的函数原型说明 void Creatpolyn（0 il &p，玉n上m 输人m项的系数和指数．建立表示一元多项式的有序链表P void Degtroypolyn（PO巧noma过 /／销毁一元多项式P void PrintPolyn（1 P 打印输出一元多项式p 吡而1 Leng上polynomail P兵 返回一元多项式p中的项数
0玉d AddP01yn（polynomail，polynomail）； 完成多项式相加运算．即a = + Pb，并綃毁一元多项式pb void $ tr №0刂n（polynomaii）； 完成多项式相减运算，即：妇瑟一Pb，并销毁一元多项式鼕0 Mul上01（p01 Ott溆&?Pb）； 完成多项式相乘诬，即：pa一× 12b，并销毁一元多项式Pb
一基本操作的算法描述（部分〕 int emp（term b）； z/依a的指数值<（或：或>）b的指数值，分别返回一1、0和] 1
void Cr 0 n（polynomail up? int血）{ 刀'输人m项的系数和指数，建立表示一兀多项式的有序链表P In址L上（； h亡Get.Head (P) ;
e.coef = 0 0； ．后set.curE1etu ()' e) ;设置头结点的数据元素 for（0 1；00：m；“ 0 { #依次人m个非零项 scanf（e江09六色0 n）；
(!LocateElem（p. e. q' ( " ClüP)())）{丿7当前链表中不存在该指数项
?? (MakeNode（e趵 st〈q, s月丿/生成结点并插人链表} //' Creatpolyn
2. 22
void AddPolyn ( polynomial & pa, polynovrual &Pb) { // switch ) // while if ( ! Li6tFnpLv ) Append (Pa, qb) // Bit FreeNOde ( hh) : // Pb NJ
) // nddP01yn第3章栈和队列
栈和队列是两种重要的线肚结构。从数据结构角度看，找和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为定性的数据结构。但从数据类型角度看，它们是和线性表大不相同的两类重要的抽象数据类型。山于它们广泛应用在各种软件系统中，因此在面向对象的程序没计中，它们是多型数据类型。本章除了讨论栈和队列的定义、表示方法和实现外，还将给出一些应用
3 · 1栈
3、1.1柚象数据类型栈的定义
栈( Stack)是限定仅在表尾进行插人或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为栈顶（蜘p），相应地，表头端称为栈底（bottom）。不含元素的空表称为空栈。
假漫栈S一（山“。，“，(n)，则称山为栈底元素，为栈顶元素、栈中元素按at , “．以的次序进栈，退栈的第一个元素应为栈顶元素。换句话说，栈的修改是按后进先出的原则进行的（如图30（a）所示）。因此，栈又称为后进先出（La In Fi～Out）的线性表（简称LIFO结构），它的这个特点可用图3．1（h）所示的铁路调度站形象地表示。
出栈 进栈
栈底
出栈 进栈
图3、]栈
（栈的示意襨：〔用铁路调度站表示栈
栈的基本操作除了在栈顶进行插人或删除外，还有栈的初始化、判空及取栈顶儿素等 下面给出栈的抽象数据类型的定义
ADT Stack {
据对象：Dz；0，《?Elec诩，i，2．
数据关系：RI一 山到．a, 0 D'玉。六
约定端为栈顶，a端为栈底
基本操作：
InitStack(&S)
臊作结果：构造一个空栈
DestroyStack(&S) 初始条件：伐s己存在。
操作结果：$被销毁。初始条件栈$己存在。
操作结果；将$清为空栈。
StackEmptY(
初始条件：找s已存在。
臊作结果：若栈s为空栈，则返回TR皿，古则F肚s StackLength(
初始条件：找s己存在。
作结果：返回的元个数，即栈的长度。
GetTop(), be)
初始条件戩$己存在且非空。
操作结果：用。返回$的找顶元素 Pueh(&S. e)
初始条件：找5已存在，
作结果：插人元水e为新的栈顶元。
Pop(&5. &的
初始条件！栈s已存在且非空。
操作结果：删除s的栈顶兀素，并用e返回其值。
StackTraverse($.vi$it()) 初始条件：栈s已存在且非空。
作结果：从找底到栈顶次对3的每个数据元寡调用函数（一旦v 0失败，则臊作失效。
Stack
本书在以后各章中引用的栈大多为如上定义的数据类型，栈的数据元素类型在应用程序内定义，并称插人元素的操作为人栈，删除栈顶元素的操作为出栈。
3，1. 2栈的表示和实现
和线性表类似，栈也有两种存储表示方法。
顺序栈，即栈的顺序存储结构是，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针怖p指示栈顶元素在顺序栈中的位置。通常的习惯做法是以top一0表示空栈，鉴于〔'语言中数组的下标约定从0开始，则当以C作描述语言时，如此设定会带来很大不便；另一方面，由于栈在使用过程中所需最大空间的大小很难估计，因此，一般来说，在初始化设空栈时不应限定栈的最大容量。一个较合理的做法是：先为栈分配．个基车容量，然后在应用过程中，当栈的空间不够使用时再逐段扩大；为此，可设定两个常量：SLACK-INIT- s ] ZE（存储空间初始分配量）和STACKINCREMENT （存储空间分配增量）．并以下述类型说明作为顺序栈的定义。
ypedef {
SEIemType粼base;
SEIemType
} SqStack；
其中，st巛椿ize指示栈的当前可使用的最大容量。找的初始化操作为：按设定的初始分配进行第一次存储分配，艹可称为栈底指针，在顺序栈中，它始终指向栈底的位置，若 base的值为NULL，则表明栈结构不存在。称top为栈顶指针，其初值指向栈底，即top= base可作为栈空的标记，每当插人新的栈顶元素时，指针t。p增0删除找顶元素时，指针 top喊1，因此，非空栈中的栈顶指针始终在找顶元素的下一个位置上。图3，2展示了顺序栈中数据元素和栈顶指针之间的对应关系。 图3，2栈顶指针和栈中元素之间的关系以下是顺序栈的模块说明。
／7 '乛艹為的k的表示与实现
一栈的序存储表示、
*define STACK INIT- f; 100；存储空间初始分配最 define STACKINCREMF.NI' 1 0；存储空间分配增量丑吡衄酰{
SEIemType b“ //在栈构造之前和销毁之后、b e的值为厩
SEIemTvpe上op； ／7栈顶指针
当前已分配的存间，以元素为单位 )sqstack;
．基本操作的函数原型说明 S us InitStac:k（$ 汐构造一个空栈s
Status (Sqstack 销毁栈s不冉存在 Status ClearStack (Sqstack
／7把s置为空栈
Status StackEmpty（Sqstack；
#若栈5为空栈，则回睏，省则返回FALSE
int Stack.l?eogth (SqStack S) ;
ERROR
Status Pop (SqStack &.S, SEIernType be) ;INIT- SIZE if ( ! S, base) exit (OVERFLOB) ; // fi-fih4}Nd4Uf S, top S. base;
S, stacksize = STACK- INIT ret.utn OK ; ) // InitSLackreturn OK i
// GetTop
next
} //
Status Pop (
// Pop
? 47 ?
栈的链式表示链栈如图3，3所示。由于栈的操作是线性表操作的特例、则链栈的操作易于实现．在此不作详细讨论。
栈的应用举例
由于栈结构具有的后进先出的特性，致使栈成为程序设计中的有用上具。本兯将讨论几个栈应用的典型例一0
3．2以数制转换
十进制数N和其他进制数的转换是计算机实现计算的基本问题，其解决方法很
多，其中一个間单算法基于卜列原理：
N=(N divd)><d+Nmdd (其中：d这，为整除运算，m。d为求余运算）例如：0318琮一（25国）8，其运算过程如下：
N
N div 8
N mod 8
13/1卜
168
1
] 68
0
2
5
2
0
2
假设现要编制一个满足下列要求的程序：对于输人的任意一个非负十进制整数，打印输出与其等值的八进制数。山于上述计算过程是从低位到高位顺序产生八进制数的各个数位，而打印输出，一般来说应从高位到低位进行，恰好和计算过程相反。因此，若将计算过程中得到的八进制数的各位顺序进栈，则按出栈序列打印输出的即为与输人对应的八进制数
VO conversion 0 {
对于偷人的任意一个非负十进制整数，打印愉出与其等值的八进制数
IniEStack(S)： //构造空栈 scant（" d"．N)；
While (N)《
Push(), N 8）； N
while 0就k酢y（的）{
Pop(S?e)i
printf（" d". e）；
}／纟conversion
算法3 1
这是利用栈的后进先出持性的最简羊的例子。在这个例子中，栈操作的序列是直线
式的，即先一味地人栈．然后一味地出栈。也许．有的读者会提出疑问：用数组直接实现不也很单吗？仔细分析上述算法不难看出，栈的引人简化了程序设计的问题，划分了不同的关注层次，使思考范围缩小了。而用数组不仅掩盖了问题的本质，还要分散精力去考虑数组下标增减等细节问题
3，2．2括号匹配的检验
假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序随意，即( l过0）或以[0] 0]月等为止确的格式，〔Q)或00）或（（月）均为不止确的格式。检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述。例如考虑下列括号序列：
吓0 0
1 2 3嶁5 6 7 8
当计算机接受了第一个括号后．它期待着与其匹配的第八个括号的出现，然而等来的却是第一个括号，此时第一个括号“ [ ”只能暂时靠边，而迫切等待与第二个括号相匹配的、第个括号“）"的出现，类似地，因等来的是第三个括号“「”，其期待匹配的程度较第二个括号更急迫，则第0个括号也只能靠边，让位于第三个括号，显然第二个扌叾号的期待急迫性高于第一个括号；在接受了第四个括号之后，第三个括号的期待得到满足，消解之后，第个括号的期待匹配就成为当前最急迫的任务了，， ，，，依次类推。可见，这个处理过程恰与栈的特点相吻合。由此，在算法中设置一个栈，每读人一个括号，若是右括号，则或者使置于栈顶的最急迫的期待得以消解，或者是不合法的情况；若是去括号，则作为一个新的更急迫的期待压人栈中，自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。
另外，在算法的开始和结束时，栈都应该是空的。此算法将留给读者作为习题完成。
3．2．3行编辑程序
一个简单的行编辑程序的功能是：接受用户从终端输人的程序或数据，并存人用户的数据区。由于用户在终端上进行输人时，小能保证不出差错，因此，若在编辑程序中，“每接受一个字符即存人用户数据区"的做法显然不是最恰当的。较好的做法是，设立一个输人缓冲区，用以接受用户输人的一行字符，然后逐行存人用户数据区。允许用户输人出差错，并在发现有误时可以及时更正。例如，当用户发现刚刚键人的一个字符是错的时，可补进一个退格符“ # ”，以表示前一个字符无效；如果发现当前键人的行内差错较多或难以补救，则可以键人一个退行符“@”，以表示当前行中的字符均无效 例如，假设从终端接受了这样两行字符： outcha@putchar( s* # + +）；则实际有效的是下列两行：
le（动
putchar(诗s4+
为此，可设这个输人缓冲区为一个栈结构，每当从终端接受了一个字符之后先作如下
判别：如果它既不是格符也不是退行符，则将该字符压人栈顶；如果是一个退格符，则从栈顶删去一个字符；如果它是、个退行符，则将字符栈清为空栈。十述处理过程可用算法
3．2描述之。
void LineEdit(冫{
／/利用字符找s，从终端接收一行并送至调用过程的数据区。
InrtStack(S)i ／／构造空找$
ch ge上c №了0； 从终端接收第一个字符 while ()h 0 E〕0为全文结束符
“h到思()h！：。EOF & & ch》0 \ 姒上ch (ch)〈
ea北' #气Pop($，c) i br“k; /纟仅当栈非空时退伐 ea?e '@气Clearstack(S)i break; '重置s为空栈
default：push(S，c.h)； bre 0/有效字符进栈，禾考虑找满情形
ch ；ge怕r()；从终端接收下一个字符
将从栈底到栈顶的栈内字符传送至调用过程的数据区；
Clear$tock(； 重置s为空栈
()h！“刃ch苤getchar()，
Destroy$tack(劬；
)// LineEdit
算法3，2
3．2．4迷宫求解
求迷宫中从人口到出口的所有路径是一个经典的程序设计问题。由于计算机解迷宫时，通常用的是“穷举求解”的方法，即从人口出发，顺某
一方向向前探索，若能走通，则继续往前走；否则沿原人口
钐
多
彡@过也
0
到到到0
00
0
到
到
0
0
0
0
000勿
0
0
到
的
到
0
过
到
的
0
到
到
到到
0
的
河
乡 的
00
勿0
o到00
0
路退回，换一个方向再继续探索，直至所有可能的通路 0 ． ．都探索到为止。为了保证在任何位置上都能沿原路退1 回，显然需要用一个后进先出的结构来保存从人口到当 3 前位置的路径。因此，在求迷宫通路的算法中应用“栈” 45 也就是自然而然的事了。 6 首先，在计算机中可以用如图30所示的方块图表8(7)示迷宫。图中的每个方块或为通道（以空白方块表示），
或为墙（以带阴影线的方块表示）。所求路径必须是简 图3迷官单路径，即在求得的路径上不能重复出现同一通道块。
假设“当前位置"指的是“在搜索过程中某一时刻所在图中某个方块位置'，则求迷宫中一条路径的算法的基本思想是：若当前位置“可通"，则纳人“当前路径"，并继续朝“下
位置'探索，即切换“下一位置"为"当前位置"，如此重复直至到达出口；若当前位置．不可通"，则应顺着“来向"退回到“前一通道块"，然后朝着除“来向''之外的其他力向继续探索；若该通道块的四周4个方块均“不可通"，则应从“当前路径”上删除该通道块“所i胃“下一位置”指的是“当前位置”四周4个方向（东、南、西、北）上相邻的方块。假设以栈S记录 `当前路径”，则栈顶中存放的是“当前路释上最后一个通道块，。由此，“纳人路径”的操仵即为“当前位置人找，疒从当前路径于删除前．通道块"的操作即为“出栈' 求迷宫中一条从人口到出凵的路径的算法可简单描述如下：设定当前位置的初值为人口位置，
若当前位置可通．
则{将当前位置插人栈顶； 纳入路径
若该位詈是出口位罟．则结束； ／/求得路径存放在找中否则切换当前位置的东邻力块为新的当前位置；
否则，
若栈小空且栈顶位置尚有其他方向未经探索，
则设定新的当前位置为沿№时钊方向旋转找到的找顶位置的卜一相邻块：若找不空但栈顶位置的四周均不可，
则〈删去栈顶位置 从路径中删去该通道块若栈小空，则重新测试新的栈顶位置，
直至找到个可通的和邻块或出栈至栈空；
}诅e（栈不空）；
在此，尚需说明一点的是，所谓当前位置可通，指的是未曾走到过的通道块，即要求该方块位置不仅是通道块，而且既不在当前路径上（否则所求路径就不是简单路径），也不是曾经纳人过路径的道块（否则只能在死胡同内转圈）。
巧de萨?trust（通道块在路径上的“序号
PogType at ; //通道块在迷宫中的“坐标位置"
从此通道块走向下一通道块的"方向
} SEIemType；
/0弋的元素类型
．
Status Mazepath（MazeType maze，POSType，POSTYPe end）{
若迷宫ma中存在从入「吓社到出门。fid的通道，则求得一条存放在栈中（从栈底到栈
//顶) ,并返回TR吨；否则讵回L
InitStaek( $）；curpos = start； 设定当前位置"河人凵位置" curstep = 1； //探索第 do（
(pass (curpos)) { //当前位置可以通过，即是未曾走到过的通道块
FootPrint（curpos)；
（curstep．1）；
，纟留下足迹
Push (S.e) ;
汐加人路径
if（亡匿pos．= end) return（）
到达终点（出口）
cur-POS NextPos（．]〕．
//下一位置是当前位置的东邻
curstep±+；
探索下一步
el艹{ 当前位置不能通过 if（！S以k帏唄：还y吓{ Pop (.S.e):
“h鼠1 & &！StackEmptY(S))〈
a赚Pr建( ). 5e0切；
}、巾讼e
Pop (S，e) i
/7留下不能通过的标记．并退回一步
计气，cil < {
Push〈S e〕；换下一个方向探索
Ne凵均5 (). seat e. di）： ，/设定当前位置是该趼方向匕的相邻块
扎/ If
hile（000k血Y（的
return〔FALSE)；
} P!azepath
箅法3，3
3 2 5表达式求值
表达式求值是程序设计语言编译中的一个墨基本问题。它的实现是栈应用的又一个典型例子。这里介绍一种简单直观、广为使用的算法，通常称为“算符优先法"。
要把一个表达式翻译成正确求值的一个机器指令序列，或者直接对表达式求值，首先要能够正确解释表达式。例如，要对下血的算术表达式求值
。01一2 3一I的5
首先要了解算术四则运算的规则。即： l )先乘除，后加减
2） 从左算到右；
3） 先括号内，后括号外。
由此．这个算术表达式的计算顺序应为
4 2只3一10 / 5一4 + 6一10 / 5一 1 0一10 / 5 1 0 2
算符优先法就是根据这个运算优先关系的规定来实现对表达式的编译或解释执行的。
任何一个表达式都是由操作数（。p。“ nd）、运算符（opera r）和界限符（delim r）组成的 ， 我们称它们为单词。 一般地 ， 操作数既可以是常数也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符等3类；基本界限符有左右括号和表达式结束符等。 为了叙述的简洁 ， 我们仅讨论简单算术表达式的求值问题。
这种表达式只含加、减、乘、除等 4 种运算符“ 读者不难将它惟广到更一般的表达式十 ，
我们把运算符和界限符统称为算符 ， 它们构成的集合命名为 op。 根据上述 3 条运算规则 ， 在运算的每一步中 ， 任意两个相继出现的算符 8， 和 0， 之间的优先关系至多是下面3种关系之一；
< 9，的优先权低于
o《 61的优先权等于02
0的的仇先权高于
表3．I定义了算符之间的这种优先关系。
表3彐算符间的优先关系 由规则3），+、 和/为01时的优先性均低于'（，但高于“）”，由规则2），当二时，令>吓' #，是表达式的结束符。为了算法简洁，在表达式的最左边也虚设一个 ' 0构成都个表达式的一对括号。表中的' 0 '广表示当左右括号相时，号内的运算己经完成。同理，辉，“ =，表示整个表达式求值完毕。'尸与' 0、' #，与'），以及气，与' #，之间无优先关系，这是因为表达式中不允许它们相继出现，一旦遇到这种情况，则可以认为出现了语法错误。在下面的讨论中，我们暂假定所输人的表达式不会出现语法错误。
为实现算符仇先算法，可以使用两个工作栈“一个称做OPTIC，用以寄存运算符；另一个称做()PND，用以寄存操作数或运算结果。算法的基本思想是：
l )首先置操作数栈为空栈，表达式起始符“ # ”为运算符栈的栈底元素；
2）依次读人表达式中每个宁符，若是操作数则进OPND栈，若是运算符，则和 OPTR栈的栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕（即()PTR 浅的栈顶元素和当前读人的字符均为“ # ” 算法3．1描述了这个求值过程。
OperandType EvaluateExpress ion() {
算术表达式求值的算符优先算法。设咿和C)PND分别为运算符栈和运算数栈，为运算符集合。
InitStaek (OPTRh push（0酉．'輯与； initStaek (OPND)；c getchar()；
*hile (c! =旷 GetTop(OPTR) 0 0 {
if 0 In(). OP)){Push((OPND. 0后c = getchar()钅} ／／不是运算符则进栈 1 0
3KiEch（precede(，的）{ Cage 汐栈顶儿素优先权低
Push(C)E?I'R，c); 0 getcharQ)； break;
C* Se 脱括号并接牧下一字符 Pop(OPTR, x)；亡 getchar（后 break；
53
Case /3退找并将运算结果人伐
Pop( OPTH，theta)；
皆甲（OPNf)．Pop(DPNn.》）；
Push(OPNI). Operate().上h酰a，b))； break；
} Switch
cetuxn GetTop( 02ND);
〉EvaluateExpres5iOn
箅法3．4
算法中还调用了两个函数。其中Precede是判定运算符栈的栈顶运算符01与读人的运算符02之间优先关系的数；Operate为进行二元运算a的函数，如果是编译表达式，则产生这个运算的一组相应指令并返回存放结果的中间变量名；如果是解释执行表达式，则直接进行该运算．并返回运算的结果。
例3以利用算法Evaluate卜:xpression- reduced对算术表达式3（7一2）求值，操作过程如下所示。 步骤 DPTR栈 OPND栈 输人字符 主要操作3．3栈与递归的实现
栈还有。个重要应用是在程序设计语言中实现递归。一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。
递归是程序设计中一个强有力的工具。其一，有很多数学函数是递归定义的，如大家熟悉的阶乘函数
Fact(n) （3一1 )
．Facl(n
2阶Fibonacci数列
0
Fib(n) Fib() — 1) +到b 一2） 其他情形
和Ackerman函数
· 54 ·
若m = 0
Aek(m，的= AckOn一]，0 （3一3） Ack()— 1，Ack(m .n — 1 ) )其他情形
等；其二，有的数据结构．如一叉树、，、义表等，山于结构本身固有的递归特性，则它们的操作弓递归地描述；其一，还有一类问题，虽则问题本身没有明显的递归结构，但用递归求解比迭代求解更简单，，如八皇后问题，Ha “ i塔问题等。
例3一2阶日“卣塔问题）假设有3个分别命名为X、Y和Z的塔座，在塔座X上
插有月个直大小各不相同、依小到大编号为]，2，，
”的圆盘（如图3．5所示）。现要求掐X轴十的“个圆盘移至塔座Z上并仍按同样顺序疊排，圆盘移动时必须遵循下列规则：
( I)每次只能移动一个圆盘；
图3，5 3阶H anoi塔问题 （2）圆盘可以插在X、Y和Z中的任一塔座上；
的初始状态 （3）任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。
如甸实现移动圆盘的操作呢？当一丨时，问题比较简单，只要将编号为1的圆盘从塔座X直接移至塔座Z上即可；当，01时，需利用塔座Y作辅助塔座，若能设法将吓在编号为”的圆盘之上的“一1个圆盘从塔座X（依照上述法则）移至塔座Y上，则可先将编号为门的圆盘从塔座X移至塔座Z上，然后再掐塔座Y上的”一1个圆盘（依照上述法则）移至塔座Z上。而如何将”一1个圆盘从一个塔座移至另一个塔座的问题是一个和原问题只有相同特征属性的问题，只是问题的规模小1，因此可以用同吖的方法求解。山此可得如算法3．5所示的求解月阶Han塔问题的0函数。
void ha-noi（int山char ch y．char z)
／/将塔座x上按直径由小到人且自上而下编号为]至n的n个圆盘按规则搬到 塔座z上可用作辅助塔座。
搬动操作move性“以）可定义为在是初值为0的全局变量．对搬动斗数后
// printf(" Movedisk % i from to + c、n? 2后 move(). 1，扪； //将编号为1的圆盘从x移到z
else {
hanoi(n - l . x, 0： 栲x上编号为1至n一1的圆盘移到v “作辅助塔
将编号为n的圆盘从x移到z
hanoi()-狐 将y下编号为1至n一I的圆盘移到z “作辅助塔
算法3巧
显然，这是一个递归承数．在蕕数的执行函数中，需多次进行自我调用。那末·这个递归数是如何执行的．先看任意两个函数之间进行调用的情形
和汇编程序设计中主程序和了程序之间的链接和信息交换相类似．在高级语言编制
的程序中，调用函数和被调用函数上之间的链接和信息交换需通过栈来进行。
通常，当在一个数的运行期间调用另一个数时，在运行被调用数之前，系统需先完成3件事以的将所有的实在参数、返回地址等信息传睇给被调用函数保存；（2）为被调用函数的局部变量分配存储区这3）将控制转移到被调函数的人口。而从被调用数返回调用数之前，系统也应完成3件工作：（保存被调函数的计算结果；（2）释放被调函数的数据区；（3冫依照被调函数保存的返回地址将控制转移到调用函数。当有多个丞数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶。例如，在图3．6 @所示主数main中调用了函数 fir山而在数first中又调用了函数$ “。nd，则图3，6（的展示了当前正在执行函数second中某个语句时栈的状态，而图3，6（b）展示从函数second退出之正执行函数st 中某个语句时栈的状态（图中以语句标号表示返回地址）。
Y
void fi工引气{社吓int void second( int d); void it〕0（
first（n)；
first:（《nt：耘int
cond 0）；
int second (int d) {
<
栈顶
图3，6主函数mam执行期间运行栈的状态
一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用丞数是同一个函数，因此，和每次调用相关的一个重要的概念是递归函数运行的“层次”。假设调用该递归数的主函数为第0层，则从主函数调用递归函数为进人第1层，从第层递归调用本函数为进人“下一层"，即第衅1层。反之，退出第层递归应返回至“上一层"、 若在函数A中调用了数H?贝刂称函数、为调用数，称函数B为被调用函数、
即第一I层。为了保证递归函数止确执行；系统需设立一个“递归匚作栈"作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个“「作记录”．其中包括所有的实在参数、所有的局部变犀以及上．层的返回地川。每进人一层睇归，就产生一个新的T作记录乐人栈顶。每退出一层递归．就从栈顶弹出一个工作记录，则当前执行层的上作记录必是涕归工作栈栈顶的工作记录，称这个记录为“活动记录"，并称指示活动记录的栈顶指针为“当前环境指针”。
例如，图3，7展示了语句
hanoi(3，a，b，的
行过程（从主函数进人递归函数到退出递归函数而返回至主函数）中递归上作找状态的变化情况。山于算法3，5所小的递归函数中只含四个值参数，则每个工作记录包含5个数据项：返回地址和1个实在参数，并以递归函数中的语句行号表示返回地址，同时假设主数的返回地量为0。图3．7中>表示栈顶指针。
实际上，在调用函数和被凋用函数之间不一定传递参数的值，也可以传递参数的地址。通常，每个程序设计语出都有它自己约定的传递方法（包括被调用函数的执行结果如何诉回凋用函数等不其细节读名将会在后续课程中学到。
由于递归函数结构清晰，悍序易读，面且它的正确性容易得到证明“因此，利用允许递归调用的语言（例如C语言）进行程序设计时，给用户编制程序和调试程序带来很大方便。因为对这样一类递归问题编程时，不需用户自己而由系统来管理递归工作栈。
归运行的层次
行语句行号
递归工作钱状态
o址湖值球，y “值〕
喏与圆盘的壮态
囗，“这
山主函数进丿、第层递归后．运行至谄句（行巧·因递归用而进人下一层。
由第一层的句（行0进人第“层递归，执行至语句
2，0 b
3，自?l以e
私 ，b．
山二层的经0刂（行巧进人第二层睇归，执行语句（行）3，将1刂圆盘由侈至亡后从语句（行）9退出第。层递归，返回至第二层的语句（行）6心
将2号圆盘由a移b后，从句（行）7进丿、T一层归《
冚塔的睇归函数运行示意图 在实际的系统中一般都综合考虑递归州用和非递归调用统一处理，在此，我们只讨论直接递归调用的处卉极制。
· 5 7 归运
的层次
一行酒句行号
睇归上作状态
o却 值巛值，y值“亻№
塔与盘的状态
将I号圆盘由c侈至到叾从句（行退出第二层，返回至第二层的iB句
（行）
8 0，c，b
，a “、，b
8，9
从句（行）9退出弟 层，返回至第一以的语句（行。
栲3号圆山《《帏至。后咩从语句（行进人下一层递归。
从第二层的语句（行〕5进人筇层递归。
“吓
o，3
将]号圆盘由b移至后、从语句（行圓退出篤二《层归，回至第过层语句
（行）6。
将2号圆盘由5移至。后，从语句《行进人卜刁递归
诩，b，c
8，2，b，a，c
o，3 “，b，
将]每圆盘由移至e后，从语句（行）9退出第三层，返回至第二层语句( )j）
8 · 9
从浯（行退出第一层．返回至第．层语句（行）&
8，2，b．
出3，
从句（行）9退出递归数，回至主函数
堆运行主函数
30 队 列
3．4 1抽象数据类型队列的定义
和栈相反，队列（Queue）是一种先进先出（F吓I } n Fi仆t out，缩写为FIFO）的线性表。它只允许在表的一端进行插人，血在另一端删除元素。这和我们日常生活中的排队
， ·
是一致的，最早进人队列的儿素最早离月。在队列中，允许插入的“端叫做队尾( rear），允许删除的一端则称为队头0、艹0。假设
， ，
有在-，，，“：1都离开队列之后，‰才能
图3队列的示意图
队列为q一（山，，“ “凵，那么，山就是队 出队列人队列头元素，则是队尾元素。队列中的兀素是刂安照，， “，的顺序进人的，退出队列也只能按照这个次序依次退出 也就是说只
退出队列。图3．8是队列的示意图。
队列在程序设计中也经常出现。一个最典型的例子就是操作系统中的作业排队。在允许多道程序运行的刂算机系统中，同时有几个作业运行。如果运行的结果都需要通过通道输出，那就要按清求输出的先后次序排队。每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出作怖出操作。凡是申请输出的作业都从队尾进人队列。
队列的操作与栈的操作类似，也有8个。不同的是删除是在表的头部（即队头）进行。
下面给出队列的抽象数据类型定义：
加e（
数对象：D {的a.e固e，i
据关系：RI = {。甴冫' 0 “
约定其中a,端为队列头@端为队列尾。
基本操作：操作结果：构造一个空队列初始条件：队列Q已存在。
操作结果：队列0被销毁．不再存在。
ClearQueue(&?Q)
初始条件：队列0已存在。
操作结果：将0清为空队列。
QneueFanpty( Q）
初始条件：队列已存。
操作结果：若0为空队列．则返回TR，否则。
QueueLength( 0）
初始条件：队列0巳存在。
操作结果：返軻0的元素个数．即队列的长度。
毹“d（0，be)
初始条件：Q为非空队列。
撵作结果：用返回0的队头元素。
E.n0ueue(&Q, e)
初始条件：队列Q已存在。
操作结果：插人元素为0的新的队尾元素 DeQueue(&Q, &e)
初始条件：Q为非空队列。
作结果删除Q的队头元素，并用e返回其值。
pueoeTraverse(Q，visit( ) )
初始条件：0已存在10卧空．
操作果：从队头到队尾，依次对0的每个数元素调用感数画。0。 、以visit( ) 失败．则操作火数值Queu
和栈类似，在本朽以后各章中引用的队列都应是如上定义的队列类型。队列的数据元素类型在应用程序内定义。
除了栈和队列之外，还有一种限定性数据结构是双端队列（Dequc)。
双端队列是限定插人和删除操作在表的两端进行的线性表。这两端分别称做端点1 和端点2（如图3，9（的所示）。也可像栈一样，可以用一个铁道转轨网络来比喻双端队列，如图3，9（b）所示。在实际使用中，还可以有输出受限的双端队列（即一个端点允许插人和删除，另一个端点只允许插人的双端队列）和输人受限的双端队列（即一个端点允许插人和删除，另一个端点只允许删除的双端队列而如果限定双端队列从某个端点插人的元素只能从该端点删除，则该双端队列就蜕变为两个找底相邻接的找了“
图3，9双端队列示意图
〔的队列《（铁道转轨网
尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用，故在此不作i羊细讨论。
3．4．2队列一．一队列的链式表示和实现
和线胜表类似，队列也可以有两种存储表示。
用表表示的队列简称为链队列，如图300所示。一个队列显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能惟一确定。这里，和线性表的单
表一样，为了操作方便起见，我们也给涟队列添加一个头结点，并令头指针指向头结点：由此，空的彘队列的判决条件为头指到和尾指针均指向头结点，如图3．1 1（a）所示。
链队列的操作即为单链表的插人和删除操作的特殊情况，只是尚需修改尾指针或头指针，图3 1 1（b〕一（d）展示了这两种操作进行时指针变化的情况。下面绐出链队列类型的模块说明
·
data next
(d)
图3，10 链队列示意图
= =一= ADT Queue的表示与实现
一单队列一一．队列的缸式存储结构 typed" QNQde {
Q刚“身 d上
Struct QN到0 next;
} QNOdet善@e山甲后飞 typedef struct {
o旧门d10．f了an坛 队头指针
QueuePtr rear； ／/队尾指针
} LinkQnQue；
图土1 1队列运算指针变化状况
(a)空队列， (b)丿L承x人队列；
（元y人队列；(d)元素x出队列
一基车操作的函数原型说明
Init:Queue（LinkQueue & 构造一个空队列0
Status DestroyQueue（Lir》kQ1艹&
//销毁队列0，0不再存在
Status earQueue（LinkQueue & 0）将0清为空队列毓us Queuecmpty（L新0u0u0 0）
／/若队列0为空队列，则返回T即E，否则返回硼L int QueueLength（LinkQueue．
//返回Q的元素个数，即为队列的长度
Status Gettlead（LinkQueue Q，QE1emType &的 若队列不空．则用e返回0的队头元素．并返回0K；否则返回ERROR
Status EnQueue（L eue & 0） 插人元素e为Q的的队尾元素 status DeQueue（LinkQueue &Q，QEI emType &e) 若队列不空．则删除0的队头元素，用e诉回其值，并返回0
／/否则返回ERROR
· 6 1
Status QueueTravevse(LinkQueue Q. vLsit( ) )sizeof (QN0de) )
Status DestroyQueue ( LinkQueue {(Q, front:) { Q. rear Q, front free (Q. front) i
Q. front q. rear:
return OK'
Status EhQueue ( LinkQueue OE1emType e)
p naL10c: (sizeof (QNode) ' ; if ( ! p) (OVERFLOW) ; p NULL;
Q. rear ?next. Q. rear = p; return
Stat:ug
{f (Q. front
Q, front ->next;
—>data ;
— > next if (Q, rear p) Q. Q. front; free (p) return OK ; ? ?
列尾指针也去失了．因此需对队尾指针重新赋值（指向头结点)O
3．4．3循环队列一一队列的顺序表示和实现
和顺序栈相类似，在队列的顺序存储结构中·除了用一组地址连续的存储单兀依次存放从队列头到队列尾的元素之外，尚需附设两个指针{ ront和rear分别指示队列头元素和队列尾元素的位置。为了在C语占中描述方便起见，在此我们约定：初始化建空队列时，令front一“ “一0，每当插人新的队列尾元素时，“尾指钊增1 ”；每当删除队列头元素时，“头指针增1 ”、因此，在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。如图302所示
QIront
Q. front
o行t
(d)
图3，0头、尾指到和队列中兀素之间的关系
00下队列0短后、上和扣泔人队列沤的和上相继被删下孙
（十JG、30《001j啉人队列之后和J'被除
假设当前为队列分配的最大空间为6，则当队列处于图3．12（山的状态时不可再继续插人新的队尾兀素，否则会因数组越界而遭致程序代码被破坏。然曲此时又不宜如顺序栈那样，进行存储再分配扩大数组空间，因为队列的实际可用空间并木占满。一个较巧妙的办法是将顺序队列臆造为“个环状的空间，如图 3，1 3所示，称之为循环队列。指针和队列元素之间关系不变．如图3口巨的所示循环队列中，队列头元素是J，，队列尾元素是J：．之JG、j和J,相继插人，则队列空间均被占满，如图3．14 (的所示，此时 0 front：Q. rear；反之，若JR、玉和JG相继从图 3．1 4（的的队列中删除，使队列呈“空”的状态，如
图3，14（c）所小。此时亦有在关系式Q. front图3．1 3循环队列示意图 Q．rear，山此可见，只凭等式0．front一Q，re “无法
判别队列空间是“空'还是“满"。可有两种处理方法：其．是另设一个标志位以区别队列是“空'还是“满"；其二是少用一个元素空间，约定以“队列头指针在队列尾指针的置（指环状的下一位置）上"作为队列呈“满"状态的标志。
从上述分析可见．在C语言中不能用动态分配的一维数组来实现循环队列。如果用户的应用程序中没有循环队列，则必须为它设定一个最大队列长度；若田户九法预估所用
．63 ·
图3，] 4循环队列的头尾指釗
@一般情况；（的队列满时《@空队列
队列的最大长度．则宜采用队列。
循环队列类型的模块说明如．卜：
一循环队列一一队列的序存储结构
# f玉“ ×0 ZE 1 埽大队列长度 typedef struct {
100TY e； ．初始化的动态分配存储空间
武front;
/0、指针，若队列不空，指向队列头元素
int rear;
，/尾指针諾队列不空，指向队列尾元素的下一个位置
)Sqqueue；
一循环队列的基本澡作的算法描述
Status I nit)ueue（S@艹№ &0）{ 构造一个空队列0
o 、№90 (QElemType）a11 (MHQSIZE、sizeof（lemT的月
0 Q. base) “让〈ER旺）；汐存储分配失败
o ．front：： Q. rear = return 0；
玉n QueueLength〔SqQueue Q) { 方返回0的兀素个数，即队列的长度 return（0．rear．．0．front + MAXQSIZE) A×OSI： Status En0ueue（SqQueue &-Q，QElenuyve e）{ 届人元素@为0蕕的队尾元素
if ((O.rear+ 0 MAXOSIZE 0.五0n0 Rk酥：//队列满 0，baseCQ rearl * 0； Q， (Q.rearf 0 SI； return 05；
Status DeQueue〈SqQueue &?Q ` 0心“TY些0 {
若队列不空，则删除Q的队头元素，用e返回其值，并返回；
，纟否则返回ERROR
if (). front。。 Q，rear) return ERROR； e ' 0，№se「0〔ron辶；
o．front = （Q（0酰+ 0 MAXQSIZE; return OK；
3，5离散事件模拟
在日常生活中，我们经常会遇到许多为了维护社会正常秩序而窬要排队的情境。这样一类活动的模扌以程序通常需要用到队列和线性表之类的数据结构，因此是队列的典型应用例了之一。这里将向或者介绍一个银行业务的模拟程序。
假设某银行有1个窗口对外接待客户，从早晨银行开门起不断有客户进人银行，山于每个窗口在某个时刻只能接待一个客户，因此在客户人数众多时需在每个窗口前顺次排队，对于刚进人银行的客户，如果某个窗囗的业务员正空闲，则可上前办理业务，反之，若，1个窗门均有客户所占，他便会排在人数最少的队伍后面。现在需要编制一个程序以模担银行的这种业务活动并司算一天中客户在银行逗留的平均时间。
为了计算这个平均时间，我们自然需要掌握每个客户到达银行和离开银行这两个时刻，后者减去前者即为每个客户在银行的逗留时间。所有客户逗留时间的总和被一人内进人银行的客户数除便是所求的斗均时问。称客户到达银行和离开银行这两个时刻发生的事情为“事件"，则整个模拟程序将按事件发生的先后顺序进行处理，这样一种模拟程序称做事件驱动模拟，算法3．6描述的正是上述银行客户的离散事件驱动模拟程序。
void Bank S rmulation( int 00s0T〕血e）（
银行业务模拟，统计一天内客户在银行逗留的平均时间。
槲下后Y（丛 //初始化曾h玉le（MoreEvent）{
EventDrived( OccurTime．EventType); //事件驱动
switch（en上忄e）{
Case 监《CustomerArrived(）《 breaJc //处理客户到达事件 D : CustomerDeparture(）禀 break； 处理客户离开事件
default：Invalid(丛
}／' switch
· 65 ·
司甾2上
CloseForDay; 计算平均短留时间
〉Bank Simulation
算法3，6
下面词论模拟程序的实现，首先讨论模拟嵇序中需要的数据结构及其操作算法3，6处理的主要对象是“事件"，事件的主要信息是事件类型和事件发生的时刻。算法中处理的事件有两类：，，类是客户到达事件；另一类是客户离开事件。前一类事件发生的时刻随客户到来自然形成；后一类事件发生时刻则山客户事务所需时间和等待所耗时间而定。由于程序驱动是按事件发生时刻的先后顺序进行，则事件表应是有序表，其主要操作是插人和删除事件。
模拟程序中需要的另一种数据结构是表示客户排队的陈列，由丁前面假没银行有个窗口，内此程序中需要四个队列，队列中有关客户的主要信息是客户到达的时刻和客户办理事务所需时间。匈个队列中的队头客户即为正在窗口办理事务的客户，他办完事务离开队列的时刻就是即将发生的客户离开事件的时刻，这就是说，对每个队头客户都存在一个要驱动的客户离片事件。因此，在任何时刻即将发生的事件只有下列5种可能： 0）新的客户到达；（2月号窗口客户离开；（3）2号窗口客户离开；（4）3号窗口客户离开；（5）4号窗口客户离开。
从以分析可见，在这个模拟程序中只需要两种数据类型：有序链表和队列。它们的数据元类型分别定义如下：
typedef struct {
int 事件发生时刻
int NType； ／事件类型，0表示到达事件，]至感表示四个窗口的离开事件
}，1 emType； ，/事件类型，有序链表Linkl，土st的数据元素类型
typedef LinkLast “0t0．毓 //事們表类型，定义为有序雠表
社； ．到达时刻
〔№上i01、； 办理事务所需时间
} he T肄e； 彦队列的数据元素类型
现在我们详细分析算法3，6中的两个主要操作步骤是如何实现的先看对籼客户到达事件的处理。
由 一] 在实际的银行中 ， 客户到达的时刻及其办理事务所需时间都是随 的 ， 在模拟程序中可用 机数来代替。 不失 一般世 ， 假设第 一个顾客进门的时刻为0 ， 即是模拟程序处理的第一 个事 ， 之后每个客户到达的时刻在前一个客户到达时设定 、 因此在客户到达事件发生时需先产 生两个随机数 其一为此时刻到达的客户办理事务所需时间 durtim 其二为下一客户将到达的时间间隔 而t。，til“ ， 假设当前事件发生的时刻为 。。 、 ， 则下一个客户到达事件发生的时刻为 、 由此应产生一个新的客户到达事付插人事件表 ； 刚到达的客户则帘插人到当前所含元素最少的队列中 ；若该队列在插人前为空，则还应产生一个客户离开事件插人事件表。
客户离月．事僻的处理比较简单。首先计算该客户在银行逗留的时间，然后从队列中删除该客户后查看队列是否空．若不空则设定一个的队头客户离开事件。
最后我们给出在1还数据结构下实现的银行事件驱动模拟程序如算法3，7所示。
／/序中用到的主要变量
EventList／事件表
Event事件
LinkQueue，／4个客户队列 OE} 0引T卯e 客户记录土n上TotalTime，CustomerNurn； 厚累计客户逗留时间，客户数
int cmp (Event a， Event b 依事件的发亇时刻<或=或产事件b的发生时刻分别返回到或0或I
void OpenForDay() { 初始化操作
TotalTime 凿 0四《№丿Ill
初始化累计时间和客户数为0
InitL1gt（“冫；
初始化事件链表为空表
em OccurTime = 0；en，NType
设定第．，个客户到达事件
Orderinsert（“，0叩丛
插人事件表
for 0 + +的Lnit0ueue（〕）；汐置空队列
} OpenFur10ay
“ Customet?Arrived() { 处理客户到达事付，．NType- 0。
Random( dux-time， ／/生成蒲机数
《孬en,0ceurTime + ，/下一客户到达时刻
（< 00自i加e） ／丿银行尚未关门，插人事付表
Orderlnsert (ev.气，@，emp)：
Minimum(中： //求长度最队列
（QueueLength
OrdetInserE（．以〕+ i)，0呻后
，7设定第i队列的一个开事件并插人件表
〉CustomerArrived
void CustomerDeparture(）{ 处理客户离廾事，“，旮些'以。
en.NType: D国0u0地(q 0，0旧℃0但e的； 删除第i队列的排头客户 CUS上er.；汐累计客户逗留时间珏0 QueueEnpt37(qC?)) { 亻/设定第1队列的一个离廾事件并插人事件表
GetHead（qr 1《．
Orderlnsert-（，（0二C卩e十．10n，1冫， （cmp这））i
，Customer3epa:-tuce
void Bank ion(lnt曙湖、℃》{
OpenForDay(）； 初始化 h玉e（！Lust-Empty(ev))
De上5 ℃ (GetHead〔(v)，p)：en GetCurE]erb(p)； if (en- Nffype =的
Cu$tosnerArr）i /7处理客户到达事件
015e CustoreerDepa〕"ture(）； 汐'处理客户离丌事件
季计算并输出平均逗留时间
printf("The Average龜is，(float)TotalTime／
} S ügulation
算法3，7
例3一3假设每个客户办理业务的时间不超过30分钟;两个相邻到达银行的客户的时间间隔小超过》分钟，模拟程序从第一个客户到达时间为“ 0 ”开始起运行。
删除事件表一I第一个结点，得到“，OccurTime—(〕，因为“．NType—0，则即得到两个随机数（23，4），生成一个下一客户到达银行的事件（Oc “ rTime一NType一的插人事件表；刚到的第一位客户排在第一个窗口的队列中（Ar小，alTime = 0，山- 23），山于他是排头，故生成一个客户将离开的事件（OccurT “e = 23，NType = 1 )插人事件表。
删除事件表上第一个结点，仍是新客户到达事件（因为- Occur Time一私得到随机数为（3山，则下一客户到达银行的时间为0 “ “ me亠“1一》一1一5、山丁此时第二个窗凵是空的，则刚到的第0位客户为第二个队列的队头（A“ i “ e一0
I)uration一3）．因而生成一个客户将离开的事件（0（Time一7，INType一2）插人事件表。
删除事件表上第一个结点，仍是新客户到达事件，en. O urTltne一5，得到随机数（门，3），则插人事件表的新事件为（0 “ urT《me：8，NType一的，同时，刚到的第三位客户成为第三个队列的队头（A “ i Ti -：5．D “a山n一( l )，因而插人事件表的新事件为 (OccurTime—lG.NTypc—3)。
删除事件表的第一个结点．因为NType：一2．说明是第二个窗口的客户离开银行亠 Oc “一？，删去第二个队列的队头，c “ s山m “．ArrivalTime = 4，则他在银行的逗留时间为3分钟。
依次类推，在模拟开始后的一段时间内，事件表和队列的状态如图3，巧所示，～ first为链表头指图3，巧 事件驱动模拟'算法3．0过程中事件表和队列状态变化状况
第4章串
计算机上的非数值处理的对象基本上是字符串数据。在较早的嵇序没计语言中，字符串是作为输人和输出的常量出现的。随着语加匚程序的发展，产生了字符串处理。这样，字符串也就作为一种变量类型出现在越来越多的程序设计语言中，同时也产生了一系列字符串的操作。字符串一般简称为串。在汇编和语言的编译序中，源程序和目标程序都是字符串数据。在事务处理程序中，顾客的姓名和地址以及货物的名称、产地和规袼等“般也是作为字符申处理的。又如信息检索系统、文字编辑程序、问答系统、自然语翻译系统以及音乐分析程序等，都是以字符串数据作为处理对象的，
然面，现今我们使用的计算机的硬件结构主要是反映数值计算的需要的，因此，在处理字符串数据时比处理幣数和浮点数要复杂得多。曲且，在不同类型的应用中，所处理的字符串具亻j不同的特点，要有效地实现字符串的处理，就必须根据具体情况使用合适的存储结构“这一章．我们将讨论一些基本的串处理操作和几种不同的存储结构。
4彐串类型的定义
串（№．in@（或字符串），是山零个或多个字符组成的有限序列。一般记为其中．、是串的名，用单引括起来的字符序列是串的值“（1《十《《的可以是字母、数字或他字符；串中字符的数目“称为串的长度。零个字符的串称为空串〈N it@，它的长度为零
串中任意个连续的字符组成的子序列称为该串的子串。包含子申的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置子串在串中的位置则以子串的第一个字符在主串中的位置来表小。
例如，假设a訕“、a为如下的4个串
a='?E了 0411NG
c--'BEIJING' d= 'BEI JING
则它们的长度分别为3諢、7和8；并目“和都是（和d的子串迢在c和d中的位置都是l .而b在（，中的位置是4，在d中的位置则是5。
称两个串是相等的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并目、各个对应位置的字符都相等时才相等。例@上例中的串泌“和d彼此都不相等。
值得一提的是，串值必须用一对单引号括起来·但单引另本身不属丁申，它的作用只是为了避免与变量名或数的常量混淆而已例如在程序设计语訁中
x一' 123气
则表明x是一个串变量名，赋给它的值是字符序列123。又如
tsing— 'TSlNG'
中' tsmg是一个串变量名，而字符序列TSING是其值
在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其他字符中间。由一个或多个空格组成的串冖称为空格串〈blank string，请注意：此处不是空串）。
它的长度为串中空格字符的个数。为了清楚起见，以后我们用符号“ ”来表示“空串”
串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线世表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象，如：在线性表中查找某个元素、求取某个元素、在某个位置上插人一个元素和删除
个兀素等礻而在串的基本操作中，通常以“串的整体”作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插人一个子串以及删除一个子串等。
串的抽象数据类型的定义如下：
ADT String {
數据对象：D={ a,!山eCharoet.erSet.. i；0，2， ，tn，n00：数掂关系：：0 《 《凿《 过2．基本怍：
S王()T，Chars) 初始条件《c№“是字符申常量
操作结果：生成一个其值等于。“的申T.
Strcopy (&T,
初始条件：串5存在。
作结果：山串s复制得串
StrEnpty（初始条件紳s存在。
操作结果：若s为空串，则返回TRUE，否则返回L$
StrConpare（T) 初始条件呻s和T存在。
操作结：若s > T．则返回值>山若$以T，则返回值地着S < 0则返回值< 0。
StrLength（S) 初始条件：串s存在。
操作结果：返回s的元素个数，称为串的长度。
Clear*ring（&引初始条件《串存在。
操作结果：将s清为空串
初始条件：串引和$2存在《
操作结果：用T返回由引和$2联接而成的新串·
SubString（&,sub，四Ten)
初始条件：串S存在'1<pos<StrLength(S)且0<1en<StrLength(S)．“ POS + 1。
操作结果：用sub返回串s的第pos个字符起长度为len的子串。
Index (S，T，pos)
初始条件：串s和T存在，T是非空串，1 s < str上h（s）
操作结果：若主串s中存在和串T值相同的子串，则返回它在主串s中第p。5个字符之后第一次出现的位置；否则函数值为0。
7 1
PJ e (&S. T.的
初始条件．串s，T和v存在，T是非空串。
操作结果：用替换主串s中出现的所有与?r相等的不重的子串。
Strlngert (&S.凶T)
初始条付；甲S# T存在，1、些s就en啦h（十地作结果：在甲5的第些s个字符之前抽人串TQ
StrDe10te（& $，p05，司
初始条件：串s存在,I<poe<StrLength(S) 一len? ]
操作结果：从串s中删除第pos个字符起长度为Len的子串。
DeBtrOYString（& 3）初始条件冲存在。
操作结果：申s被销毁 String
对于串的基本操作集可以有不同的定义方法，读者在使用高级程序设计语言中的串类型时，应以该语言的参考手册为准。在上述抽象数据类型定义的13种操作中，申赋值 StrAssign、串比较StrCompare、求串长StrLength、串联接Concat以及求子串SubString 等5种操作构成串类型的最小操作子集。即：这些操作不可能利用其他串操作来实现，反之，其他巾操作（除串清除c后田山和串销毁Destroystring外）均可在这个最小操作子集上实现
例如，可利用判等、求串长和求子串等操作实现定位函数Ind“〈s，T，p。$）。算法的基本思想为：在主串S中取从第的初值为p。0个字符起、长度和串T相等的子串和申 T比较，若相等，则求得函数值为吓否则值增1直至中S中不存在和申f相等的子屮为止。如算法4，1所示
int Index（，让ri的S，S上r刂T，int PO〈
T为非空串。若主申s中第凶白个字符之后存在与T'相等的子串，
／/则返回第一个这样的子串在$中的位置，否则返回0 (pos >的（
n SErLength(的；m 当StrLength( T）； ，POS；
*hiLe（< n一+的{
SubSt.ring（引山，S. i? m); 过(StrCompare(sub,T)！0）
else return i； 学返回子串在主串中的位置 }／7 while
return山 s中不存在与相等的子串 Index
法4 ]
串的表小和实现
如果在程序设计语言中，串只是作为输人或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数伯处理的程序中，串也以变量的形式出现
串有3种机内表示方法，分别介绍如下。
4．2．1定长顺序存储表示
类似于线性表的顺序存储结构．用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区．则可用定长数组如下描述之。
．串的定长顶序存储表小
# define MAX$TRLEN 2 5 5 //用户可在25 5以内定义最大串长
typedef ungigned char十] 0号单元存放串的长度
串的实际长度可在这预定义长度的范围内随意，超过预定义长度的串值则被舍去，称之为 “截断"。对串长有两种表示方法；一是如上述定义描述的那样，以下标为0的数组分量存放串的实际长度，如PASCAL语言中的串类型采用这种表示方法；二是在串值后面加 ，个不计人串长的结束标记字符，如在有的c语言中以“ \ 0。表示串值的终结。此时的串长为隐含值，显然不便于进行某些串操作。
在这种存储结构表示时如何实现串的操作，下面以串联接和求子串为例讨论之。
1．串联接C（'n “ t（& T，引，S2）
假设Sl、和T都是s& ring型的申变量，且串T是由串Sl联结串S2得到的，即串T的值的前一段和串Sl的值相等，串T的值的后一段和串S?的值相等，则只要进行相应的“串值复制。操作即可，只是需按前述约定，对超长部分实施“截断"操作。基于串 SI和S?长度的不同情况，串“1值的产生可能有如下3种情况：0引L的+ S? @」以 MAXSTRLEN,如图（的所示，得到的串T是正确的结果；2）Sl 101<MAY STRI?EN而Sl[0J+S2[01>MAXSTRLEN，则将串的一部分截断，得到的串只包含串S2的一个子串，如图4，1佳）所示；3）SICOI—MAXSTRLEN'则得到的并非联接结果，而和串相等。上述算法描述如算法4，2所小。
Status Concat( &?T Ing引．SStr{ng S2）{
／'用T返回山和联接而成的新串“若未截断，则返回TR北，否则硼。
<：MAXSTRLEN) { 末截断
se（S了< MAYSTRSIZE) { 汐截断
．引@．冂= SICL瞓3用；
叶引0和1 ] MA%GTIRLEN《：莹0、卜IN一刂]；
TCDI MAXSTRLEN； 1」 FALSE；
01 e { 截断（仅取SD
MAXSTRLEN」 Sl [ 0．
MAXSTRLEN
7 3
uncut巛PALSZ
return uncut:；箅法图4．]串的联结操作Con翮t（T，Sl，S2）示意图
（到s1@〕+S2[0」<MAXSTRLEN；
（励SIC0j<MAXSTRE.EN曲引[明+52@〕>MAXSTRLEN'
(e) SCOI—MAXSTRI.EN
2．求子申SubString(& Sub.S,pos'Ien) 求子串的过程即为复制字符序列的过程，将串S中从第pos个字符开始长度为len的字符序列复制到串sub中。显然，本操作不会有需截断的情况，但有可能产生用户给出的参数不符合操作的初始条件，当参数非法时，返回ERROR.其算法描述如算法4．3所示。
Statue SubString( String &?$ub，55t四S，in上p05，上len) {
用subiB回串s的第p。s个字符起长度为1 “的子串“
其中,1<poss:StrLenqth(S)且0<1en<StrLenqth(S)一伊．卜．妊（pos < pos > S「的 len < 0卩len >明一凶9 + 1) ERROR；
SubCl.，Len] P05一U05 + len一]山
S勖[ 0」；len; return；
}// SubString
算法4，3
” 综十两个操作可见，在顺序存储结构中，实现串操作的原操作为“字符序列的复制操作的时间复杂度基丁复制的字符序列的长度。另一操作特点是，如果在操作中出现串值序列的长度超过上界MAXSTRLEN时，约定用截尾法处理，这种情况不仅在求联接串时可能发生，在串的其他操作中，如插入、置换等也可能发生。克服这个弊病惟有不限定串长的最大长度，即动态分配串值的存储空间。
4，2，2堆分配存储表示
这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在C语言中，存在一个称之为“堆”的自由存储区，并由c语言的动态分配函数ma№ co和free ( )来管理。利用函数ma№ CO为每个新产生的串分配一块实际串长所窬的仃储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时，为了以后处理方便，约定串长也作为存储结构的一部分。
彦 一中的堆分配存储表示
t耵? Btruet {
若是非空申．则按串长分配存储区，否则ch为，
int length; //串长度
} HStrinq;
这种存储结构表示时的串操作仍是基于“字符序列的复制"进行的。例如，串复制操作 strc。py（T，s）的实现算法是，若串T已存在，则先释放串T所占空间，当巾S不空时，首先为申T分配大小和串s长度相等的存储空间，然后将串S的值复制到串T中；又如串插人操作Strlnsert（& s，p。“ T〕的实现算法是，为巾S重新分配大小等于串S和长度之和的存储空间，然后进行串值复制，如算法4所示、
Statue Strln$ert( HString &?S，社凶ing的{
+ 1 ·在串s的第
for 0 S冂啦h一土> POS一1： 一i)为插人T而腾出位置
S. ch[土」；
S.chCpos- ]，pos十T, length- 2冂 T, ch[0 . . T. 1ength - 11 i //插人T
S.length + T. le叫上h '
return〔爪；
〉々Stringert
算法4，4
以上两种存储表示通常为高级程序设汁语訁所采用。由于堆分配存储结构的串既有顺序存储结构的特点，处理力便，操作中对串长又没有任何限制，更显灵活，因此在串处理的应用程序中也常被选用。以下所示为只含最小操作子集的HString串类型的模块说明
=的表示与实现= 一串的堆分配有储表示 typedef struct {
char x ch;
若是非空甲，则按申长分配存储区，否则ch为即
length；
彦串长度
}瞿；0' ingl
一基本操作的函数原型说明
Stetu$ StrA$$iqn (HString &.T, char，c了的；
//生成一个其值等于申常量ch“s的串T int 5trLength (HString S); 在返回的元个数，称为申的长度《 int St.rCotqpare(日30气四& HSt?ing
，女若s，则返回值00；若T，则诉回值：若弘《T，返回值《0
Statue (EL9trinq &；夕将S清为空串，并释放s所占空间。
St 0 Concat（HString &?T，引，HSEring $2）；／7用T返回由引和联接而成的新巾。
上? SubString (HString 9，PO心10D《
/7 1<POS<StrLength(S)且0 len rLe四（劬一POS + ]。 返回串s的第个字符起长度为恸、的子串。
、．基本操作的算法描述訛StrAssign(HString char chars) { 生成一个其值等于串常量c }旧rs的申T
(T,eh) free(T,ch) ; 释放T原有空间 for 0 = 0，0生chats；+ + i，c)： //求chars的长度辽0 i) {T. ch即L T. length el艹{ 妊（！(T.eh = (char）“11 0 sizeof(char)))) 玉t（0 E LO后嚨chl_0- 0一门亡“訇一土一囗叾 T. length
retun 0K；
· 76 ·
} // StrAssig-n
int.
return S, length;
? // StrLength
int StrCompare(HStrung S , H_String T) {return S. length-I, lengtk?u
} // $trCompare
Statu$ ClearString(HString {
{free(S. Ch) NULL; }
S. length return OK;
// ClearString
length) Bizeof(chas)
(OVERFLOW)
T. ch[0. lenqt:h— ST. chC0, . S], length — 11;
T. length = SL length + $2, length;
T, chCSl length. . T. length— = $2. cht(). . $2.
return OX
? // Concat
Statug len)
//
// — pos 1 0 if (pos < 1 len g. length — POS + L)
return ERROR
length leng
return OX i i/' ing
? 77 ?
4．2，3串的块链存储表示
和线性表的鲢式存储结构相类似，也可采用鲢表方式存储串值。山于串结构的特殊性一结构中的每个数据兀素是一个字符．则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放个字符，也可以存放多个字符。例如，图4.以a）是结大小为即每个结点存放，1个字符）的琏表，图4，2（b )是结点大小为I的链表。当结点大小大于1时，由于申长不一定是结点人小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上“ # ”或其他的非串值字符（通常“ # ”不属于串的字符集．是一个特殊的符号)O
00000 000到0 00河 ． 0
o能0的 0的
图上2串值的表存储方式
（结点大小，尸的表；（的结点大小为1的表
为了便于进行串的操作，当以锖表存储申值时，除头指针外还可附设一个尾指针指示蠻表中的最后一个结点，并给出当前串的长度。称如此定义的申存储结构为块链结构，说明如下：
-串的块存储表示
*define CEI?NKSI?"E甌〕 typedef struct Chu { ah．chtCHtJNKSIZE_li 社〖u Chunk、next；
可由用户宝义的块人小
凵
Chunk he d，上a； 串的头和尾指针 int Curle自： 串的当前长度
} LString《
由于在一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行联结樸作，但应注意联结时需处理第个串尾的无效字符
在式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率、在各种串的处理系统中．所处理的串往往很长或很多。例如，
本书的几百万个字符，情报资料的成千上万个条目。这要求我们考虑串值的存储密度。
存储密度可定义为
串值所占的存储位存储密度一实际分配的存储位 · 78 ·
显然，存储密度小（如结点人小为]时〕，运算处理方便，然血，存储占用量人。如果在串处理过程中需进行内、外存交换的话，则会因为内外存交换操作过多而影响处理的总效率“ 应该看到，串的字符集的大小也是一个重要因素。一般地，字符集小，则字符的机内编码就短，这也影响串值的存储方式的选取
串值的链式存储结构对某些串操作，如联接操作等有一定方便之处，但总的说来不如另外两种存储结构灵活，它占用存储量大且操作复杂。此外，串值在链式存储结构时串操作的实现和线性表孔链表存储结构中的操作类似，故在此不作详细讨论。
4，3串的模式匹配算法
4，3，1求子串位置的定位函數Ind“（S，T , pos)
子串的定位操作常称做串的模式匹配（其中T被称为模式串是各种串处理系统中最重要的操作之一。在4．1节中曾借用申的其他基本操作给出了定位函数的一种算法。根据算法4．1的基本思想，采用定长顺序存储结构，可以写出不依赖于其他串操作的匹配算法，如算法4. 5所示。
int Index( SStrinq S，SStrinq { pos) {
返回子申T在主串s中第p“个字符之后的位置若不存在，则数值为0。
其中非空
whilo（i《=斗的& & j：TC.OI!) {
T的0 { +4i; “六}继续比较后继字符
el們{ = i一j + 2； 指针后退重新开始匹配
0 > T区巾 return i一T〔明衤 0100 return 0，
0 Index
算法4．5
在算法4，5的函数过程中，分别利用计数指针i和j指示主串S和模式串T中当前正待比较的字符位置。算法的基本思想是：从主串s的第pos个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符，否则从主申的下一个字符起再重新和模式的字符比较之。依次类推，直至模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功，函数值为和模式T中第一个字符相等的字符在主串S中的序号，否则称匹配不成功，吆数值为零。图4．3展示了模式T一' abcac '和主串S的匹配过程（p酥= l)6
算法4．5的匹配过程易于理解，且在某些应用场合，如文本编辑等，效率也较高，例如，在检查模式TING '是否存在于下列主串中时
'A STRING SEARCHING EXAMPLE CONSISTING OF SIMPLE TEXT
上述算法中的w田LE循环次数（即进行单个字符比较的次数）为41，恰好为（Ind“十T
· 79 ·
一1 0一4这就是说，除了仁串中呈黑体的1个字符．每个字符比较了两次以外．其他字符均只和模式进行一次比较。在这种情况下，此算法的时间复杂度为000一。其中 ”和冽分别为主串和模式的长度、然而，在有些情况
下，该算法的效率却很低。例如，当模式串为 ' 000000旧'，而主串为訇Q0000C〔用000000COGOCOQOC000 0000000000000000000000000g时．由丁模式中前7个字符均为“ 0 ”，又，主串中前52个字符均为“ 0 ”，每趟比较都在模式的最后一个字符出现不等，此时需将指针回溯到1一6的置上，并从模式的第一个字符开始重新比较，整个匹配过程中指针i需回溯45次，则 WH比E循环次数为8 (index m）。可见，算法 4．5在最坏情况下的时间复杂度为00“。这种情况在只有0、1两种字符的文本串处理中经常出现，因为在主串中可能存在多个和模式串“部分匹配”的了
第 匹配 凹a b亡a〕b
禹丿亠3
第二迅些配 b a b c a b c a c b a b
第二適匹配 彐b a b c到b圹a〔b a b b C C
第四耥匹闱 0 b b c a b《d c b a b
第五黽匹配 b a b c H b c d c b b
串，因而引起指针i的多次回溯。国串可以用在许多 第六匹配 a 5 应用之中。比如，一些计算机的图形显示就是把画面
表小为一个01串，一贝书就是一个几百万个0和1组 图4.3算法4，5的匹配过程成的串。在二进位计算机上实际处理的都是01串·
一个字符的ASCII码也可以看成是8个二进位的时串。包括汉字存储在计算机中处理时也是作为一个国串和其他的字符串一样看待。因此在下一节，我们将介绍另一种较好的模式匹配算法。
4．3．2模式匹配的一种改进箅法
图4．4改进铎法的匹配过程示例
第三趟的匹配中，当 7 一5 比较不等时，又从》一[孬一1重新丌始比然 经仔细观察可发觋·在i一4
这种改进算法是D. E. Knuth与v. R. Pratt和J. H. Morris同时发现的、因此人们称它为克努特一莫里斯一普拉特操作（简称为KMP算法）。此算法可以在00十”D的时间数量级上完成申的模式匹配操作。其改 a b 进在于：每当一匹配过程中出现字符比较不等时，不需回溯i指针，而是利用升b 已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续 =门 进行比较。下面先从具体例子看起。
a b
回顾图4．3中的匹配过程示例，在忄0 6 = 、丿 字符
较。 后，
和丿一I辑一5和j一[以及i一6和丿一I这騭次比较都是不必进行的。因为从第三部分匹配的结果就可得出，主串中第4、5和6个字符必然是、b '、'和％气即模式串中第 2、3 和4个字符)O因为模式中的第一个字符是，因此它无需再和这3个字符进行比较，而仅需将模式向右滑动3个字符的位置继续进行7孬一2时的字符比较即可。同理．在第一匹配中出现字符不等时，仅需将模式向右移动二个字符的位置续进行一30一] 时的字符比较。由此，在整个些配的过程中指针没有回溯．如图1. t所示。
现在讨论一般情况。假设主串为气，”．，《，模式串为孕是，从上例的分析咧 ，为了实现改进算法，需妥解决下述回题：当匹配过程中产生“失配”（即50）时，模式串“向右滑动”可行的距离多远，换句话说，当主串中第`个字符与模式中第丿个字符“失配”（即比较不等）时，主串中第字符0指针小回溯〕应与模式中哪个字符再比较？
假没此时应与馍式中第枞差<刀个字符继续比较，则模式中前力一1个字符的了串必须满足下列关系式（4．2），且不可能有在下>叠满足下列关系式（4唧
0 “孕凵 5《刁5《吓．2
而已经得到的“部分匹配”的结果是，
一“ PFk12 “孕」5 0 i 2
由式（4一2）和式0一3）推得下列等式反之，若模式串中存在满足式0一4）的两个子串，则当匹配过程中，主串中第i个字符与模式中第个字符比较不等时，仅需将模式向右滑动至模式中第々个字符和主串中第个字符对齐，此时，模式中头一〕个字符的子串‰，“加一《必定与主申中第i个字符之前长度为一1的子串$。“ $。- “，5一'相等，山此，匹配仅需从模式中第个字符与主串中第i个字符比较起继续进行。
若令“忄刀一差，则胛、r的弓表明当模式中第j个字符与主串中相应字符“失配"时，在模式中需重新和主串中该字符进行比较的字符的位置。山此可引出模式串的“到
数的定义：
0
丿且“泖凵当此集合不空时
]其他情况
山此定义可推出下列模式串的胛到函数值：
1 2 3 4 5 6 7 8
模式申
b自h e B C
0 ] 1 2 2 1 2
在求得模式的“到函数之后，匹配可如下进行：假设以指针i和丿分别指示主串和模式中正待比较的字符，令/的初值为鉀、，丿的初值为1。若在匹配过程中$产荡，则i和丿分别增1，否则，》不变，而退到月“ 0到的位置再比较，若相等，则指针各自增1，否贝0再退到下一个娌到值的位置，依次类推，直至下列两种可能：一种是丿退到某个到值（““ “～“门“ 0的时字符比较相等．则指针各自增1，继续进行匹配；另一种是j退到值为零（即模式的第一个字符“失配"），则此时需将模式继续向右滑动一个位置，即从主串的下一个字符]起和模式重新开始匹配。图4．5所示正是上述匹配过程的一个例子。 KMIJ算法如算法上6所小，它在形式上和算法4，5极为相似。不同之处仅在于：当 模式(垦卜刂1) “ b
与= 2，“和2〕= 1
主串模式
主串 a e a b A n b n b C c 8准b C
第四趟
式
图4．5利用模式的“到函数进行匹配的过程示例
匹配过程中产生“失配”时，指针不变，指针丿退回到“到与目所指示的位置上重新进行比较，并且当指针丿退至零时，指钅0和指针丿需同时增1。即若主串的第i个字符和模式的第1个字符不等，应从主串的第袢1个字符起重新进行匹配
{流Index KMP(SSering六SString {武动{
汐'利用摸式串T的n以上函数求T在主串S中第p“个字符之后的位置的
p算法。其中,T非空00p0 飞湖《r四山（，
o和stil 。{ “《“ j汐继续比较后继字符
el $0
nextC3j；
，/模式串向右移动
return i匹配成功
算法4．6
KMP算法是在己知模式申的胛冠函数值的基础上执行的，那么，如何求得模式串的 “到函数值呢？
从上述讨论．可见，此函数值仅取决于模式串本身而和相匹配的主串无关。我们可从分析其定义出发用递推的方法求得“河函数值。
由定义得知
0 设靛“比刀一差，这表明在模式串中存在下列关系
（4一7）其中为满足1 < <丿的某个值，并且不可能存在>满足等式（耘7 此时
[丿+ 0？可能有两种情况，
· 82 ·
(1)若加一仍，则表明在模式串中
0．8）
并且不可能存在>差满足等式（4一8），这就是说”“正丿+ 1〕一+ 1，即
（4一9冫（2）若，则表明在模式串中此时可把求到函数值的问题看成是一个模式匹配的问题，整个模式串既是主串又是模式串，而当前在匹配的过程中，己有一“一，一“ 2一，“，户0一一1，则当时应将模式向右滑动至以模式中的第” “的个字符和主串中的第丿个字符相比较。若 “到《明：，且角一枞，则说明在主串中第丿十1个字符之前存在一个长度为々'（即河以〕）的最长子串，和模式串中从首字符起长度为的子串相等，即
（4刁0）
这就是说胛到0十0一+ 1即 nextlj十1」一“以」+ 1
o．11)
同理，若关扒，则将模式继续向右滑动直至将模式中第准以0个字符和虍，对齐，，依次类推，直至和模式中某个字符匹配成功或者不存在任何々气1 <々<刀满足等式（4一10），则
“ 0 + 1」 （4．1 2）
例如：图4．6中的模式串，己求得前6个字符的娌“函数值，现求“对17丰因为
一3，又然关/' 3，则比较和/因为”“正3」01），这相当于将子串模式向右滑动。
'“
法，如算法4．6所示心
（n b到
void get- next(SString社0 {
图4．6漠式串的胛到数值
由于扒：/：仍，而且” “忄0一0，所以“霍7 ]一1，而因1 2 3 1 5 6 为炻一，则”“生8〕：2。 模式a b a a b c 根据上述分析所得结果（式（4一6）、@．9）、（4一(1)和
（伺2） ） ， 仿照 KMP 算法 ， 可得到求 “酲函数值的算 的] 0 1 1 2 2 3
//求模式串的ne函数值并存人数组ne。while 0 <了的）{= next(到；
} // get-next
算法4 7
算法4．7的时间复杂度为0恸）。通常，模式串的长度m比主串的长度”要小得多，因此，对整个匹配算法来说，所增加的这点时间是值得的。
最后，要说明两点：
o ） 虽然算法 4． 5 的时间复杂度是 00“ ） ， 但在一般情况下 ， 其实际的执行时间近
· 83
似于0（“一m）．因此至今仍被采用。KM P算法仅当模式与主串之间存在许多“部分匹配”的情况下才显得比算法1．5决得多。但是KMP算法的最人特点是指示主串的指针不需回溯，整个匹配过穆中．刘主串仅需从头至尾扫描一，这对处理从外设输人的宠大文件很有效，可以边i卖人边匹配．而无需回头重读
nextvalCj]
（前面定义的“丞数在某些情况下尚有缺陷。例如模式‰ a口口犷在和主串亳配时，当?一4，丿一4时chC4〕# t，山[ 4 ]，由“「了的指示还需进行一1、丿一1等3次比较。1 2 3 4 5
实际上，因为模式中第1、2、3个字符和第4个
字符都相等，因此不需要冉和主串中第1个字0 1 2 3 1 符相比较，而可以将模式一气向右滑动4个字
符的位置直接进行5刂：1时的字符比较。这就是说，若按上述定义得到““ [月一私而模式中一狲，则当主串中字符5，和比较不等时，不需要再和扒进行比较，而直接和进行比较，换句话说，此时的到[刀应和娌I和相同。由此可得计算“到函数修正值的算法如算法4，8所示。此时匹配算法不变。
void get. nextval（Seqtrinq T，int〔{ 求模式串T的next函数修正值并存人数组
n al〔0
while 0 < T〔明）{01s0 j =
》get nextva!
算法4，8
4．4串操作应用举例
4．40文本编辑
文本编辑程序是一个面向用户的系统服务程序，广泛用于源程序的输人和修改．甚用于报刊和书籍的编辑排版以及办公室的公文书信的起草和润色。文本编辑的实质是修改字符数据的形式或格式。虽然各种文本编辑程序的功能强弱不同，但是其基本操作是一致的，一般都包括串的查找，插人和删除等基本操作、
为了编辑的方便，用户可以利用换页符和换行符把文本划分为若干页，每页有若干
（当然，也可不分页而把文件接划成若干行)6我们可以把文本看成是一个字符串，称为文本串。页则是文本串的子串．行又是页的子串比如有下列一段源程序
nain 0 {
float，山a
scanf 0 f．俨．&山& b 0 a > b max =山 我们可以把此程序看成是个文本串。输人到内存后如图7所示。图中“，」"为换行符。
201
00
00000
-
00000000
b
b
b
图10文小格式示例
为了管理文本串的页和行，在进人文本编辑的时候，编輯程序先为文本串建立相应的页表和行表，即建立各子串的存储映像。页表的每一项给出了页号和该页的起始行号。而行表的每一项则指示每一行的行号、起始地址和该行子串的长度。假设图4，7所示文本串只占一页，且起始行号为100，则该文本串的行表如图4．8所示。 2国 8
1国 209
10 2 226
] 0 3 250
] 04
105 282 2图上8图4．7所示文本申的行表
文本编辑程序中设立页指针、行指针和字符指针，分别指示当前操作的页、行和字符。如果在某行内插人或删除若干字符，则要修改行表中该行的长度。若该行的长度超出了分配给它的存储空间，则要为该行重新分配存储空间，同时还要修改该行的起始位置。如果要插人或删除一行，就要涉及行表的插人或删除。若被删除的行是所在页的起始行，则还要修改页表中相应页的起始行号（修改为下一行的行号）。为了查找方便，行农是按行号递增顺序存储的，因此，对行表进行的庙人或删除运算需移动操作位置以后的全部表项。页表的维护与行表类似，在此不再赘述。由于访问是以页表和行表作为索引的，所以在作行和页的删除操作时，可以只对行表和页表作相应的修改，不必删除所涉及的字符。这可以节省不少时间
以上概述了文本编辑程序中的基本操作。其具体的算法，读者可在学习本章之后自行编写。
4园，2建立词索引表
信息检索是计算机应用的重要领域之一。由于信息检索的主要操作是在大量的存放在磁盘上的信息中查询一个特定的信息，为了提高查询效率，一个重要的问题是建、好的索引系统。例如我们在1. 1节中提到过的图书馆书目检索系统中有3张索引表，分别可按书名、作者名和分类号编排。在实际系统中，按书名检索并不方便，因为很多内容相似的书籍其书名不一定相同。因此较好的办法是建立“书名关键词索引”。
例如，与图4．9（a》中书目相应的关键词索引表如图、L 9 ( b)所示，读者很容易从关键词索引表中查询到他所感兴趣的书上为了便于查洵，可设定此索引表为按词典有序的线性表。下面要讨论的是如何从书目文件生成这个有序词表。 书号 关键词 书号索引
0 gorithm.s analysis CO田putev
design fundamentals introduction numerical
034
034，05占06 /
005，031
@5，国0，醴3
0 3
0 2 3
o，050
05 0，0 6 7
《川5，m0m23
5 natH Structures
010 Introduction 10 Data Structures
3 Fundamentals Of
034 Thi，“ n and Analysis 00 ， 、Olnp丽“ Algorithms
050 Introduction to Numerical Analysis
067 Numerical Analysis
图4、9书目文件及其关词索引表
(d)书目文件，(b)关犍词索引表
重复下列操作直至文件结束：
( 1)从书目文件中读人一个书目串；
（2） 从书目串中提取所有关键词插人词表；
（3） 对词表中的每一个关键词，在索引表中进行查找并作相应的插入操作。
为识别从书名申中分离出来的单词是否是关键词，需要一张常用i司表（在英文书名中的“常用词”指的是诸如“ an ” 、"the"等词顺序扫描书名串，首先分离单词，然后查找常用词表，若不和表中任一同相等，则为关键词，插入临时存放关键词的词表中。
在索引表中查洵关键词时可能出现两种情况：其一是索引表上已有此关键词的索引项，只要在该项中插入书号索引即可；其二是荪在索引表中插人此关键词的索引项，插人应按字典有序原则进行。下面就重点讨论这第三个操作的具体实觋。
首先设定数据结构
词表为线性表，只存放一本书的书名中若千关词，其数量有限，则采用顺序存储结构即可，其中每个词是一个字符串。
索引表为有序表，虽是动态生成，在生成过程中需频繁进行插人操作，但考虑索引表
．86 ·
主要为查找用．为了提高查找效率（采用第九章中将讨论的折半查找），宜采用顺序存储结构；表中每个索引项包含两个内容：其一是关键词，因索引表为常驻结构．则应考虑节省存储，采用堆分配存储表示的串类型：其0是书号索引．山十号索引是在索引表的生成过程中逐个插人，目不同关啭词的书号索引个数不等，甚至可能相差很多，则宜采用链表结构的线性表。
$define MaxSoqkNum ] 0G0假设只对10本阝建索引表
#define(*define) MaxLineLe(MaxXeyNu-m)n 500(2500)书目串的最人长度(索引表的最大容量)
*define0了urn 10 词表的最大容量
typedef
struct {
char忡此〔]；字符串的数组 int lastl词表的长度 } RordListfype蕃词表类型（顺序表） typedef int Elen1Type;定义链表的数据元家类型为整型（书号类型〕
typedef 3tsvct {
HString key:
关腱词
LinkList bnol ist.J
才存放书号索引的鱼表
}行T俨； typedef ?Eruct {
过素引@头型
IdxTermType + 1； int
} IdxListType；
主要变
／/索引表类型（有序表）
Ch，juf；
丿书囗串缓冲区
WorclLi5ETvpe wdli#；词表
／/基本操作 void InitidxLi$t (IdxLi6tType & idxl ist）《汐初始化操作，置索引表i酝祉为空表，且在妯i叱让[ 0」设一空申 void GeeLine（FILE f月
//从文件t《读人一个书目信息到书目串缓冲区f
void ExtracLKey60fd (ElemType； 从buf中提取书名关词到词表lis匕书号存人bn。
Status InsldxLigt:（IdKListType & idxl这0 ElemType bno)： 将书号为b的书名关键词按词典顺序插人索引表土d又li void PutText（IdxLtstType id 19t）； 将生成的索引表血li就输出到文件g
void main() { //主函数 if（f：0 n〔（" BookEnfC)， if (g：0证("Bookldx?txt
InltLdxList (idxlist)： while ( ! feof (f) ) {
Get-Line〔f ) ;
Extract-Key?ord（BookNO〕
//初始化索引表×li毓为空表
从文件f读人一个书目信息到buf
，歹从b“提取关思词到词表．书号存人B。。k
· 87 ·
InsldxLxst ( BookN0)
PubTexE (q, id*list,) :
// main
return 0K;
// Insert1dxList
4. 10
4. 11 , 4, 12 , 4. 13 4. 14
void GetWord ( int i, IIString & wd) { p = (wdlist. if-em +
(wd, p)
// Get?ord
4. 11
int Locate (IdxI,ist.Type *st, HString wd, Boolean &.b) { for ( i ' idxlisr. J ;
( 'd*1igE itemri_ key, wd) ) return return i +
4. 12
? 88 ?
void EnsertNeBKey ( int i. StrType wd) {4 13
SLeLug ( IdxVuiystTyp(ù &idxlist, int' ( ! MakeNode ( p . bno) ) return ERROR; Appand ( idxlist. return OK;
? // InsertBQ0k
4. 14? 89 ?
第5章数组和广义表
前几章讨论的线性结构中的数元素都是非结构的原子类型，虍素的值是不冉分解的。本章讨论的两种数据结构一一数组和广义表可以看成是线姓表在下述含义上的扩展：表中的数据元素本身也是一个数据结构。
数组是读者已经很熟悉的一种数据类型，几手所有的程序设计语言都把数组类型设定为固有类型。本章以抽象数据类型的形式讨论数组的定义和实现，使读者加深对数组类型的理解
5口数组的定义
类似于线性表，抽象数憔类型数组可形式地定义为：
ADT Array；
数据对象
@ >脚称为数组的维数是数组第维的长度，
:i,是数组元素的第维下标两“《EletnSet)
据关系田=，田，，
00 <玩“ 1，10k0刂0 i，基本操作：
InitArray(&A. n. boundl， “，boundn)
操结果：若维数n和各维长度合法，则构造相应的数组A，并返回0狐 DestroyArray( &的
操作结果：毁数组A
Value(), be, indexl． ．，Indexn)
朝始条件逮是n维数组．e为元素变量，后是n个下标值：
操作结果！若各小标不超界，则e赋佰为所指定的^的元素值，并返回0& Assign(&?.鳐indexi， 吓indexn）
初始条件：A是n维数组，e为元素变量．陆后是n个下标值
操作结果諾下标不超界，则将e的值赋给所指定的的元素，并返回0 } AM' Array
．
这是一个c语自风格的定义。从匕述定义可见，n维数组中含有IT个数据元素，
每个元素都受着个关系的约束。在每个关系中，元素 丿（0 < <一2）都有一个直接后继元素“因此．就其单个关系而言．个关系仍是线性关系。和线性表一样、所有的数据元素都必须属于同．数据类型。数组中的每个数据元素都对应于．组下标0，．，痍），每个下标的取值范围是0 `0， 1造称为第维的长度0一1.2，
然．当殍一1时删维数组就退化为定长的线性表。反之“维数组也可以看成是线性表的推广。由此，我们也可以从另一个角度来定义“维数组。
我们可以把一维数组看成是这样一个定长线性表：它的每个数据元素也是，个定长线性表。例如。图5，1（的所示是一个一维数组·以忉行列的矩阵形式表小。它可以看成是一个线性表
= m一1或月一1 )
其中每个数据元素丐是一个列向量形式的线性表（如图5湖（b）所示）或者是一个行向量形式的线性表（如图5，1（c）所示）。在C语言中，一个二维数组类型可以定义为其分量类型为一维数组类型的一维数组类型，也就是说，
typedef ElemType Array2[rnlCnl；
等价十
typeclef ElemType Arrayltn]； typedef Arrayl Array2Cml；
同理，一个”维数组类型可以定义为其数据元素为烈一1维数组类型的一维数组类型。图。0二维数组图例
（的矩阵形式表示； （0列向耐的一维数组苇（的行向译的一维数fll
数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。
5．2数组的顺序表示和实现
由于数组一般不作插人或删除操作，也就是说，一旦建立了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组是自然的
由于存储单元是一维的结构，而数组是个多维的结构，则用一组连续存储单元存放数组的数据元素就有个次序约定问题。例如图5 ]（钔的一维数组可以看成如冬5．l(c）的一维数组，也可看成如图5．]（的的一维数组。对应地，对一《维数组可有两种存储方式：种以列序为主序（co扁mn major ord “）的存储方式，如图5．2（的所示；一种是以行序为主序( row major ord “）的存储方式，如图5．2（b）所示。在扩展BASIC、PL/1、COBOL PASCA上和C语言中，用的都是以行序为主序的存储结构，而在FORTRAN语言中，用的是以列序为主序的存储结构，
LOC飞曱一LOC@0的
LOC'@胄下LOC( 0L（X'(A卩》；L伙2@的
LOC@望上LOC@000L冲凸0，（℃。囝
{（在0疒
图5．2《维数组的两种存储方式
（钔以列序为主序；(b)以行序为主序
由此，对于数组，一臧规定了它的维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。下面仅用以行序为主序的存储结构为例予以说明
假设每个数据元素占L个存储单丿L，则二维数组、A中任一元素与的存储位置可山下式确定
仁0C0．/）= LOC@，0)十仂2 ×凵一刀L （5一D 式中，LOC(i，刀是‰的存储位置；LOC（0，0）是“的存储位置，即二维数组，A的起始存储位置，亦称为基地址或基址。
将式（5一l )推广到一般况，可得到维数组的数据元素存储位置的计算公式： · 92
I?C)C(Y I，丿。“
可缩写成
其中
式（5一2）称为殍维数组的映像函数。容易看出，数组元素的存储位置是其下标的线性函数，一旦确定了数组的各维的长度，。就是常数。由于计算各个兀素存储位置的时间相等，所以存取数组中任一元素的时间也相等。我们称具有这一特点的存储结构为随机存储结构。
下面是数组的顺序存储表示和实现
数组的耻序存储表示
# include《stdarg．h?'
标准头文件，提供宏va- ““以“一arq和“ end.
丿用干存取@长参数表
# def玉MAX ARRAY. DIM struct {
8
假设数组维数的最大值为8
ElemType base；
／7数组元素基址，由InitArray分配
土n上 dim；
数组维数
int. ．u
数组维界基址，由IniLAtray分配
int 00f的刁nt下；
数组映像数常量基址，山InitArray分配
} Array；
一基本撥作的数原型明
Statu? InitArray(Array int
／7若维数dim和随后的各维长度合法，则构造相应的数组并返回。
S七u过DestroyArray(Array & A) ' 销毁数组A。
Status，FlernType &?e?．．'）；
，学A是n维数组，。为元素变量，随后是n个下标值。
若各下际不超界·则e赋值为所指定的的元素值．并返回，
Assign(Array & ElemType e、
，//A是n维数组为兀素变嶺．随后是n个下标值，
///若下标不卸界．则将e的值賦给所指定的的元素，并返回0K，
“基举操作的算法描述．．
Status InitArray( Array & A．int dim，
若维数和各维长度合法，则构相@的数组八，并返回0K 计（d新直< ]《dim 、MM- ARRAY. DIP,) return F?RROR： ．d im “ d愴；
A.bounds= ()n匕）H00（d sizeof(?nt) ) ; if（！bounds) exit(OVER-FL'OR)；
。若各维长度合法，则存人〕ds．并求出A的元素总数引皂al elemtotal
va- start(ap. dim) for ( 1 = 0; i) {
A. va arq(ap, if (A. bou?lds?- i: return UNDERFLO"I; elecatotal * A. bounds,- ;
va_ end(ap) Statua DesbroyArray(Array CA) {
NiJL1.;ind va- arg(ap. iDt:) ;
if ( ind<O A_ bounds[il) return ; off + = A. ind;
va start(ap. e) $ if ( (result Locate(A. ap. O) return result; e = * (A. bage + off) ; return OK;
Eu自?ggign(Array &A? ElemType
A是n维数组，e为元累变量，随后是n个下标值
若下标不超界，则将e的值斌给所指定的A的元素，并返回，
va start(ap?
if气了esu]上= Locate(A，，Off月< 0）江n result ;
(A.base+off)《； return 0卜
5．3矩阵的压缩存储
矩阵是很多科学与工程计算问题中研究的数学对象。在此，我们感兴趣的不是矩阵本身，而是如何存储矩阵的元从而使矩阵的各种运算能有效地进行。
通常，用高级语言编制程序时，都是用二维数组来存储矩阵元“有的程序设计语言中还提供了各种矩阵运算，用户使用时都很方便。
然而，在数值分析中经常出现一些阶数很高的矩阵，同时在矩阵中有许多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。所谓压缩存储是指：为多个值相同的元只分配一个存储空间；对零元不分配空间。
假若值相同的元素或者零元素在矩阵中的分布有一定规律，则我们称此类矩阵为特殊矩阵；反之，称为稀硫矩阵。下面分别讨论它们的压缩存储。
5．3．1特殊矩阵
若阶矩阵/\中的元满足下述性质则称为“阶对称矩阵。
对于对称矩阵，我们可以为每一对对称元分配一个存储空间，则可个元压缩存储到” + 1) / 2个元的空间中。不失一般性，我们可以行序为主序存储其下三角（包括对角线）中的兀。
假设以一维数组sa勖十l ) ' 2．]作为阶对称矩阵A的存储结构，则以]和矩阵元与之间存在着一一对应的关系：
（吓3）
对于任意给定一组下标0，）·均可在中找到矩阵元‰，反之．对所有的差一0，]，2，
+ D 一1，都能确定陬[ 0中的元在矩阵中的位置（，，刀。由此，称“勖十1月2 ]为，； 2
阶对称矩阵A的压缩存储（见图5．3）。
9 5 图5，3对厙阵的压縮存储
这种压缩存储的力法同样也适用于三角矩阵。所谓下（十）三角厙阵是指矩阵的上（下厂《角（不包括对角线〕中的丿L均为常数c或零的阶矩阵。则除了和对称矩阵一样，只存储其下00二角中的元之外．再加一个存储常数c的存储空间即可。
在数值分析中经常出现的还有另，类特殊矩阵是对角矩阵。在这种矩阵中，所有的非零元都集中在以主对角线为中心的带状区域中。即除了主对角线上和直接在对角线上、下方若干条对角线上的元之外，所有其他的元皆为零。如图50所示。对这种矩阵，我们亦可按某个原则（或以行为主，或以对角线的顺序）将其压缩存储到一维数组》
条对角线
图5．4对角矩阵
（动一般情形；（三对角矩阵
在所有这些我们统称为特殊矩阵的矩阵中，非零元的分布都有一个明显的规律，从而我们都可将其压缩存储到一维数组中，并找到每个非零元在一维数组中的对应关系。
然而，在实际应用中我们还经常会遇到另一类矩阵，其非零元较零元少，且分布没有一定规律，我们称之为稀疏矩阵。这类矩阵的压缩存储就要比特殊矩阵复杂。这就是下一节我们要讨论的问题。
5．3．2稀疏矩阵
什么是稀疏矩阵？人们无法给出确切的定义，它只是一个凭人们的直觉来了解的概念。假设在m ×烈的矩阵中誦'个元素不为零。令 ，称为矩阵的稀琉因子
涌常认为< 0．05时称为稀疏矩阵。矩阵运算的种类很多，在下列抽象数据类型稀疏矩阵的定义中．只列举了几种常见的运算。
抽象数据类型稀疏矩阵的定义如下！
耵SparseMatzix {
数据对象：D；0到，
m和〕分别称为矩阵的行数和列数}
· 9 6
据关系：R船，Col }基本操作．
CreateSMatrix(&M)；
操作结果：创建稀疏炬阵 DestroySMaLr1%(&M)；
初始条件；稀疏矩存在；操作结果：销毁稀疏矩阵 PrintSMatrix(M)J
初始条：稀疏矩阵凹存在操作结果：输出稀疏小阵 CopySMatrix(), &?T)；
初始条件：稀疏年阵M存在，
操作结果：山稀疏矩阵M复制得到T “ AddSNatrix(). N. &-Q)；
初始条件：稀琉矩阵M与的行数和列数对应相等。
操作结果：求稀疏矩阵的和0 =卜I+N。
S社t鞭诽ri以六N，&．；
初始条件：稀疏庫阵M与N的行数和列数对应相等。操作结果《求稀琉矩阵的差0：．N。
MultSMatri8(M，N，& 0）；
初始条件《稀疏年阵M的列数等于N的行数。
操作结果：求稀疏庫阵乘积Q訂M × N。
Tran$poseSMat.r ix(). &的．初始条件：稀斑阵凹存在。
操作结果：求稀硫年阵卜，的转置矩阵T。
}禹r SparseMaErix
如何进行稀疏矩阵的压缩存储呢？
按照压缩存储的概念，只存储稀疏矩阵的非零兀。因此，除了存储非零元的值之外，还必须同时记下它所在行和列的位置（0）。反之，一个三元组（0以）惟一确定了矩阵 A的一个非零元由此，稀疏矩阵可由表示非零元的三元组及其行列数惟一确定。例如．下列三元组表
巛1，2 , 1 2），0，3，的，（3口． 3（3，6，1 4珧（4，3，2 4），0，2，1 8），（6，1，1 5 ) .
加6，7）这一对新、列值便可作为图5．5中矩阵M的另一种描述。而由上述三元组表的不同表示方法可引出稀疏矩阵不同的压缩存储方法。
M
· 9 7
二元组顺序表
假设以顺序存储结构来表示三元组表，则可得稀疏矩阵的一种压缩存储方式一们称之为三元组顺序表。
一稀疏阵的三元组顺序表存储表示
#detine MAXSIZE 125的'假设IF零元个数的最人值为] 25佣 typedef struct（
i，j： //该非零元的行下标和列下标 EleJnType
} Triple;
typedof *truct
Triple datalMAXSIZE + ] ] 0/非零元元组表，「0 ]未用
int mu. nu， 矩阵的行数、列数和非零元个数 }fSMatrix;
在此，data域中表示非零元的三元组是以行序为主序顺序排列的，从下面的讨论中读者容易看出这样做将有利於进行某些矩阵运算。下面将讨论在这种压缩存储结构一卜如何实现矩阵的转置运算。
转置运算是一种最简单的矩阵运算。对于一个狲“的矩阵M，它的转置年阵T是一个” ×忉的矩阵，且T(i，丿）--M()，i)，] ”，] <i<mo例如，图5，5中的矩阵M和 T互为转置矩阵。
显然，一个稀疏矩阵的转置矩阵仍然是稀疏矩阵。假设和是TSMatrix型的变量，分别表示矩阵M和T。那么，如何由在得到呢？
从分析和6之间的差异可见只要做到：（将矩阵的行列值相互交换；（2）将每个一元组中的下和丿相互调换；（3）重排三元组之间的次序便可实现矩阵的转置。前0条是容易做到的，关谊是如何实现第三条。即如何使b．ta中的三元组是以7、的行（M的列）为主序依次排列的
b. data
可以有两种处理方法：
( t )按照b．data中三元组的次序依次在a．data中找到相应的三元组进行转置。换句话说，按照矩阵M的列序来进行转置。为了找到M的每一列中所有的非零元素．需要对其三元组表a．data从第一行起整个扫描一遍，山于a．data是以M的行序为主序来存放每个非零元的岫此得到的恰是b. data应有的顺序。其具体算法描述如算法5彐所示
Status TransposeSMatrih(TSMat.rix卜1，TSMatrix &-T) {
用一元组表存储表示．求稀疏№阵凹的转置知阵
fo〖（C01 “ 1；C01 < nu；E+COI) for〈p二1；pe二生tui十十p）
if（dat pj j cot) {
T.dataLqJ. 1；M.datacp_l,： T.data「ql . j = dataLp
'T.datacq_l,《；生da「国
return劊‰
}夕TranspogeSMatrix 分析这个算法，主要的丁作是在p和的两重循环中完成的，故法的时间复杂度为0（nu．tu）@，即和M的列数和非零元的个数的乘积成正比。我们知道，一般炸阵的转置算法为一气0刂《row〕= M〔的w」「0：的；
其时间复杂度为O(mu><nu)o当非零元的个数山和tnu><nu同数量级时，算法5 1的时间复杂度就为0（m矿《“'）了（例如，假设在100》5加的矩阵中有000个非零元），虽然！节省了存储空间，但时间复杂度提高了，因此算法50仅适于的情况、
（2）按照a．data中三元组的次序进行转置，并将转置后的三元组置人心中恰当的位置。如果能预先确定年阵M中每一列（即T中每一行）的第一个非零元在b．da中应有的位置，那么在对a，da岫中的二：元组依次作转置时，使可直接放到b．data中恰当的位亂士去。为了确定这些位置，在转置前，应先求得M的每一列中非零元的个数，进而求得每列的第一个非零元在b. data中应有的位置
在此，需要附设num和cpot两个向量。num《表示矩阵M中第詞列中非零元的个数、cp可co刂指示M中第詞列的第一个非零元在b' data中的恰当位置。显然有
cpot「．1的
cp区00 cpot[col 0 + nurn[col 2 < col < a. nu
例如，对图5．5的矩阵M、num和cp。t的值如表5口所示
num coll在此，我们将M, nu n M,tv荀与成n。和山，以下同
· 99
这种转置方法称为快速转置，其算法如算法5．2所示。
Status $ [ Tc的poses凹atl后x('枷卜岳0过x M，TfiMaeriK & 0 { 采用0元组顺序表存储表示．求稀硫阵的置年阵
．0 = Y. T．nu生山．tu竺上山 if (T, tu i {
Ear (co] 一1；CO〕对nuc《+ C01冫」；0；
for性；；坛t': = M tu;十+ t丿 4卜nurnLM datalt」，到：求中每一列含非零元个数 cpot「0
，求弟col列中第一、引零元在data中的序号
for（001：；六001。000 Jiu; '0200（甲0的C01 =以0上C01一刂 for @《0 pc:、
001 =鞔data〔p．，i； q: 0p0 c01
i M. datal国．〕；:j = M.datacp-_i.辑 T，da上甴屺，e。datal_p_]. ei +十CO〕，忭是7 for
Z'妗匿n（〕K；
》，3MaErix
算法5，2
这个算法仅比前一个算法多用了两个辅助向量从时间上看，算法中有4个并列的单循环，循环次数分别为艹和tu，因而总的时间复杂度为0（艹十@。在M的非零元个数蜘和等数量级时．其时间复杂度为0（，n的《“丛和经典算法的时间复杂相同。
三元组顺序表又称有序的双下标法，它的特点是，非零元在表中按行序有序存储．因此便于进行依行顺序处理的矩阵运算。然而，若需按行号存取某一行的非零元，则需丛头开始进行查找
2、行逻辑铸接的顺序表
为了便于随帆存取任意一行的非零元，则需知道每一行的第一个非零兀在三元组表中的位置。为此，可将一于节快速转置矩阵的算法中创建的，指示“行”信息的辅助数组 cp。t固定在稀疏矩阵的存储结构中，称这种“带行链接信息”的三元组表为行逻辑鲢接的顺序表，其类型描述如下．
typedef struct（
Triple dataCMAXSi%E 0；
丿非元三元组表
int rposCMAXRC +的；
各行第一个非零元的位表
int
矩的行收、列数和非零元．1、数
} RLSMaErix：
在卜面讨论的两个稀疏矩阵相乘的例子中，容易看出这种表示方法的优越性'C将计算球。·的算法档改动下．也可以只占个向量空间．
两个矩阵相乘的经典算法也是大家所熟悉的。若设 Q亠M N
其中．M是”n x柘矩阵．N是叨00“矩阵当．：“时：
for气=吓1 < =司；+ +
for（-j二坛-j
Q「吲i ]；玉
for (k二]；nl；十k) 0 i ]「到叫畦k」．
此算法的时间复杂度是0恸00/ 0勖0。
当M和N是稀疏矩阵并用三元组表作存储结构时，就不能套用上述算法。假设M 和N分别为
N（5一5）
则Q M × N为
Q
它们的二元组M. data、N. data和Q. data分别为：
M. data N. data Q, data
那么如亻可从M和N求得0呢？
（1 )乘积矩阵Q中元素在经典算法中，不论MG,的和N@炉的值是否为零，都要进行一次乘法运算，而实际上，这两者有个值为零时，其乘积亦为零。因此，在对稀疏矩阵进行运算时，应免去这种无效操作，换句话说，为求Q的值．只需在M．da怊和N．data中找到相应的各对元素（即M， da中的j值和N．data中的；值相等的各对元素）相乘即可。
例如，M. datali」表示的矩阵元0，1，3）只要和N. datall ]表示的矩阵元（1，2，2）相乘；而M．证明表示的矩阵元0．4则不需和N中任何元素相乘，因为N．data中没有i为4的元素。由此可见，为了得到非零的乘积．只要对M，data「1, M，冂中的每个元
素0，々，M(i以月0您滌飞；m，] `々《猢），找到N，data中所有相应的元素巛，丿，N（々，丿月 0过在《m。，I 0000相車即国，为此需在N．da山中寻找厙阵N'中第々行的所有非零元。．自稀疏矩阵的石逻辑链接的顺序表中，N, rpos为我们提供了有关信息。例如，式
（5．的中的矩阵N的rpos值如表5，2所示：
表5，2矩阵的rpos值
2
2
4
rposcrow
3
并且，由于r四乩ro指示矩阵N的第r。w行中第一个非零元在N．data中的序号，则 rposCrow+ ? — l指示矩阵N'的第“行中最后个非零元在N. data中的序号。而最后一行中最后一个非零兀在N. data中的位置显然就是N.蜘了。
（2） 稀疏矩阵相乘的基本操作是：对于M中每个元素M. dataCpl (p= 1 , Z ? ??? ' M.
tu〕，找到N中所确满足条件M. datalpl. J—N. datatql. i的元素N. data[ql '求得M. data[pl. v和N. data[ql. v的乘积，而从式（5一6）得知，乘积矩阵Q中每个元索的值是个累和，这个乘枳M. data[pl \0《N．只是QWlLtil中的一部分。为便于操作，应对每个兀素设．累计和的变量，其初值为零，然后扫描数组M，求得相应兀素的乘积并累加到适当的求累计和的变量上。
（3） 两个稀疏矩阵相乘的乘积不一定是稀疏矩阵。反之，即使式0．6〉中每个分量值 M(i，的》《N以，刀不为零，其累加值i:]山也可能为零。因此乘积矩阵Q中的元素是否为非零元，只有在求得其加和后才能得知“山于0中元素的行号和M中元素的行号一致，又M中元素排列是以M的行序为主序的，山此可对Q进行逐行处理，先求得累月求和的中间结果（Q的一行），然后冉压缩存储到Q．data中去。
由此，两个稀疏矩阵相乘（Q一M × №的过程可大致描述如下：
o初始化；
（0是非零矩阵）{逐行求积
：M. mu; + + avow) { 丿丿处理M的每一行
CEemp[」：山 学累加器清零计算0中第行的积并存人№呷0柘将ctempl ]中非零元压缩存储到Q'data;
)// for arow
/ if
算法5．3是上述过程求精的结果
Stet" MultSMatrix( RLSMatt"ix，RLSMatrix N．RLSMatrix 0）{ 求矩阵乘积0 =渊× N，采用行逻辑甾接存储表小。
if（nu N. (u) return ERROR;
o ．mu．M. nu，N' Q' tu Q初始化出．耳N．№卜0)《 Q是非零矩阵
for (arow— 1；；+ drow) { 汐处理M的每一行
／/当前行各元素累加器清零Q、rpC'5 [ '0到；0就u + 1；
〕巨区州《．M、月甲：№了po司．啩0．0； elselfp=-M.tu+
for（p =印。缸卣到；E}<tp; ++p){汐对当行中每一个非零元 ro，dataLp ]， ／7找到对应元在N中的行号 if (brow < N.mu）t = №匚p05 [ bro“十l l i else { t = № tu + ]；}
for ()= N. rposLbrow-l.; 0十十q〕{
ecol；N. datacq：，的 乘积元素在Q中列号曰地：00了]寸；；的da「[，e，N. i中
o ／for q
'求得0中第cr。。行的非零元
for在C01 =〕；0亡01 <= 0，nu；+ + ccol) 汐'压缩存储该行非零元 if (ctemp[ccol])（
if（忄Q.tu 0 MAXSIZE) return ROR；
Q. datalQ.tu卜（ecol. ctemp[ccoll); if
} # for ro园
return；
7 Mul《00
算法5，3
分析上述算法的时间复杂度有如卜结果：累加器初始化的时间复杂度为 O(). mu?N. nu)，求Q的所有非零元的时间复杂度为0（M．tu >1 N, tu/N.的，进行压缩存储的时间复杂度为O(). nu），因此，总的时间复杂度就是()(M.《N. “ 4M.》《N．tu/N. nit])O
若M是m行，家列的稀疏矩阵，N是“行声列的稀疏矩阵，则M中非零元的个数
M以u一：／m × n，N中非零元的个数N，tu：60：n × p，此时算法5，3的时间复杂度就是0（阴× ×（1 + ” 6、，当饑< 0．05和< 0．卟及，/ < 1 000时，算法5．3的时间复杂度就相当于0（m ×脚，显然，这是个相当理想的结果。
如果事先能怙算出所求乘积矩阵Q不再是稀疏矩阵，则以二维数组表示Q，相乘的算法也就更简单了。
3．十字链表
当矩阵的非零元个数和位置在操作过程中变化较大时．就不宜采用顺序存储结构来表示三元组的线性表。例如，在作“将矩阵B加到矩阵，A上"的操作时，由于非零元的插人或删除将会引起A，data中兀素的移动。为此，对这种类型的矩阵，采用链式存锗结构表示三元组的线性表更为恰当。
在表中，每个非零元可用一个含五个域的结点表示，其中》0和酽3个域分别表示该非零元所在的行、列和非零兀的值，向右域right用以链接同一行中下一个非零元，向下域d。wn用以链接同、列中下一个非零元。同一行的非零元通过域链接成一个线性彘表，同一列的非零元通过down域链接成一个线性彘表，每个非零元既是某个行表中的一个结点，又是某个列表中的一个结点．整个矩阵构成了一个十字交叉的嵴表，故称这样的存储结构为十字链表．可用两个分别存储行链表的头指针和列表的头指针
1 03
fit)
5. 4
typedef *truct OLNode f int
F, I esoType w right, downi ) ()Link s rheaci. chead; CreateSMoLui%.
int rtm, no,
if (M) free(M) ; ? ?
return ;
}// CreateGMatrix OL
算法5 4
对于行列月有个非零元的稀疏矩阵，算法5以的执行时间为0（t x到一 max { m }，这是因为每建立一个非零元的结点时都要寻查它在行表和列表中的捱人位置，此算法对非零元输人的先后次序没任何要求。反之，若按以行序为主序的次序依次输人三元组，则可将建立十字链表的算法改写成(-)(t)数量级的0为非零元的个数）。
下面我们词论在十字毓表表示稀疏矩阵时，如何实现“旖矩阵月加到年阵丿\上”的运算。
两个矩阵相加和第2章中讨论的两个一儿多项式相加极为相似，所不同的是一元多项式中只有一个变元（即指数项），而矩阵中每个非零元有两个变几（行值和列值），每个结点既在行表中又在列表中，致使插人和删除时指钅f的修改稍为复杂，故需更多的辅助指针。
假设两个矩阵相加后的结果为／1'，则和矩阵，'中的非苓元a了只可能有3种情况。它或者是与十／0或者是‰（一0时）；或者是（‰一0时）。由此，当将加到上去时，对A矩阵的十字彘表来说、或者是改变结点的域值（十傷才c），或者不变就
o），或者插人一个新结点（‰一0还有一种可能的情况是：和，A矩阵中的某个非零元相对应，和矩阵/中是零元、即对A的操作是删除一个结点（丐+：：0）。由此，整个运算过程可从矩阵的第一行起逐行进行。对每一行都从行表头出发分别找到A和召在该行中的第一个非零元结点后开始比较，然后按上述四种不同情况分别处理之。
假设非空指针pa和(I)分别指向矩阵烈和13中行值相同的两个结点，一 =NOLL, 表明矩阵．A在该行中没有非零元，则上述4种情况的处理过程为：
（1）若p.e- =NULL或@勺后> pb一 j，则需要在．A矩阵的彘表中插人“个值为b的结点。此时，需改变同一行中前一结点的血ht域值，以及同一列中前一结点的down域值（2）若pa—>j<pb 于则只要将pa指针往右推进一步。
（的若pa-—j= =pb-2>j且pa-é>e-tpb->e《：0，则只要将十b刂的值送到所指结点的e域即可，其他所有域的值都不变。
（4）若pa—>j— —pb—>j且pa—>e+pb— = 0，则需要在矩阵的琏表中删除 pa所指的结点。此时，需改变同一行中前一结点的right域值，以及同一列中前一结点的 down域值。
为了便于插人和删除结点，还需要设立一些辅助指针。其一是，在A的行链表上没 pre指针，指示pa所指结点的前驱结点；其一是，在A的每一列的彘表上没一个指钊 h [ 0它的初值和列彘表的头指针相同，即h旧]一Chead家。
下面对将矩阵B加到矩阵，A于的操作过程作一个概要的描述。
( l)初始，令pa和旆分别指向和B的第一行的第、个非零元素的结点，即
pa—A. rheadL11 ; pb=B. rheadC?; pre—NULL
且令hl初始化
for (j=l；j?---?A. nu; (j) hlCjJ—A. cheadLfI;
5 ·
（2）重复本步骤，依次处理本百结点，直到B的本行中无非苓元素的结点，即pb一 NULL为IE：
=NULL或pa*、j>pli—:>]（即A的这一行中非零元素已处理完），则需在為中插人，个pb所指结点的复制结点。假设新结点的地址为p，则A的行表中的指针作如下变化，
if（pre NULL)釓rheads p else {pre ?right = p; } p—>right = pa; pre;出
為的列链表中的指针也要作相应的改变。首先需从h忄的0了开始找到新结点在同一列中的前驱结点可让h p j ]指向它，然后在列链表中插人新结点：
(A.Chead[p 一到」= = NULL) {A.chead[p->j] = p; P->down-MLL；} else {p—>down = p—>j l ?down; hl[p
若pa!=NULL且pa > i <pb->i，则令“指向本行下一个非零元结点，即 pre；pa =吓0'《0 r角证；
若pa—>j 户j，则将B中当前结点的值加到烈中当前结点上，即此时若pa—>e!一0，则指针不变，否则删除八中该结点，即行表中指针变为
if（pre = = NULL)一0 il一国·0、right; else {pre ?right —一茸山吓}
[0以；Lja?>right；
同时，为了改变列表中的指针，需要先找到同一列中的前驱结点，且让h逢pa．，到指向该结点，然后如下修改相应指针：
（A. eheadCp p) A. eh“d〔p、0、j〕竺bl〔P一>到P．> do凶中 else {hl[p -> 一0 do：p一> down；} free（P) ;
（3）若本行不是最后一行，则令pa和pb指向下一行的第一个非零元结点，转（2）；否则结束。
通过对这个算法的分析可以得出下述结论：从一个结点来看，进行比较、修改指钊所需的时间是一个常数；整个运算过程在于对A和B的十字链表逐行扫描，其循环次数主要取决于A和B矩阵中非零元素的个数和tb；由此算法的时间复杂度为C)(ta+ tb) a
5．4广义表的定义
顾名思义，疒义表是线性表的推)k。也有人称其为列表（Lists．用复数形式以示与统称的表脒的区别）。广泛地用于&工智能等领域的表处理语言冒SP语言，把广义表作为基本的数据结构，就连程序也表小为抽象数琚类型广义表的定义如下：真GLiSt {，系列的广义表。 数据对象：D到e. 0 ?ni；e. eAtomset或GList，
数据关系；田= { < ，e D，2劃。>．(肚。mset为某个数据对象})《i n } 基本操作： InitGList( &L)；
襟作结果：创建空的，、表L。
CreateGList(&L,；
初始条件是广义表的书写形式申。
操作结果：由S创建广义L。
DestroyGLi$t( L) ;
初始条件；广义表L育在作结果：销毁广义表L。
COPYGList( &T，0；初始条件刁、义表L存在
操作结果岫广义表L复制得到广义表， GListLengt,h(L)；
初始条件：广义表L存在。
作结果；求广义表L的长度，即丿L素个数， GLi5tLL)epEh( L)：初始条件：广义表L存在。
操作结果球广义表L的深度。
就上而p上y（L)；初始条件：广义表L存在。
操作结果《判定广义表L是否为空。
CetHead(L)；
初始条件：广义表L存在、
操作结果：取广义表〔的头， CetTail (L)；初始条件疒义表L存在作结果：取广义表L的尾 InsertFiret- GL(&L, e)；初始条件义表L存在，
操作结果：仙人丿素e作为广义表L的第一元素。
DeleteF irst
初始条件：广义表L存在，
操作结果：删除广义表L的第一、几索，并用e返回其值。
Traverse- GL(L，V 5土乜（）〕初始条件：广义表有在
操作结果：遍历广义表，用函数i t处理每个元素。
}轟CList
广义表一般记作
IS
其中，LS是广义表心．，-0的名称是它的长度。在线性表的定义中“ (l 只限于是单个元素。而在下义表的定义中可以是单个兀素，也可以是广义表，分别称为广义农LS的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。当广义表LS非空时．称第一个元素为LS的表头（Head），称其余元素组成的表．“）是上S的表尾（T 0
显然，广义表的定义是．，个递归的定义，因为在描述广义表时又用到了广义表的概念。下面列举一些广义表的例子，
o）A一（）一一A是一个空表，它的长度为零。
（2）B—(e)- -列表B只飠一个原于e ,B的长度为1。
（3）0 =，勖，吓d月一一列表C的长度为2，两个元素分别为原了“和子表宀
（D D能（A，月，0一 列表D的长度为3，3个元素都是列表。显然，将子表的值代人后，则有T) =（（丛（的，0，“'，的月。
o ）E=，E）一这是．个递归的表，它的长度为2。E相当于一个无限的列表从上述定义和例了可惟出列表的3 'i、重要结论；
（0列表的元素可以是．了表，而子表的元素还可以是于表一一山此，列表是一个多层次的结构，可以用图形象地表小。例如图5 0表示的是列表DO图中以圆圈表示列表，以方块表示原子。
o ）列表可为其他列表所共享。例如在上述例子中．列表為、B和C为I)的子表．则在D中可以不必列出子表的值，而是通过子表的名称来引用
（的列表可以是“个递归的表，即列表也可以是其本身的，个子表。例如列表E就是一个递归的表。
根据前述对表头、表尾的定义可知：任何“个非空列
表其表头可能是原子．也可能是列表，而其表尾必定为列表。例如：
GetHead(B)==e， GetTail(B)=(丛
GetHead(D) = A. 0曰T司（D）一(B，C)，
图& 7
列表的图形表示
．
山F(B，0为非空列表，则可继续分解得到！
Get ead（（B，C一 GetTail((B.C))=(C) .
值得提醒的是列表0和（0）不同。前者为空表，长度：0；后者长度"一1，可分解得到其表头、表尾均为空表（）。5，5广义表的存储结构
由于「义表@ “）中的数据元素可以艮有不同的结构，（或是原子，或是列表），因此难以用顺序存储结构表示．通常米用链式存储结构，每个数据元素可用一个结点表示。
如何设定结点的结构？由于列表中的数据元素可
《
结点，用以表示列表；一种是原子结点，用以表示原子。
从上节得知：若列表不空，则可分解成表头和表尾；反
表咕点
能为原子或列表，由此需要两种结构的结点：一种是表 《〔《
{a宀0
个表结点可由3个域组成：标志域、指示表头的指针域
原子结点
和指示表尾的指针域；而原子结点只需两个域：标志域
图5．8列表的锖表结点结构
之，一对确定的表头和表尾可惟．确定列表。由此，
和值域（如图5，8所小）。其形式定义说明如下；
方 一广表的头尾表存储表示“
typ?d?f enum { A凹，LIST )E1emTagi ATOM = 0；@子，L巧T =苤后了表
typedef ?truet GL№de {
Ei T 0中 在公共部分，用于区分原了结点和表结点 union（ 原子结点和表结点的联合部分
At:011iTY11e； “是原子结点的值域，山用户定义
Struct. { Struct.瞓的hp，、“ up；}
//是表结点的指针域，伊、和ptr. tp分别指向表头和表尾
}帱GList% ／/广义表类型
AeNIL B
D
E
图。．9广义表的存储结构示例
上中曾列举了厂义表的例了，它们的存储结构如图5．9所示。在这种存储结构中有几种情况1 )除空表的表头指针为空外，对任何非空列表，其表头指针均指向一个表点，且该结点中的hp域指示列表表头（或为原子结点，或为表结点），tp域指向列表表尾（除非表尾为空，则指针为空，否则必为表结点）；（2）容易分清列表中原子和子表所在层次。
如在列表D中，原子女和e在同一层次上．而“和d在同一层次且比口和e低一层，B
t09 和C是同．层的子表3）最高层的表结点个数即为列表的长度。以上3个特点在某种程度1给列表的操作带来方便。也可采用另一种结点结构的彘表表示列表，如图5口0和图5．11所示。其形式定义说明如下：
一广义表的扩展线性链表存储表示
typedefenU {，LIST}ElemTag;／/；；原子，LIST “ 1;子表 typedef struct GLNode {
Elennag
，刁g；
／／公共部分，用于区分原于结点和在结点
“ 10n {
原了结点和表结点的联合部分
to田rpe
凸[OJtl；
//原子结点的值域
struct Gl,Node
表结点呐表头指针
strucE GLNode
／/相当于线性讎表的ne，指向下一个元素结点汐广义表类型GLi是一种扩展的线性表
对于列表的这两种存储结构，读者只要根据自己的习惯掌握其中一种结构即可。
tag— 0
表结点
原'子结点
图
列表的另
种结点结构
图5．1 1列表的另种铸表表示
5．6 m兀多项式的表示
在一般情况下使用的广义表多数既非是递归表，也不为其他表所共享。对广义表可以这样来理解，广贮表中的一个数据元素可以是另一个广义表，一个元多项式的表示就是广义表的这种应用的典型实例
在第2章中．我们曾作为线性表的应用实例讨论了一元多项式， 元多项式可以一个长度为且每个数据元素有两个数据项（系数项和指数项〕的线性表来表示
这里，我们将讨论如何表示元多项式。一个元多项式的每一项，最多有m个变元。如果用线性表来表示，则每个数据元素需要m十1个数据项，以存储一个系数值和m 个指数值。这将产生两个问题：一是无论多项式中各项的变元数是多是少．若都按m个变元分配存储空间，则将造成浪费；反之，若按各项实际的变元数分配存储空间，就会造成结点的大小不匀，给操作带来不便;?.是对嗟值不同的多项式，线性表中的结大小也不同，这同样会引起存储管理的不便。因此，由于m元多项式中每一项的变化数目的不均匀性和变元信息的重要性，故不适于用线性表表示。例如三元多项式
尸（x，，以）一上飞+ 2的y之《日一3mv v +之+ 6的：y后+ 2尹+ 15
其中各项的变元数目不尽相同，而@等因子又多次出现。如若改写为
丆0，到=（00 + 2）@ + 3）+（（十6T3）讨+ 2的+ 15
情况就不同了。现在，我们再来看这个多项式P，它是变元是的多项式，即丰从十 ] 5zQ，只是其中和B本身又是一个0，脚的二元多项式，15是的零次项的系数。进一步考察A()t，到，又可把它看成是，的多项式。03 +，而其中C和D为X的一元多项式。循此以往，每个多项式都可看作是山一个变量加上若十个系数指数偶对组成
任甸一个m元多项式都可如此做：先分解出一个主变元，随后冉分解出第过个变元，等等。由此，个忉元的多项式首先是它的主变元的多项式，而其系数又是第二变元的多项式，由此可用广义表来表示m元多项式，例如上述三元多项式可用式（弘7）的广义表表示，广义表的深度即为变元个数。
户：(A，2），〔B，1），（1 5，的）0
其中。《0，巛C，3（I)，0）
C 0，），（2．6月
D艹上（（3，5均E = x（0，4丛（6，3）） F =云（2，）
可类似于广义表的第二种存储结构来定义表示m元多项式的广义表的存储结构链表的结点结构为：《：亡1
exp
g亠
exp
表结点 原子结点
其中exp为指数域，c。ef为系数域，hp指向其系数子表，tp指向同一层的下一结点。其形式定义说明如下：
typedeE Struct MPNOde {
ElemTag tag；union {
丿区分原子结点和表结点 /指数域
float COeE；
汐系数域
丁我们在疒义的括弧之前加一个变兀，以示各层的变元。
struct. MPNode
hp;
／7表结点的表头指到
struct MPNode
／/相当于线性斂表的next，指向下一个元素结点
} MPLISL;
m元多项式广表类型
式（5一7）的广义表的存储结构如图5，12所示，在每一层上增一个表头结点并利用exp 指小该层的变元，可用一维数组仔储多项式中所有变元，故exp域存储的是该变元在一维数组中的下标。头指针p所指表结点中exp的值3为多项式中变元的个数。可见，这种存储结构可表示任何元的多项式。
5，7广义表的递归算法
在第3章中曾提及，递归函数结构清晰、程序易读、且容易证明正确性，因此是程序设 i十的力工具，但有时递归函数的执效率很低，因此使用递归应扬长避短。在程序设汁的过程中，我们亓不一味追求睇归。如果一个问题的求解过程有明显的递推规律，我们也很容易写出它的递推过程（如求阶乘数不一“！的值），则不必要使用“递归"：反之，在对问题进行分解、求解的过程中得到的是和原问题性质相同的子问题（如Hanoi*问题）岫此自然得到一、个递归算法，且它比利用栈实现的非递归算法更符合人们的思维逻辑．因向更易于理解。但是要熟练握递归算法的设计方法也不是件轻而易举的事情在本节中，我们不打算全讨论如何设计递归算法，只是以广义表为例，讨论如何利用“分 Kiik"(L)ivlde and 0艹q “ 0进行涕归算法设计的方法、
对这类问题没训递归法时、通常可以先写出问题求解的递归定义。和第二数学归纳法类似，递归定义由基本项和归纳项两部分组成
递归定义的基本项描述了一个或几个递归过程的终结状态。 虽然一个有限的递归（ 且无明显的叠代 ） 可以描述一个无限的计算过程 ， 但任何实际应用的递归过程 ， 除错误情况外 ， 必定能经过有限层次的递归而终止。 所谓终结状态指的是不需要继续递归而可直接求解的状态。如例3一3的裎阶山“ i塔问题，在理一1时可以直接求得解，即将圆盘从
X塔座移动到Z塔座0一般情况下，若睇归参数为心则递归的终结状态为月一0或
递归定义的归纳项描述了如何实现从当前状态到终结状态的转化。递归设计的实质是：当一个复杂的问题可以分解成若于子问题来处理时，其中某些子问题与原问题有相同的特征属性，则可利用和原问题相同的分析处理力法；反之，这些子问题解决了，原问题也就迎刃而解了。递归定义的归纳项就是描述这种原问题和子问题之间的转化关系。仍以日an塔问题为例。原问题是将月个圆盘从X塔座夥至Z塔座上，可以把它分解成3个子问题D将编号为I至月一1的”一1个圆盘从X塔座移至Y塔座；（2）将编号为n的圆盘从X塔座移至Z塔座这3）将编号为]至，冖1的圆盘从Y塔座移至Z塔座。其中（1）和（3）的子问题和原间题特征底性相同，只是参数一1和，D不同，由此实现了递归。
由于递归函数的没刂用的是归纳思维的方法，则在设计递归函数时，应注意：（1）首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原回题性质相同的于问题、只要接口一致，便可进行递归调用；（对丞数中的每、个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想得太深太远。正如用第二数学归纳法证明命题时，由归纳假设进行归纳证明时绝不能怀疑归纳假设是否正确
下面讨论广义表的3种操作，首先约定所讨论的广义表都是非递归表且无共享子表。
5，7彐求广义表的深度
广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。例如：多元多项式广义表的深度为多项式中变元的个数
设非空广义表为
LS一
真中雪0一 “，或为原子或为LS的子表，则求LS的深度可分解为”个子问题，每个了问题为求a，的深度，若，是子，则由定义其深度为零，若a，是广义表，则和《述
样处理，而LS的深度为各0一1，2，“ ·，的深度中最大值加1。空表也是广义表，并山定义可知空表的深度为]。
由此可见，求广义表的深度的睇归算法有两个终结状态：空表和原子，且只要求得 ，“，，D的深度丁义表的深度就容易求得了。显然，它应比子表深度的最大值
广义表
LIS—（，树
的深度DEPTH（LS）的递归定义为基本项
归纳项
DEPTH(LS)±I当LS为空表时
DEPTH(I?S)=() 当LS为原于时
DEPTH(I?S) =l &Max{I)EPTH(a,)} 、由此定义容易写出求深度的递归函数。假设L是GList型的变量，则I—NULL表明，义表为空表，0．0 g一0表明是原子。反之出指向表结点，该结点中的hp指针指向表头，即为L的第一个子表，而结点中的tp指针所指表昆结点中的亓指针指向L的第一个子表。在第一层中由tp相连的所有尾结点中的hp指针均指向L的子表。由此，求广义表深度的递归函数如算法5，5所示。
int GListDept.h( GList L) {
//采用头尾表存结构，求广义表L的深度，证00 return 空表深度为1 if（L一《0十二 ATOM) return 原子深度为0 for（x生0，pm PPZPP->Ptr?tP) {
dep = GLi9tDepth(pp->ptr?hp)l //'求以pp->ptr,hp为头指针的子表深度 if (dep > ma幻max一dep'
return 1 ]； 矛'非空表的深度是各元素的深度的最人值加] } GListDepth
算法5．5
上述算法的执行过程实质上是遍历广义表的过程，在遍历中首先求得各了表的深度，然后综合得到广义表的深度。例如：图5．] 3展示了求广义表D的深度的过程。图中用虚线小意遍历过程中指针上的变化状况，在向结点的虚线旁标记的是将要遍历的子
0
图5，13求广义表D的深度的过程
表，而在从结点射出的虚线旁标记的数字是刚求得的子表的深度，从图中可见广义表D = (A．B，0一气），@，，“，的的深度为3。若按递归定义分析广义表D的深度，
则有：
DEPTH(D) ]司(DEPTH(A) ?DEPTH(B)?DEPI?H(C)}
DEPTH(A) =
DE剡（田 ：1 + Max { DEPTH(国} = 1 + 0 ”
DEPI'H(C) ；I—Max{DEPTH(a).DEPTH((b,c,d)))· 114
DEPI'H()b，亡，山〕= 0一“ {DEEQH(a) .DEPTH(b) .L)EPPli(c)}
由此，DEPT H（D〉亠] + Max 0，1，2 }
5．7，2复制广义表
在5．5节中曾提及，任何一个非空广义表均可分解成表头和表尾，反之，一对确定的表头和表尾可惟一确定一个广义表。由此，复制一个广义表只要分别复制其表头和表尾，然后合成即可。假设LS是原表，NEWLS是复制表，则复制操作的递归定义如下。
基本项：] nitGL这t（NEW吓）{置空表}，当LS为空表时。
归纳项：COPY(GetHead(LS) —>GctHead(NEWLS)) {复制表头} COPY(GetTaiI(LS) +GetTail(NEWLS)) {复制表尾}
若原表以图5．9的链表表示，则复制表的操作便是建立相应的链表。只要建立和原表中的结点一一对应的新结点，便可得到复制表的新链表。由此可写出复制广义表的递归算法如算法5，6所示。
&T，GLi%L L) {
汐采用头尾链表存储结构岫广义表L复制得到广义表T。
0囝'1'即跹；复匍空表
01u（
0（忄(GList)ma110c(sizeof(GLNode))))妣（0 R卜的汐建表结点
T一0叼l.一0 tag；
A'I'010 'Y 一0 “ = 1'一《、酣。中／7复制单原了
{ CopyGl?ist( Vtr. hp，0．过、ptr. lip)c
复制广义表L—>ptr. hp的一个副本T—ptr. hp
CopyGLi*t(T—>ptr.、Ptr. (p)；
复制广义表i.->ptr. tp的一个副本T%>ptr. tp 小e
//else
return OK；
} # CopyGList
算法5
注意，这里使用了变参，使得这个递归数简单明了，直截了当地反映出广义表的复制过程，读者可试以广义表C为例循序察看过程，以便得到更深刻的了解。
5，7．3建立广义表的存储结构
从上述两种广义表操作的涕归算法的讨论中可以发现：在对广义表进行的操作下递 归定义时，可有两种分析力法。一种是把广义表分解成表头和表尾两部分；另一种是把义表看成是含有月个并列子表（假及原子也视作子表）的表在讨论建立广义表的存储结构时，这两种分析方法均可。
假设把广义表的书写形式看成是一个字符串s．则当s为非空白串时广义表非空。此时可以利用5，1节中定义的取列表表头GetHead和取列表表尾GetT司两个函数建立广义表的链表存储结构。这个递归算法和复制的递归算法极为相似，读者可自0试之：卜曲就第二种分析方法进行时论。
了义表字符串S可能两种情况：（0 S一尸（带括弧的空白串）；（趵S：（，，“，羥其中0一 ，劢是S的子串。对应于第一种情况3的广义表为至表，对应丁第一种啃况5的广义戋中含有u个子表，每个子表的朽写形式即为子串殳山=
，．，的。此时可类似于求广义表的深度，分析由S建立的广义表和山鱈0一
建立的子取之间的关系。假设按图5．8所示结点结构来建立广义表的存储结构，则含有门个子表的广义。表中有个表结点序列。第0一] ．．“一0个表结点中的表尾指针指向第下十1个表结点、第个表结点的表尾指到、为NUI主，并且，如果把原子也看成是了表的话，则第家个表结点的表头指钊hp指向由建立的子表0 = 1，2，，，，，劢。由此，由$ 建广义表的问题可转化为由奁，0 = 2，．宀劢建子表的问题。又，叫可能有3种情况：（l ) 带括弧的空白串；（2）长度为1的单字符串；（3）长度> 1的字符串。显然，前两种情况为递归的终结状态，子表为空表或只含一个原子结点，后一种情况为递归调用。由此，在不虑输人字符串可能出错的前提卜，可得下列建立广义表链表存储结构的递归定义。
基本项：置空广义表 当s为空表串时
建原子结点的子表 当S为单字符巾时
归纳项：假设sub为脱去S中最外层括弧的了串，记为‰，，，，，5，，其中s，0
，，的为非空字符串。对一个、，建立一个表结点，并令其域的指针为山，建立的子表的头指钼，除最后建立的表结点的尾指针为NU上L外，其余表结点的尾指针均指向在它之后建立的表结点。
假定数跹“ r吓tr，陬(r)的功能为，从字符串str中取出一个“，”之前的了串赋给 h亠，并使姒成为删去子串h姒和'，，之后的剩余串，若串中没有字符六，．则操作后的r即为操作前的str，而操作后的“为空串NULL。根据上述递归定义可得到建广义表存储结构的递归函数如算法5，7所示。函数$ ev“如算法5，8所示。
StatutJ CreateGLxst(GLxst &巛SString（
采用头尾毓表存储结构，由广义表的书写形式串s创建广义表0设呷尸
{F巧00。地（g，e呷的0：NULL;，学刨建空表
else { {E 0 0、(GLisO nalioc (sizeof (CLNode)))) “（0 RFL?；彦建表结点
if（Strr?ngth(引Eag ATOM; L—?atom }创建单原子广义表 190 {
L ?tag = LIST；p
山．t土ng（s，$，2．StrLength(5)一2）； 在脱外层括号 do（．/重复建n个亻表
v“ 0川b，）；在从中分离出表头串h籼山
CreateGL1st(po..:ptr. hp. h）：q if（！SttFnptyQgab)) { 表尾不
0 (p (CLNode娑）malloe (sizeof(GLN?de)))) exit（OVERFLOW)；
产tag LIST；t?
}HhiJe ( ! StrE.rnpty(
- NULL;
) //else return OK i
} CreateGList // sever
第6章树和二叉树
树型结构是一类重要的非线性数掘结构。其中以树和二叉树最为常用，直观看来，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，如人类社会的族i普和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，如在编译程序中，可用树来表示源程序的语法结构。又如在数据库系统中，树形结构也是信息的重要组织形式之一。本章重点讨论二又树的存储结构及其各种操作，并研究树和意林与二叉树的转换关系，最后介绍几个应用例子。
6口树的定义和基本术语
树0「是刀00的个结点的有限集。在任意一棵非空树中：（0有且仅有一个特
定的称为根巛。（的的结点；（2）当“ > 1时，
层次
其余点可分为m（”，>的个互不相交的有限集．的， ，，Tm，其中每一个集合本身又是一棵树，并且称为根的子树（。例 O 如，在图〔0中出0是只有一个根结点的树；（的是有13．个结点的树，其中是根，其余结点分成3个互不相交的子集：0
F，K，0，= { 0 G。T =；D，H ,I，丛M}; （的
'1%.不和0都是根A的了树詡．本身也是一棵树。例如不，其根为猕其余结点分为
图6．1树的示例
00只有根结点的树；00一般的树
两个互不相交的子集；0：，K，0，T。
；0。0和Tl都是召的子树。而0中E是根．《K》和《0是E的两棵互不相交的子树．其本身又是只有一个根结点的树。
上述树的结构定义加上树的一组基本操作就构成了抽象数据类型树的定义。
ADT Tree《
数据对象D：D是具有相同持性的数据叩素的集数据关系R；若D为空集，则你为空树；
若仅含一i、倨亓孛，则R为空集，否则H明出湖是如下二元关糸：（0在'〕中存在惟一的称为根的数据元素“。0它在关系H下无前驱；
o）若D到r。。凵云巾，则存在〔〕一《r。。的一个划分以山，宀D，（以），对任意0 0 〕，扈@）有D冂=巾．且对任意的i 0《i《惟．存在数据元素狐《立有< r Of，狐> H；
（3）对应于D “；root}的划分．H一“《、root冫}有惟一的一个划分出
，H．〔正一，0〕，对任意i k口巛j，k《m）有H n；．且对任意谊区、谜．H是
D L.的一--FL关系．也，，( })是一裸符合车定义的树，称为根“的了树，
基本操作p：
IniCTree（&· 0；
操作绍果：构造空树T： bestrayTree(&T)；初始条件；树T存在澡作结果：销毁树T。
CreateTree()T，definition)；
初始条件；def in it i给出树T的定义。
作结果：按definition构造树 ClearTree(&T)；
初始条件：树T存在。
操作结果：将树渭为空树《 TreeEnpty(T)；
初始件：树T存在生
操作结果：若为空树，则返回即E，否则巧
TreeDepth( T)；
始条件：树'1'存在：
作结果：返回T的深度。
00t（'l') i
初始条件：树T存在。
操作结果：返回的根阳10e（T，cur- e) '
初始条件：树T存在式“ e是T中某个结点。
襟作结果；返回。。的值。初始条件：树T'存在，cur e是T中某个结点。
操作结果：结点“r．e赋值为value,
Parent()' cur. e)；
初始条件：树T存在，cur以是中某个结点。
操作结果諾cu。e是的非根结点，则返回它的双亲，否则函数值为“空，。
LeftChi1d(). 01r．
初始条件！树T存在．“。是T中某个结点。
操作结果：若。ur “是的非叶了结点，则返回它的最左孩子．否则返回''空。
Rightsi%ling()'；
初始条付．树T存在scur-。是T中某个结点，
操作结果：若cu。e有右兄弟，则返回它的右兄弟．否则函数值为“空，。
IngertChild(&T, &?p，土，c) i
初始条件：树T存在，p指向中某个结点，1《土P所指结点的度+ ]，非空树c与T不相交。
世作结果：1由人亡为T中p指结点的i了树“
De〕.eteChi1d(&T. &吓i)；
初始条件：树T存在．p指向中某个结点< i< p指结点的度。
操作结果：删除T中p所指结点的第1棵子树 TraverseTree().
初始条件：树T存在，Vis跹是对结点操作的应用数。
操作结果：按某种次序对T的每个结点调用飛数v “土t．一次且卒多一次；一旦“ $ 0失畋，则操作失败。
1 1 9 ·
)?DT Tree
树的结构定又是一个睇归的定义，即着树的定义中又用到树的慨念，它道出了树的固特們。树还可有其他的表示形式．如图6．2所示为图60（的中树的各种表示萁中（的是以嵌套集合（即是，些集的集体，对于其中任何两个集合，或者不相交，或者一个包含另．个）的形式表示的是以「义表的形式表示的，根作为由了树森林组成的表的名字写在表的在边；（的用的是凹人表示法（类似书的编目）。表示力法的多样化，止说明了树结构在日常生活中及汁身机程序没计中的重要怊。般说来，分等级的分类方案都可用层次结构来表示，也就是说．都可导致一个树结构 图生2树的其他3种表示法下列出树结构中的．、些基本术语。
树的结点包含、个数据元素及若干指向其了树的分支。结点拥有的子树数称为结点的度（Degree)c例如．在图6，1（b）中，A的度为3，C的度为1，F的度为（〕。度为0的结点称为叶子0 “ 0或终端结点。图6．1（b）中的结点K、L、F、G、M上J都是树的叫子。度不为（〕的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最人值。如图6．I ( l））的树的度为3。结点的子树的根称为该结点的孩了（Ch翮），相应地．该结点称为孩子的双亲（Pa “ nt的例如，在图6．1（b)所小的树中，I)为A的子树的的根，则I )是A的孩子，而A则是D的双亲，同一个双亲的孩子之间且称兄弟（。例如，H、{和！互为兄弟。这些关系进一步推，、，可认为I )是 M的祖父。结点的祖先是从根到该结点所经分支上的所有结点。例如，M的祖先为A、D 和比反之，以某结点为根的子树中的任一结点都称为该结点的子孙。如B的了孙为下、 K、L和F。
结点的层次（L “山从根丌始定义起，根为第一层，根的孩了为二层。若某结点在第／层，则其了树的根就在第0 1层。其双亲在同一层的结点互为堂兄弟。例如，结点 G与E、F、H、凵甴为堂兄弟。树中结点的最人层次称为树的深度（Depth）或高度。图 6． 1（b)所示的树的深度为4。
如果将树中结的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为尢序树。在有序中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
森林〔、是"'(1@。的棵嫲不相交的树的集合。对树中每个点而訁．其子树的集合即为森林。由此，也可以森林和树相互递归的定义来描述树
就逻辑结构而羊任何一棵树是一个元组0 “一（rom，和，其中：“是数据元素．称做树的根结点；F是m 00）裸树的森林，F一01 ，0），其中一（。下0称做根“@的第棵子树；当m丆0时，在树根和其子树森林之间存在一卜列关系： RF
这个定义将有助于得到森林和树与二一又树之间转换的递归定义。
树的应用了泛，在不同的软們系统中树的基本操作集不尽相同
叉树
在讨论一般树的存储结构及其操作之前，我们首先研究一种你为二叉树的抽象数据类型。
在20 二叉树的定义
二叉树（Bi nary Tree)是另种树型结构，它的特点是每个结点至多只有二棵了树〈即一二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。
仙象数据类型二叉树的定义如下：
BinaryTroe：
数据对象是以亻相同特性的数据元素的集合。
据关系
若D =巾，则R =称日而“浈r@为空二叉树；若D*则=，H是如下二兀关系《
（1)在冂中存在惟一的称为根的数惦元素root'它在关系H下无前驱；
（2〕若D一；roou关巾，则看在D一《
若则中存在惟一的兀素，<匕> eH，且有在的关系匚出若则D:中存在惟一的元素×，，< r t》《且存在上的关系H：匚躡 <fOOt.X1 0，< r00七．>
团（D HI ; )是一裸符合本定义的叉树．称为根的左子树，（唁D是一棵符合本定是的二叉树，称为根的右子树
InitEiTre(基本擇作P，)e( bT)；
操作结果：构造空二叉树T。
DestroyBiTree( T)；
初始条件：二又树T看在操作结：销毁二叉树T
CreateBIIree(&T, definituon)，
初始条件：def № i后“给出二又树T的定义。
作结果！按definiEion构造二又树监 ClearBiTree(&T) ; 初始条件；二叉树T存在
操作结果；将二汊树T清为空树。
BiTreeEnpty(T)；
初始条付：二叉树T存在；
臊作结果：若T为空二叉树，则返回T即E，否则翻巧 BiTreel)epth(T)；
初始条件：二．又树T存在，操作结果：返回T的深度。
R00 T）；
初始杀件：一二叉树T存在。
操作结果：返回T的根， Value(T，e ) ;
初始条件0又树T存在还是T中犁个结点。
操作结果：回e的亻旧 A$sign(). be. value) ;
初始条件《二叉树T有在，e是T中某个结点。
操作结果：结点e赋值为v PCIrent()t的；
初始条件：二义树T'存在．e是T中某个结点，
操作结果：若是T的非相结点，则诉回它的双亲，否则返回“空，。
Left℃hild(),的；
初始条件：二叉树在还是1中某个结点
操作结果：返回e的左孩子。若e无左孩子，则返回空 RightChild(). e)；
初始条件：二又树T存在，e是T中某个结点。
操作结果：返回e的右孩子。若。无右孩了，则返回“空。
LeftSih1ing()' e)；
初始条件：：叉树T存在，e是亇中某个结点。
操作结果：返回e的左兄弟。若e是T的左孩子或无左兄弟，则返回“空"。
RightSihlinq(T，e) ;
初始件：二叉树T存在是T中某个结点。
操作结果：返回e的右兄弟·若e是T的右孩子或无右冗弟，则返回“空”。
InsertChilcI(). p，LR? c) ;
初始条件：二叉树T存在．p指向T'中某个结点，LR为0或l '非空二叉树c与T不相交且右了树为空。
操作结果：裉据球为0或〕，插人c为T中P所指结点的左或右子树。p所指结点的原有左
或右子树则成为c的右子树 Deletechild〔T．p．）i
初始条件：．叉树T存在．p指向T中某个结点，LR为0或]．操作结果：根据LB为刂或]，删除中p所指结点的车或右子树。
Pre()rder?Traver.Ge(rl'，Visit( 0；
初始条件：一树T看在这让是对结点操作的应用数。
操作结果：先序遍历T，刈每个结调用函数$一次且仅一次。
fi t}、收
InQrderTraverse()' Vis」.L( )》；
初始条件：二叉树T存在，距$且是对结点操作的应用函数。
操作结果：中序遍历T，对每个结点调用数Vi $一次且仅一次。
作失取
PostOrderTraverse(). Viglt())；
初始条件：二叉树T有在湖$是对结点操作的应用函数
操作结果詬序遍J力T，对每个结点调用函数叭0．次且仅一次
作失
leve10rderTraverse(T，Visit( ) )；
初始条件：二跹树'T存在．Vis是对结点操作的应用孓数。
5 it 0失敢．则操
旦vis' 0、败．则操
旦v让0失瞰，则操操作结果：墚序遍历T，对每个结点调用函数让次且仅一次。一卩“以）失败`则悍作失敢。
}轟俯BinaryTree
上述数据结构的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左了树和右子树的、互不相交的二又树组成。由于这两棵了树亦是二叉树，则由二叉树的定义，它们也可以是空树“山此，二叉树可以有五种基本形态，如图6．3所示“图6．3二叉树的血种基本形态
空一叉树；《流仅根结点的二丈树：（右子树为空的0．树《
(d)左、右孑树均非空的二叉树；（左了树为空的一叉树
6、1节中引人的有关树的术语也都适用于二叉树。
6．2．2二叟树的性质
二又树具有下列重要特性
性质1在过叉树的第》层上至多豹？“个结点00L}。
利用归纳法容易证得此性质。
I时，只肩个根结点。显然，2 ' 一1是对的凸
现在假定对所有的丿口《。。。，命题成立，即第丿层上至多有2 “个结。那么．可以证明j一时命题也成立
由归纳假没：第冖1层《生多有2以个结点。由于二叉树的每个结点的度金多为2，
] 23
故在弟i层上的最大结点数为第一1层上的最大结点数的2倍，即2 × 2：2 性质2深度为力的二叉树至多有2。．、结点．以00。
由性质[可歷，深度为走的二又树的最大结点数为
（第层l-的最大结点数）一2．
性质3对任何一棵一二叉树不如果其终端结点数为，0度为2的结点数为．则 i殳为二叉树丆中度为]的结点数。因为二义树中所有结点的度均小于或等于2，所以其结点总数为 再看二叉树中的分支数。除了根结点外，其余结点都有一个分支进人，设6为分支总数，则“；B-1 1。由于这些分支是由度为1或2的结点射出的，所以又有B一十2 №
于是得
十：恸0 f ]
山式（6一0和（0却得完全二叉树和满二叉树，是两种特殊形态的二叉树
一棵深度为差且有2 1个结点的二叉树称为满二叉树。如图6．4@所示是一棵深度为4的满二叉树，这种树的特点是每一层上的结点数都是最大结点数。
可以对满0叉树的结点进行连续编号，约定编号从根结点起，自上而下，自左至右。山此可引出完全二叉树的定义。深度为差的，有个结点的二叉树，当且仅当其每一个结点都与深度为差的满二叉树中编号从至的结点一一对应时，称之为完全二叉树評如图6．4（b）所示为一棵深度为4的完全二叉树。显然，这种树的特点是：（1)叶子结点只可能在层次最大的两层上出现这2）对任一结点，若其右分支下的子孙的最大层次为则其左分支下的子孙的最大层次必为/或/ + 1。如图60中@和(d)不是完全二叉树。
完全二叉树将在很多场合下出现，下面介绍完全二叉树的两个重要特性。
性质4其圣n个结点的完全一叉树的深度为围g?是+ 0。
证明：假设深度为私则根据性质2和完全二叉树的定义有
一1或2 “ < ” < 2走
于是1 < g“ <因为差是整数．所以：自咪」4．1
性质5如果对一棵有“个结点的完全二叉树（其深度为山0山0的结点按层序编号（从第1层到第山g“刂+ 1层，每层从左到：却，则对任、．结点的< ` <有
（0如果下一|，则结点是二叉、树的根，无双亲；如果i01，则其双辛PARENT(i)是结点法2」
（2） 如则结老无左孩子（结点下为叶子结点）；否则其左孩子LC田I'D(i)、在各种版本的数据结陶书中．对完全二叉树的定文均不相同。本朽中将一律以此定篁为准。
幻符号到表示不大于的最人幣数，反之汇刁表示小小丁的最小整数1M(j园特殊形态的二叉树
（的满一树；（0完饣一叉树；（的和（山非完全一又树是结点2i。
（3） 如果2，+ 0、则结点无右孩子；否则其右孩子RCHILD(i)是结点2衅1。
我们只要先证明（2）和（3），便可以从（2）和（3）导出0过
对于》亠1，由完全二又树的定义，其专孩了是结点2。若2 0狲即不存在结点2，此时结点i无左孩子。结点i的右孩了也只能是结点3，若结点3不存在，即3》此时结点/ 无右孩了。
对于，> I可分两种情况i刂论：0）设第丿一电。隕“」层的第一个结点的编号为以由 ．叉树的定义和性质2可知一 ），则其左孩子必为第丿+ I层的第一个结点，其编号为 2，= 2（2丿 1）：2若着> ”，则无左孩子；其右孩子必为第丿+ ]层的第一个结点，其编号为幻0，若2i + I >狲则无右孩子；（2）假设第丿（0`》过五砦的层上某个结点的编号为，（2“ ( I) .目2浔忙，则其左孩子为右孩子为20 ]，又编号为》0的结巛是编号为的结的右兄弟或者堂兄弟．若它有左孩子．则编号必为2》一2一2 0 +的．若它有右孩了，则其编号必为20 0。图6，5LCHILD(i) LCHILD (if1) RCHILD
图6，5 完全一更树中结点下和龟+ ]的、右孩子
（结点和下在同一层
〕结点和i + ]不在同．层十所示为完全二又树上结点及旦左、右孩子结点之间的关系。
6．2，3二叉树的存储结构
顺序存储结构
二又树的序存储表示
#define MAX TREE SIZE IOW ／／二叉的最大结点数 typedef l'臼《m' 1 ype s13 rceLMAX I'RF.E SIZE_i; 0号单元存储相结点 Sql?i'l「“ bt：
按顺序存结构的定义，在此约定，用一组地连续的存储单元依次自十而下、自左至右存储完全一叉树上的结点元素，即将完全二叉树上编号为i的结点元素有储在如十定义的一维数组中下标为一1的分量中。例如，图6，6（a）所示为图6．4（b)所小完全二叉树的顺序存储结构。对于一般二叉树．则应将其每个结点与完全二义树上的结点相对照，存储在一维数组的相应分量中，如图60（所示二叉树的顺序存储结构如图 6、6（凿所示，图中以“ 0 ”表示不有在此结点。由此回见，这种顺序存储结构亻又适用十完全
000000000000 韭00000过00 0
图过又树的顺序存储结构
o的完全0里树；伟0．般二又树
二叉树。因为，在最坏的情况下，一个深度为且 PARENT 只有々个结点的单支树（树中不存在度为2的结点）却霞要长度为一1的一维数组。
2．式存储结构
RCHILD
kluld
data
rchild
划》翮
徂
parent rchild
中的结点至少包含3个域：数据域和左、右指针
域，如图6，7〈b）所示。有时，为了便丁找到结点
图6．7．以树的结点及其存储结构
的双亲，则还可在结点结构中增加一个指向其双
（的一叉树的結点；
亲结点的指针域，如图6，7（0所示。利用这两种
（树羊自两个指针域的结点结构；
结点结构所得二叉树的存储结构分别称之为二叉憐表和三叉表，如图6．8所小．链表的头指针
在）含有一个指针域的结点结恂
设计不同的结点结构可构成小同形式的式存储结构。山二又树的定义得知，二又树的结点（如图6．7（a）所示）山一个数据元素和分别指向其丿《、、右子树的两个分支构成，则表示二叉树的链表
指向二叉树的根结点。容易证得，在含”个结点的二叉链表中有卜1个空域
6．3节中我们将会看到可以利用这些空链域存储其他有用信息，从得到另一种链式存储结构一线索链表。以一卜是一义链表的足义和部分基本操作的函数原型说明 一树的二叉彘表存储表小 typedef 3truct BiTNQde《 TIF,O ernType 山甴 struct Bi'I'Node rchild；左右孩了指钅《
}讷'Node，咩E玉Tree；
基本操作的函数原型说明：都分
Status CreaLeEiTrec( BiTree &-T)；
，7按先序次输人'叉树中结点的值（一个字符丛空格字符表小空树， //构造二叉链表表示的一树T。
Status PreOrderrravecse(BiTree T，$上?tus〈Vis1t)(TE1emType e〕）； //采用《叉表存储结构、蹰sit是对结点操作的应用丞数。
先序遍历二叉树T，对每个结点调用孓数Vi 3一次且仅一次·
，7一目到t 0失敗，则操作失敲．
Status lnOrderTraverse(BiTree T, Status（Visit)(TE.1emType e) )； 采用0叉彘表存结构，VI t是对结点操作的应用函数， 中序遍历过义树T，对每个结点调用函数v It一次目仅一次。旦v it( )失败，则操作失取
Status Post0rderTraverse( BiTree T，Status（Vis (t)（TEIe1nType e) 采用叉表存傭结构，Vi $计是对结点操作的疴用函数， 层序历《又树六对每个结点调用函数计一次目仅一次。
/7一旦v让就（）失败，则操作失败 at“ LevelOrderTraverse(田Tree T，Status（V）（TEIemType月／7采用二又表存储结构湖t是对结点操作的应用函数“ 汐层序遍历二又树T，对每个结点调用函数s一次且仅一次。 一旦“ sit( )失败，则幞作失收氦 0夼
（单点树的又表；(b)一虻表巛一叉链表
] 2 7
在不同的存储结构中，实现二又树的操作方法亦不同，如找结点的双亲PAREN'I' （'V，的，在一及彘表中很容易实现，曲在一又鱼表中则需从根指到出发巡查。山此，在只体应用中采用什么脅储结构，除根据二叉树的形态之外还应考虑需进行何种操作，读者可试以6．2兯中定义的各种操作对以上三种存储结构进行比较
6，3遍历二叉树和线索二叉树
6，3．]遍历二叉树
在二又树的一些应用中，常常要求在树中查找具有某种特征的结点，或者对树中全部结点逐一进行某种处理。这就提出了，个遍历二叉树( Traversing Binary Tree )的问顺，即如何按某条搜索路径巡访树中旬个结点，使得每个结点均被访问一次，而旦仅被访问一次。“访问”的含义很广，可以是对结点作各种处理，如输出结点的信息等。遍历对线性结构来说，是一个容易解决的问题。而对二叉树则不然，山于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。
回顾二叉树的递归定义可知，过叉树是山3个基本单元组成：根结点、左了树和右了树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。假如以L、D、R分别表示遍历左子树、访问根结点和遍历右了树，则可有DLR、CDR、上RD、DRL ` RDL、RLD这6种遍历一叉树的方案。若限定先左后右，则只有前3种情况，分别称之为先（根）序遍历，中（根）序遍历和后（根）序遍历。基于二叉树的递归定义，可得下述历二叉树的递归法定义
先序遍历二叉树的操作宗义为：若二叉树为空，则空操作；否则
( 1 )访问根结点；
（2）先序遍历左子树；（3）先序遍历右子树
中序遍历二又树的操作定义为：若二叉树为空．则空操作；否则山中序遍历左子树、
（2） 访问根结点；
（3） 中序遍历右子树
后序遍历二叉树的操作定义为：若了叉树为空，则空操作；否则
o）后序遍历左子树；
（2）后序遍历右子树，
o）访问根结点。
算法6．I给出了先序历树基本操作的递归算泫在二叉链表上的实现。 次者可类似地实现屮序遍仂和后序遍历的递归算法．此处不再，一列举。
128
Status Pr日00还Travers曰（5 i'I'J ee《 Status〔VJ.31t)(TElernType的冫{
下采用叉漭表看储结构，石新是数据儿素智山的应用函数、在先序遍历树的递归算法，对匈个数牖元素调用丞数到0 汐最綸单的Vi51t函数是：
Status PrirLtEletno.r-t( TELeIfiTypc 0冫／输出兀李#的值实用时，加l.式串 return OK；
//调用实例出了了del「at,'e03 T．盾'新〕上臼，《menu)；
、d巛，a〕）
if在r区〕rde?Traverge(T I chi1d. Visit) )
if (PreorderTraverse(T " rchild，"JJs it) ) return； return卜下RO躡
}else return 0K；
0/ Pre()rderTraverse
算法6．1
例如图6，9所示的二叉树山表示忄述表达式
—e/f
若先序遍，力此二叉树，按访问结点的先后次序将结点排列起来，可得到二叉树的先序序列为
一?a x 5 -cd:el （6一3）类似地，中序遍历此二叉树，可得此一《叉树的中序序列为
a十b醫c一d一0 f （6一4）
后序遍，力此二叉树，可得此二叉树的后序序列为
a bed一+ ef/
从表达式来看，以上3个序列（6．3）、（6 4）和（6．的恰好为表达式的前缀表示（波兰式）、中缀表示和后缀表示（逆波兰式）。
从上述二叉树遍历的定义可知．3种遍历算法之不同处仅在于访问根结点和遍历左、右子树的先后关系。如果在算法中
暂且抹去和睇归无关的小ite语句．则3个遍历算法完全相同。图6，9表达式（0卜山此，从递归执行过程的角度来看先序、中序和后序遍历也是(c d) 00的叉树
完全相同的。图600（b）中用带箭头的虚线表示了这3种遍历
算法的递归执行过程。其中，向下的箭头表示史深一层的涕归调用，向i．的箭头表小从递归调用退出返回；线旁的一角形、圆形和乃形内的字分别表小在先序、中序和后序遍 以一树表示表达式的递归定如六艺表达式为数或简度．则相应'又树中仅有，个裉结．其数据域存放该表达式信息；若表达式一（一操作数运符第二操作数〕，则相应的二树中以，午于树表小．操作数；亻、了树表示作数，恨点的数据域存致算符〔为元算，则亻树勾过操阼数身又为表达图蜘3种遍历过程示意图
（的农达式（“ b一0的一又树；（的遍历的递归执行过程
历0叉树过程中访问结点时输出的信息。例如，山于中序嗣历中访问结点是在嗣历左子树之后、嗣历右了杩之前进行，则带圆形的字符标在向左递归返回和向右递归调用之间· 由此，只要沿虚线从1出发到2结束，将沿途所见的三角形（或圆形、或方形）内的字符记下，便得遍历二叉树的先序（或中序、或后序〉序列”例如，从图6．蜘（b）分别可得图 6．（a）所示表达式的前缀表示（一“ bc）、中缀表示（“ b一c）和后缦表示（ab “一）。
仿照递归箅法执行过程中递归主作栈的状态变化状况可直接写出相应的非递归算法。例如，从中序遍历递归算法执行过程中递归工作栈的状态可见：《0工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指计，则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈；（2）若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层即栈顶记录中指针所指的根结点这3〉若是从右子树返回，则表明当前层的遍历结束，应继续退栈。从另一角度看，这意味着遍历右子树时不再需要保存当前层的根指针，可直接修改栈顶记录中的指针即可。由此可得两个中序遍历二叉树的非递归算法如算法6．2和6．3所示，供读者分析比较，以加深理解。
Status lnOrderTraverse(BiTtee Status（$）（1 1、me）{ 采用二叉链表存储结构杜是对数据元素操作的应用函数
／/中序历二叉树T的非递归算法，对每个数据元素调用函数v15i0
InitStack(S) ; Push(). T)； 根指针进栈 while（!StackEmpty(S)) {
i炖出TO以3，@ &，&，p)（5，P一0忙hi〕0；向左走到尽头
节空指针退栈
证（!SEackEmptY(S)) { 访问结点．向右“步
Pop(). p) 0冒丑（p 、data)) return
Push()? p—>rchild);
] 3 0
return OK;
/ InorderTraverse
算法6．2
lnOrderTravergé(BITree T. u它（仍i00E1 Typ皂）{ 在采用一又链表存储结构．“ t是刈数据兀素操作的应用函数
/7屮序遍历二叉树T的非递归算法，对每个数据元素调用函数皿5。
Init$tack( p
"hile（p !StackE.mpty(S)〕{
证(P) {Push(S.；p = 9->lchild; }//根指钊进栈，遍历左子树 else { 根指针栈，访问根结点，谝历右子树 Pop(), 0；辽（! Visit(p 0 data)) return盟巛OR； p—>?rchild;
// else
}／7 While
return OK;
} /// InOrderTraverse
算法6，3
“遍历”是二叉树各种操作的基础，可以在遍历过程中对结点进行各种操作，如：对于一棵己知树可求结点的双亲，求结点的孩子结点，判定结点所在层次等，反之，也可在遍历过程中生成结点，建立二叉树的存储结构。例如，算法6．4是一个按先序序列建立二叉树的二叉彘表的过程。对图6．8（b）所示二又树，按下列次序顺序读人字符
A B C中巾D E巾G 0巾F中巾巾
（其中巾表示空格字符）可建守相应的《《叉链表“
Statug巛飞iT了e以〕&?Tj {
按先序次序输人一叉树中结点的值〔一个字符六空格字符表小空树，
//构造二叉表表示的一叉树T垤0 (T (BiTNode )ma110c(3izeof(BiTN0de)))) e累it@讹胛LO；
T一0 darn ch；
生成根结点
CreateBITree(T—>1c:hild)；
构造左子树
CreateBiTree(T—>rehild)；
return《
》// CreateBiTree
/7构造右子树
算法6，4
对二叉树进行谄历的搜索路径除了上述按先序、中序或后序外，还可从上到下、从左到右按层次进行。
显然，遍历二叉树的算法中的基本操作是访问结巛，则不论按哪一种次序进行遍历．对含个结点的了叉树，其时间复杂度均为00D。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为№则空间复杂度也为0（的。遍历时也可采用二叉树的其他存储结构，如带标志域的二叉憐表（参见算法603丛此时因存储结构中已了了有遍历听需是够信息、则遍历过程中不需片没栈，电可和80节将讨论的遍历广义表的算法相类似，采用带标志域的二叉链作存储结构．葑在遍历过程中利用指针域暂存遍历路径．也用省略找的空同，但这样做将使时间上有很大损失。
6，3．2线索二叉树
从上节的讨论得知：遍历一叉树是以一定规则将二叉树中结点排列成一个线性序列．得到二义树中结点的先序序列或中序序列或后序序列。这实质上是刈一个非线性结构进行线性化操作，使每个结点（除第一个和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继（在不至于混淆的情况，我们省去直接二字产。例如在图6，9所小的二叉树的结点的中序序列? b “．d- e哥中冠的前驱是驾0后继是'
但是，当以二叉憐表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在仃一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到。
如何保存这种在历过程中得到的信息呢？一个最简单的办法是在每个结点上增加两个指针域d和bkwd，分别指示结点在依任一次序遍历时得到的前驱和后继信息。显然，这样做使得结构的存储密度大大降低。另一方面，在有“个结点的二叉链表中定存在“到个空域。由此设想能否利用这些空链域来存放结点的前驱和后继的信息。
试作如下规定諾结点有左子树，则其吓ild域指示其左孩子，否则令ild域指示其前驱；若结点，自右了树，则阻rchild域指示其右孩子，否则令rchild域指示其后继。为了免混淆，尚需改变结点结陶，增加两个标志域
RTag
其中：
Ichild域指小结点的左孩子吓翮域指示结点的驱 rehild域指示结点的右孩了 r訃翮域示结点的后继
以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点前驱和后继的指针，叫做线索。加上线索的二又树称之为线索二叉树（Thread翮Bina一 ry Tree) e例如图6，11（所示为中序线索二叉树，与其对应的中序线索表如图6．
（b）所示。其中实线为指针（指向左、右了树）．虚线为线索（指向前驱和后继）。对二叉树以某种次序遍历使其变为线索一又树的过程叫做线索化。
在线索树十进行遍协，只要先找到序列中的第一个结点，然后依次找结后继直至其后继为空时而化。
如何在线索中找结柰、的后继？以图6．I l的中宇线索树为例来看，树中所有叶子结点的右链是线索，则右链域直接指示了结点的后继，如结点b的后继为结。 树中所有T注总在本节于父中提到的" ''和"后继"均指以果种次序遍力所得序列中的前驱和后继．非终端结的右均为指针，则无法山此得到后继的信息。然而、根」居中序晌历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右了树中最左下的结点。例如在找结点的后继时，首先沿右指针找到其右子树的根结点“一”，然后顺其左指针往下直至其左标志为1的结点，即为结点的后继，在图中是结点c。反之，在中序线索树中找结点前驱的规律是：若其左标志为“尸，则左憐为线索，指示其前驱，否则历左子树时最后访问的、个结点（左子树中最右下的结点）为其前驱。
在后序线索树中找结点后继较复杂些，可分3种情况这1 )若结点×是过叉树的根，则其后继为空；（0若结点x是其双亲的右孩子或是其双亲的左孩子目．其双亲没有右子树，则其后继即为双亲结点；（3）若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序历列出的第一个结点。例如图6．12所示为后序后继线索0叉树．结点B的后继为结点C，结点C的后继为结点D，结点F的后继为结点G，而结点D的后继为结点E。可
见，在后序线索化树上找后继时需知道结点双亲．即需带标志域的
鎣& 1 2后序后哏
二叉表作存储结构
线索二叉树
可见，在中序线索二叉树上遍历二叉树，虽则时间复杂度亦为
00D，但常数因子要比上节时论的算法小，且不需要设栈。因此，若在某程序中所用二叉树需经常历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表作存储结构。
二叉树的二叉线索存储表不一
typedef皂n酾PO interTag、Link．ThreadLink =玉指针，Thr“d 线索 typedef struct BIThrN0de { TEIemType data；
Struct BiThrNode ”，，在右孩子指钊
133
Point-er?Tag LTaq，左右标志
，I*iThrNode.、}行旨r宅r00：
为力便起见．仿照线性表的存结构，在一一叉树的线索链表上也添加一个头结点．并令其Ichild域的指针指向一叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点；反之，令二叉树中序序列中的第一个结点的{ child域指针和最后一个结点 rchild域的指钭均指向头结点。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历．也可从最后一个结点起顺前驱进行遍历（如图6，11（b冫所示下述算法60止是以双向线索琏表为存储结构时对二叉树进行遍历的法。
Statua lnOrderTraverse rhr( B iThrTree T，status（Vis 0） T指向头结点，头结点的左Ich到d指向根结点．可参见线索化算法
中序遍历二又线索树的非递归算法，对每个数据元素调用函数叭8比。
产山il山 汐' p指向根结点
while（p！；T）{ 空树或遍历结束时，p = = T
Rh-i le（p ?*LTag== Link) p p、>跹hil山
if（igit(p一氵'山00）return E?RROR； //访回其左子树为空的结点
'RT声0《：；Thread &&卩一00：hil山
P：P ->rchildi Visit(p—>data)； 访问后继结点
P
return OK；
〉In0rderTraver%f;e 'l'hr
算法6巧
那么，又如佝进行二叉树的线索化呢？山于线索化的实质是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程即为在遍历的过程中改空指针的过程。为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，若指针指向当前访问的结点，则p “ 指向它的前驱。由此可得中序遍历建立中序线索化链表的算法如算法6．6和6，7所示
lnOrderThread?ng( & Tree T) {
，7中序历二叉树，并将其中序线索化，“指向头结点。
( ! (Thft：(BiThrTree)ma110c(size0f(BiThrN0de))))（'L后
Thrt—>LTaq L新?1k《Thrt 、、RTag：Thread；
建头结点
Thrt Zsrchild巪Thtt'
//右指针回指
0 0 Thtt一冫．Ichild T〕〕匕 else {
Thrt—-*lchild。pre
／/若二叉树空，则左指针回指
Int e黿i四《T
中咩禧进行甲序线索化
pre €>rchild = pre
= Thread;
另／最后一个结点线索化
Thrt—>rchild
return 0只《
} InOrderThreading
算法 6
] 3 4 ·
譬0 d InThreadinq（BiThrTree {
lnThreading(p -.>ichild)： 左子树线索化
0 p、-.'>lchild) {p >LTag Thread；p、 刁℃ hild pre; }汐前驱线索 if 0 pre->?rchild) {pre->RI*ag；Threadi prem>rchild = }／/后继线索 pre ／/保持e指向p的前驱 inThreading(p->rchiid) i才右子树线索化
}汐InThreading
箅法6．7
6园树和森林
这一节我们将讨论树的表示及其遍历操作，并建立森林与二叉树的对应关系。
在4彐树的存储结构
在大量的应用中，人们曾使用多种形式的存储结构来表示树。这里，我们介绍3种常用的链表结构。
1.双亲表示法
假设以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置，其形式说明如下：
一树的双亲表看储表小
*define X TREE SIZE 100
“d以№d以／/结点结桷 TEJeRlType data；
int “／/双亲位置域
} ode；
0
0@0000mm
惟一的双亲的性质。PARENT(T.x)N作可以在常
鼠时间内实现。反复调用PARENT操作，直到遇
图6．13树的双亲表示法示例
typedof *truce { 汐树结构 数下标 PI'Node n e畔柯TREE SIZE]；
int 0 n； 汐根的位置和结点数
} prree；
例如，图6，1 3展示一棵树及其双亲表示的存储结构
这种存储结构利用了每个结点（除根以外）只有
见无双亲的结点时，便找到了树的根，这就是ROOT（x）操作的执行过程。但是，在这种表示法中，求结点的孩子时需要遍历整个结构
2．孩子表示法
由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其
中每个指到指向一棵子树的卡结点．此时链表中的结点可以有如一卜两种结点格式： 若采用第一种结点格式，则多重彘表中的结点是同构的，其中d为树的度。由于树中很多结点的度小于d．所以链表中有很多空镀域，空间较浪费．不难准出，在一棵有n个结点度为k的树中有n（k一0彐I个空彘域。若采用第二种结点格式，则多重彘表中的结点是不同构的，其中自为结点的度，degr “域的值同d。此时，虽能兯约存储空间，但操作不方便
另一种办法是把每个结点的孩子结点排列起来，看成是一个线性表，且以单表作存储结构，则n个结点有n个孩子毓表（叶子的孩子链表为空表）。而n个头指针又组成个线性表，为了便于查找，可采用顺序存储结构。这种存储结构可形式地说明如下：
一树的孩子彘表存储表示
typedef struct CTNOde { 《孩子结点 int child；
struct. CTNOde騖
}柯ChildPtr;
typedef {
TEIemType豳t甴
ChifdPtr first℃ hildJ “7孩子表头指针
} CT'BOX；
typedef struct {
CTBOX以司．MAX T隍．
季结点数和根的位置； } CTree；
图6，凵（a）是图6．13中的树的孩子表示法。与双亲表示法相反，孩了表示法便丁那些涉及孩子的操作的实现，却不适用于PAREN'P(T．x）操作。我们叫以把双亲表示法和孩了表示法结合起来，即将双表示和孩子笛表合在一起。图6，14（的就是这种存槠结构的。例，它和图6．11（的表小的是同一棵树、
3．孩子兄弟表示法
又称一叉树表小法，或二叉表表示法。即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为艹h ild域和nextsibling域
一树的．叉孩了一兄弟）存储表示
typedef struct {
struct (ElemType) firs(data；)tchlld. 暑n匕Slbl土四；
} CSNode, CSTree;
图6．巧是图6．中的树的孩子兄弟链表。利用这种存储结构便于实现各种树的操作。首先易于实现找结点孩子等的操作。例如；若要访问结点x的第i个孩子，则只要先 136 ·图6，归图6．13的树的另外两种表示法
〕孩了皚表；（带双亲的孩于表从hild域找到第1个孩子结点，然后沿着孩子结点的对$ ibli明域连续走i 1步，使可找到x的第i个孩子。当然，如果为每个结点增设个PA RENT域，则同吖能方便地实现PARENT(T.x)hkif
6．4．2森林与二叉树的转换
山丁二叉树和树都可用一叉链表作为存储结构，则以一叉表作为媒介可导出树与二叉树之间的一个对应关系。也就是说，给定裸树，可以找到惟一的棵二叉树与之对应，从物理结构来看，它们的一叉饼表是相同的，只是解释不同而己“图6，16直观地展示了树与二叉树之间的对应关系。
从树的二叉表表示的定义可知，任佝一棵和树对閿& 1 5图6．1 3中树的二叉表表示法
二叉树对应
应的二叉树，其右子树必家。若把森林中第棵树的根结点看成是第一棵树的根结点的弟，则同样i刂导出森林和一树的对应关系。
例如，图6．17展示了森林与二．叉树之间的对应关系图森林与二义树的对应关系示例
这个一．对应的关系导致森林或树与三叉树可以相互转换，其形式定义如下：
匚森林转换成二又树
如果F= { TI，的 0河是森林，则可按如卜规则转换成一棵二叉树月：（ro碗，L猕
R驾是
口）若F为空·即m一0，则召为空树；
（2）若F'非空，即m生0，则召的根root即为森林中第一棵树的根ROOT()0；扫的左子树LB是从0中根结点的子树森林F)一{ 0，T12 ．，'0詞转换而成的一叉树；其右子树RB是从森林F '：0。'0 “，T是转换而成的二叉树
2，二叉树转换成森林
如果B：0．“，LB' RIB )是．棵二叉树，则可按如下规则转换成森林（I )若月为空，则F为空
（2）若B非空，则F中第一棵树TI的根R伙月、（即为二叉树B的根“視；不中根结点的子树森林F，是由B的左子树LB转换而成的森林；F中除不之外其余树组成的森林F '：0 '2 ．，是山召的右子树R召转换而成的森林
从上述递归定义容易写出相互转换的递归算法。同时，森林和树的操作亦可转换成一又树的操仵来实现
6．4．3树和森林的遍历
由树结构的定义可引出两种次序遍历树的方法：一种是先根（次序）谳历树，即：先访问树的根结点，然后依次先根遍历根的每棵子树；另一种是后根（次序）遍历．即：先依次后根遍历每棵子树，然后访问根结点。
例如，对图6，16的树进行先根遍历，可得树的先根序列为 A B C D E
若对此树进行后根遍历，则得树的后根序列为： B D C E A
按照森林和树相互递归的定义，我们可以推出森林的两种遍历方法：
1，先序遍历森林
若森林非空，则可按下述规则遍历之：
(1)访问森林中第一棵树的根结点；
（2） 先序历第一棵树中根结点的了树纛林；
（3） 先序馮历除去第一棵树之后剩余的树构成的森林
2．中序遍历森林
若森林非空，则可按下述规则遍历之：
(I)中序遍历森林中第一棵树的根结点的子树森林，
（2） 访问第一棵树的根结点;
（3） 中序遍历除去第一棵树之后剩余的树构成的森林。
若对图6口7中森林进行先序遍历和中序遍，则分别得到森林的先序序列为 A B C D E F G日I J 中序序列为
B C D A F E H J I G
山上节森林与二叉树之间转换的规则可知，当森林转换成二叉树时，其第一棵树的了树森林转换成左了树，剩余树的森林转换成右了树，则上述纛林的先序和中序遍历即为其对应的二叉树的先序和中序遍历。若对图6，17中和纛林对应的二叉树分别进行先序和中序遍历，可得和上述相同的序列。
由此可见，当以二叉链表作树的存储结构时，树的先根遍历和后根谝历可借用二叉树的先序遍历和中序遍历的算法实现之。
6．5树与等价问题
在离散数学中，对等价关系和等价类的定义是！
如果集合s中的关系R是自反的、对称的和传递的，则称它为一个等价关系。
设R是集合s的等价关系。对任何es，由0一^，rR给出的集合 0 ] R二5称为由《S生成的一个R等价类。
若R是集合s上的一个等价关系，则山这个等价关系可产生这个集合的惟一划分。即可以按R将s划分为若．不相交的子集，，，“，它们的并即为S，则这些子集S'便称为S的R等价类。
等价关系是现实世界中广泛存在的一种关系，许多应用问题可以归结为按给定的等价关系划分某集合为等价类，通常称这类问题为等价问题。
例如在FORTRAN语言中，可以利用EQUIVALENCE语句使数个程序变量共享同
? 139
一存储单位，这问题实质就是按EQUIVALANCE语句确定的关系对程序中的变量集合进行划分，所得等价类的数目即为需要分配的存储单位，而同，等价类中的程序变量可被分配到同一存储单位中去。此外．划分等价类的算法思想也可用于求网络的最小生成树等图的算法中
应如何划分等价类呢？假设集合S有个兀素，忉个形如0：口）0口Q S冫的等价偶对确定了等价关系R，窬求5的划分。
确定等价类的算法可如下进行：
? ）令S中每个儿素各自形成．个只含单个成员的子集，记作Sl，Sz，
? ）重复读人m个偶对．对每个读人的偶对0、0），判定x和，所属子集。不失一般性，假设xe S ,yéS尸若S关S丿，则将S，并人S,并置S,为空（或将S.并人S，并置S,为空）。则当m个偶刈都被处理过后，Sl，Se，，，中所确非空子集即为5的R等价类。
从上述可见，划分等价类需对集合进行的操作有3个；其一是构造只含单个成员的集合蕃其二是判定某个单儿素所在子集；其三是归并两个互不相交的集合为一个集合。由此，需要一个包含上述3种操作的抽象数据类型MFS
MFSet {
數据对象：若没s是$社型的集合，则它由承的个子隼（0 ] “ 2疒～的构成，每个了
集的成员都是了界-maxnunber. m- r〕内的整数；
数据关系丿S: U，” W S S. 0 0 0 2，，，，n)
基木澡作： Initial(&S
操作结果：初始化襟作。构一个山n个了集（每个子集只含单个成员构成的集合初始条件还是己存在的小合冲是中某个了集的成。
操作结果：查找函数。确$中*所属子集辑。
Merge()S，i,刁后
初始条件和是中的两个互不相交的非空集合·
操作结果；归并操作。将和中的一个并人另一个中。
)ADT MFSet;
以集合为基础（结构）的抽象数据类型可用多种实现方法，如用位向量表示集合或用有序表表示集合等。如何高效地实现以集合为基础的抽象数据类型，则取决于该集合的大小以及对此集合所进行的操作。根据MFSeT类型中定义的操作FIND（S，×）和 MERG以S，(,)的特点，我们可利用树型结构表示集合。约定：以森林F一（不，的，
T,D表示MFSet型的集合S，森林中的每一棵树T, (i = ，“．，的表示S中的一个元素子集S（S CS = 。的，树中每个结点表示子集中的一个成员。为操作方便起见，令每个结点中含有．个指向其双亲的指针，并约定根结点的成员兼作子集的名称。例如，图6，18（a）和（b）中的两裸树分别表示了集Sl一目，3，6，的和一{ 2，8，，。显然，这样的树形结构易于实现上述两种集合的操作。由于各子集中的成员均不相同．则实现集合的“并''操作，只要将一棵子集树的根指向另一棵子集树的根即可。例如禀图 6．18（中S：s, U S?。同时．完成找某个成员所在集合的操作，只要从该成员结点出发．顺链而进，直至找到树的根结点为止图巧．18集合的．种表示法
0，H，I明；
为便于实现这样两种操，戽采用双亲表小法作存储结构．如下所示；
MYT MESeL的树的双亲表存储表示
typedef prree MFSet；
此时，查找函数和归并操作的实现如算法6，8和算法5．9所示。
社find；矸5eL01F3 t int 0 {
在找集合$中i所在了集的根。
0 < ]刂 {?:?S.n) return i不属s中任一子集 fo〖的0 & nodeslj l. parent>0; .j S； return j；
}／/ find- mfseE
算法6，8
Status merqe曰：&嶠．int i，int的{
／/ s．n囡“ 0 ]和& n。de卦到分别为S的10卜相交的构个了集詣和Sj的根结点、 求并集Si t.J Sj ?
了，$，n）return ERROR;
S.nodes(ij,parent = j; return OK；
}汐merge- mfset
箅法6，9
算法6．8和算法6．g的时间复杂度分别为0（的和00），其中d是树的深度。从前面的讨论可知，这种表示集合的树的深度和树形成的过程有关。试看一个极端的例子。
假设有”个子集S产S'， 。SQ，旬个子集只有一个成员S = {市= “，”，可用棵只有个根结点的树表小，如图6．19（的表示。现作” ]次“并”操作，并假设每次都是含成员多的根结点指向含成员少的根结点，则最后得到的集合树的深度为如图6．1叭b）所示。如果再加上在每次“并”操作之后都要进行查找成员“ 1 ”所在子集的操作，则全部操作的时间便是00的了。
改进的办法是在作“并”操作之前先判别子集中所含成员的数闫，然后令含成员少的子集树根结点指向含成员多的子集的根。为此，需相应地修改存储结构：令根结点的par 域存储子集中所含成员数目的负值。修改后的“并"操作算法如算法5，] 0所示
凵]
void mix rnfset (MFSet & S，int i，int j)〈
S n的到和& “的的分别为$的互小相交 的两个子集Si和sj的椎结。卡并集SilJSj
0 < 1
return ERROR；
it（& 0 esL i」，perent?>5. nodes!) ，parent) {
，/ Si所含成员数比sj少
引de虬到 ．parent +；5．node$L 0．parenti
& nodesti]. parent = j;
} el跹{
s、 ．@r雪还．0：nodes忄到．；
& nodegC3)，四建生i；
图6．19 “并”操作的一种极端情形
return QK；
（的ni、集合；(b) “并，作法600
可以证明，按算法6彐0进行“并"操作得到的集合树，其深度不超过@“i」+ 0其中 ”为集合$中所有子集所含成员数的总和
由此，利用算法find-mfset和mix一m卜et解等价问题的时间复杂度为0。的（当集合中有”个元素时，至多进行”一1次mix操作）。
例6一]假设集合s一00《0、0 ”是正整数丛R是S的一个等价关系“现求S的等价类。
以MFS画类型的变量s表示集合$，s中成员个数为S? n。开始时，山于每个成员自成一个等价类，则S. nodesCll. parent的值均为一1。之后，每处理一个等价偶对巛>，首先必须确定i和丿各自所属集合，若这两个集合相同，则说明此等价关系是多余的，无需作处理；否则就合并这两个集合。图6．20展示了处理R中前7个等价关系时s的变化状况（图中省去了结点的数据域），图6，21（的所示为和最后一个S状态相应的树的形态。显然，随着子集逐对合并，树的深度也越来越大，为了进一步减少确定元素所在集合的时间．我们还可进一步将算法6．8改进为算法6，11。当所查元素i不在树的第二层时，在算法中增加一个“压缩路径"的功能，即将所有从根到元素i路径上的元素都变成树根的山用归纳法证明之：
当，一1时，树中只有一个根点，即深度为1，又00 + 1：」正确
假设i《，，一1时成立，试诵：，时亦成立。不失般性．可以假设此树是由含有《，，00；' 2）个元、根为丿的树s，和含有，，一，，，个元素、根为寿的树合并而得，按法&耗根指向根即为合并后的根结点。
若合并前子树s，的深度<子树s、的深度，则合并后的树深和相同，不超过2 0一，司十1，显然不超过 L g」十]。
若合并前子树s，的深度子树s．的深度，则合并后的树深为s。的树深丰1，即（目。“」小+ 1一。緶〔2，。到一、目og」十] 国2
一2
S. naes
圈 6 20 求等价类过程示例图6的1表示集合的树
〔縮路径之前；（压路之后
int fix mfset：0 $：&g，int的{
／/确定i．所子集．并将从i至根路上所结点都变成根的孩子结点。辽(i<l i冫、$．的return一0 汐后不是$中任一子集的成员 for 0 = 0 nodesLjJ?parenE>0; j = $.nodegrj]' parent)； for (k：k！气j，k 0 {
E = S.nodeg[k」．parent; G. nodes[kl.parent：i ;
return j*
)// fix- mfseE
算法6．巧
假设例6刁中R的第8个等价偶对为（8，的，则在执行fix（$，8）的操作乏后图 6．2的的树就变成图6．2 ]伟）的树
已经证明，利用算法徽一mf “和mix一mf划分大小为的集合为等价类的时间复杂度为0（“（的）到。其中云的是一个增长极其缓慢的函数，若定义单变量的阿克曼函数为．A()r）一，A行一r），则函数的定又为A(x）的拟逆，即的的值是使．A（）冫”成立的最小。所以，对1．通常所见到的正整数而言．〕飞一
6，6赫夫曼树及其应用
赫夫曼(H man）树，又称最优树，是一类带权路径长度最短的树还着广泛的应用本节先i寸论最仇二叉協
6，6彐优二叉树（赫夫曼树）
首先给出路径和路径长度的概念。从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称做路径长度。树的路径长度是从树根到每．．结点的路径长度之和。6，2，1节中定义的完全一叉树就是这种路径长度最短的一叉树
若将上述概念广到．般情况，考虑带权的结点。结点的带权路径长度为从该结点到树根之间的路径长度与绌点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和，通常记作一习“。
假设豹个权值〈“ “2，一，“ }，试构造一棵有“个叶子结点的0叉树，每个叶子结点带权为“，则其中带权路径长最小的二树称做最优二叉树或赫夫曼树。
例如，图6，22中的3棵二叉树，都有4个叶子结点a、b、c、d，分别带权7，5、2、4，它们的带权路径长度分别为
〈a）WPI. = 7 × 2 + 5 × 2．+ 2 × 2 + 4 × 2 = 3 6 （的WPL亠7／3 +的《3十2 0+以0《2 -
在）WPL亠7》00} 5》《2 + 2》《3十1溪3 - 3 5
其中以（0树的为最小。可以验证，它恰为赫夫曼树，即其带权路径长度在所有带权为7、 5、2、4的4个叶子结点的过叉树中居最小。图6，22 日有不同带权路径长度的0叉树
在解某些判定间题时，利用赫夫曼树可以得到最佳判定算法。例如，要编制一个将分制转换成五级分制的程序。显然，此程序很简单，只要利用条件语句便可完成，如：
if（a < 60）" d"；
台1 if（a < 70）"pass；
else珏(a<8()) general
el艹if（a < 90）b= "good' else b= excellent
这个判定过程可以图6，23（的的判定树来表示。如果上述程序需反复使用，而且每次的输人量很人，则应考虑上述程序的质量问@，即其操作所需时间。因为在实际生活中，学生的成绩在5个等级上的分布是不均匀的。假设其分布规律如卜表所示
50 69
80 89立30
比例数
立0 5
0
o到0
则8的亻以上的数据需进行3次或3次以上的比较刁能得出结果。假定以5，15，40，30和
'
] 0为权构造一棵有5个叶子结点的赫夫曼树，则可得到如图6，23（的所示的判定过程，它可使大部分的数据经过较少的比较次数得出结果。但山十每个判定框都有两次比较，将这两次比较分开，我们得到如图6，23（c）所示的判定树，按此判定树可写出相应的程序假设现有10000个输人数据，若按图6，23（的的判定过程进行操作，则总共需进行31 500 次比较；而若按图6．23（c）的判定过程进行操作，则总共仅需进行22 000次比较。图6．23转换五级分制的判定过程
那么，如何构造赫夫曼树呢？赫夫曼最早给出了一个带有一般规律的算法，俗称赫夫曼算法。现叙述如下：
（归根据给定的个权值：“，0，一“0构成到果二叉树的集合F一{ T《，0， T，}，其中每棵二又树T，中只有一个带权为：的根结点．其左右子树均空。
（2）孔F中选取两棵根结款的权值最小的树作为左右子树构造一棵新的二又树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和
〔3）在F中删除这两棵树，同时将新得到的二叉树加人中
(4)重复（2）和（3），直到F只含棵树为上。这棵树便是赫夫曼树
例如，图6．“展小了图6，22（的的赫夫曼树的构造过程。其中，根结点上标注的数字是所赋的权。
(d)
图6．却去曼树的构情程
国0国010 ] ，总长14位，对方接收时，可按 位、分进行泽码。
算法的具体描述和实际问题所采用的存储结构有关，将留在下节进有词论
6，6．2赫夫曼编码
目前，进行快速远距离通信的主要手段是电报，即将需传送的文字转换成山二进制的字符组成的字符串“例如，假设需传送的电文为' A B A C C D A '，它只有4种字符，只需两个字符的串便可分辨。假设A、B、C、的编码分别为00、01、10 和1 ]，则上述7个字符的电文便为钿 100 '
当然，在传电文时，希望总长尽可能地短。如果对每个字符设长度不等的编码，且让电文中出现次数较多的字符采用尽可能短的编码，则传送电文的总长便叫减少。如果设计A、B、C、D的编码分别为0、00、]和01，则述7个字符的电文可转换成总长为9的字符串钿0国101的但是，这样的电文无法翻泽，例如传送过去的字符串中前个字符的子串' 0000 '就可有多种译法，或是' AAAA '，或 J/'/\BA'，也可以是，13哮等。因此，若要设i'1'长短不等的编码，则必须是任一个字符的编码都不是另．个字符的编码的前缀，这种编码称做前缀编鹤。
可以利用一叉树来计二进制的前缀编码。假设有一棵如图6．25所小的二叉树，其 4个明子结点分别表示A，B、C、D这4个字符，目．约定左分支表示字符@，右分支表示宁符，则可以从根结点到叫子结点的路径上分支字符组成的字符串作为该明子结点字符的编码。读者可以证明，如此得到的必为．二进制前缀编码。如山图6、25所得A、B、C、r)
的二进制前缀编码分别为0、10、1 10和到'0
又如何得到使电文总长最短的二进制前缀编码呢？假设每种字符在电文中出现的次数为，其编码长度为/，，电文中只种字符，则电文总长为惚乙。对应到二叉树 l.，若置“为叶子结点的权，乙恰为从根到叶子的路径长
度。则习“ l ,恰为一叉树，带权路长度。山此可见，设
前缀编码示例
计巾文总长最短的二进制前缀编码即为以 ，！ 种字符出现的 图 6 ． 25 频率作权，设计一棵赫夫曼树的问题，由此得到的了进制前缀编码使称为赫夫曼编码下面讨论具体做法。
山于赫夫曼树中没有度为I的结点（这类树又称严格的（满心）（或正则的）一又树〕，
] 16 ·
则一棵有”个叶了结点的赫夫曼树共有一]个结点，可以存槠在一个人小为一1的一维数组中。如何选定结点结构？山十在构成赫夫曼树之后，为求编码需从叶子结点出发走一条从辑子到根的路径；而为泽码需从根出发走一条从根到叶子的谘径。则对每个结点而．既需知双亲的信息，又需知孩子结点的信息。由此，设定卜述存储结构，
一夫曼树和赫人曼编码的存储表示 typedef Struct { unsigned int *eight; uns igned int，：
} H'I'Node，“ HuffmanTree： //动态分配数组存储夫曼树岫僭凵甸f “c。dew夕动态分配数组存储赫夫曼惊码表求赫夫曼编码的算法如算法6．12所小《
void Huffinarcoding( HuffmanTree，HuffmanC0de &HC，int蕢w，n) { // w存放n个字符的权值（均0的，构造赫夫曼树，并求出n个字符的赫夫曼编码HC。
if (n?<；；0 return;
点，其序号分别为$ 1和的。
Select(H'I?, i -到，的》；
HtiT s 0、parent i；HT[的I.卩a了en：' HT[il. 1chiid =亡hild 的「到.weight HT[S 0 0 iqht + HT〔92 ]．weight;
一从叶了到根逆向求每个字符的赫夫曼编码
HC总(Huffmancode)nolioe((n+ 1 0的后分配n个字符编码的头指针向量
Rizeof(chav))； //分配求码的工作空间
#编码结束符， for 0 = 1：n：斗i)《 逐个字符求赫夫曼编码编码结束符位置 for () = i' f - EITLi I、f! ±函c = f' f圳仃[ 0．pa“ 07从叶子到根逆向求编码
(HTtf]. Ichild ==c) cd( 一start] el cd( ．Start《'
NCCi.]一(Char g )malloc((n-豉a社3。r月；汐为第{个字符编码分配空间
0甲枞0，邴引r00； ，在从园复制编码（串）到
free( (d)； 释放〕作空间
},// PuffanC?ding
箅法 6．12
向量H丆的自0个分量表示叶子结点，最后一个分量表示根结点！各字符的编码长度小等，所以按实际长度动态分配空间。在算法6．] 2中，求每个字符的赫夫曼编码是从叶子到根逆向处理的。也可以从根出发，历整棵赫夫壘树，求得各个叶子结点所表示的字符的赫夫曼编码，如算法6．13所示。
一无栈非递归遍历赫夫曼树，求赫夫曼编码
HC (HutEmanCode)malioc((n十盞sizeof(char月；
P ；cdlen for 0，= 1；i<=十+到HT[i'.weight 0；遍历赫夫曼树时用作结点状态标志 il (p) { if（flT[p]. weight 穿向左
HTl-pl．weiqht = if（的[ p不Ichild！ 0）{p =〔pl.〕℃h过d；cdCcd1en++〕" 0气} else if (HTCp),rchi1d =的{ 登记叶子结点的字符的编码
HCCp_l = (char丿@Il（(cdlen+ l) sieeof(char))i cdccdl enl strepy(HCCpl，cd); 复制编码（串）
else it (HT[p .b.eiqht；； 向右附「羊W'2LghC if （旧[ pl. rchild ， 0）{p H'TCp」. rchild; cdCed1en+」=
0可国，“上。还胍退回 HT〔pl.weight = 0；p HTL p], parent; -cdlen;退到父结点，编码长度1 以气〕．吣
} While
算法6 3 译码的过程是分解电文中字符串，从根出发，按字符' 0 '或亇确定找左孩子或右孩子，直至叶子结点，便求得该子串相应的字符。具体算法留给读者去完成、例6．2己知某系统在通信联络中只可能出现8种字符，其概率分别为0，05，0，29，
o．07，0、08 14，0，23，0．03，0．11，试设计赫夫曼编码设权“一（5，29，7，8，14，23，3，( l )，”：8，则”“ 15，按上述算法可构造一棵赫夫曼树如图6．26所示。其存储结构HT的初始状态如图6，27@所示，其终结状态如图6、27（勖所示，所得赫夫曼编码如图6．27（c）所示。图6．26 例2的赫夫曼树
1 4 8 ·
HT
29
welght 在h汩
图6．27例的存储结构
@ HT的初态《
(b) HT的终态，
《出H夫曼绌码[IC
6，7回溯法与树的遍历
在程序设计中，有相当一类求一组解、或求全部解或求最优解的问题，例如读者熟悉的八皇后问题等，不是根据某种确定的计算法则，而是利用试探和回溯（B“ ktr “ kin@的搜索技术求解。回溯法也是设计递归过程的一种重要方法，它的求解过程实质上是一个先序遍历一棵“状态树"的过程，只是这棵树不是遍历前预先建立的，而是隐含在遍历过程中，但如果认识到这点，很多问题的递归过程设计也就迎刃而解了。为了说明问题，先看一个简单例子。
例6 · 3求含”个元素的集合的幂集
集合，的幂集是由集合．A的所有子集所组成的集合。如：0，2，3 }，则為的幂集 当然，可以用5．7节介绍的分治法来设计这个求幂集的递归过程。在此，从另一角度分析问题。幂集的每个元素是一个集合，它或是空集，或含集合．A中一个元素，或含集合，4中两个元素，或等于集合，4。反之，从集合．的每个元素来看，它只有两种状态：它或属幂集的元素集，或不属幂集元素集。则求幂集碩4）的元素的过程可看成是依次对集合
凵9
中元素进有“取'，或“舍（弃）”的过程，并且可以用一棵如图6，28所示的二叉树，来表示过程中幂集元素的状态变化状况，树中的根结点表示幂集元素的初始状态（为空集）；叶子结点表示它的终结状态（如图6．28中8个叶子结点表示式（6一的中幂集e(A)的8个元素）；而第雨= 2，3， ．“层的分支结点，则表示已对集合，A中前，一1个元素进行了取/舍处理的当前状态（左分支表示“取”，右分支表示“舍”）。因此求幂集元素的过程即为先序历这棵状态树的过程，如算法6口4所描述。
vo遢PowerSet(炻上i，int的{
求含n个兀的集合烈的幂集（№。进人丞数时已对A中i到个元素作了取舍处理， 现从第土个元素起进行取舍处理。若i > n，则求得幂集的一个元素，并输出之。
/7初始调用：PowerSet(). n)iels{取第i个元辈；0“记e (00巾输出缸集的一个元；)以i飞山；舍第i个兀素；PO让（i仁；
} // PowerSet
算法在] 4
对算法6，凵求精需确定数据结构。假设以线性表表示集合，则求精后的算法如算法
6．巧所小。
void Getpowetset(int i, L这上，List (B) {
汐线性表A表示集合线性表烏表示幂集下0的的一个元素。
局部量k为进人孓数时表B的当前长度。第一次调用本数时，B为空表，1
0 >凵就Le四．匕h月Output(E); #输出当前）的一个元素
el {GetE1em()'幻；
k ListLength(助；
Listlnsert(B，+幻；
GetPowerSet()+ ]，?，围；
Lj：北nelc还'203，k 4 ]
}汐CeEPowerSet
CetTJO er跹000，；
算法6．] 5
图6．28中的状态变化树是一棵满二叉树，树中每个叶于结点的状态都是求解过中
可能出现的状态（即问题的解）。然而很多问题用回溯和试探求解时，描述求解过猾的状态树不是一棵满的多又树、当试探过程中出现的状态和问题所求解产生矛屑时，不冉继续试探下去，这出现的叶子结点不是问韉的解的终结状态。这类问题的求解过程可看成是在约束条件F进行先序（根）遍历，并在遍历过程中剪去那些不满足条件的分支
例6一4求4皇后回题的所有合法布局（作为例子，我们将8皇后问题简化为4皇后问题）。
图6，29展示求解过程中棋盘状态的变化情况。这是一棵四叉树，树上可个结点表示 个局部布局或、个完整的布局“柜结点表小棋盘的初始状态；棋盘主无任何棋子、每个（皇后）棋子都有4个可选择的位置，但在任亻可时刻，棋盘的合法布局都必须满足3个约東条件，即任亻可两个棋子都不占据棋盘上的同一行、或者同一列、或者同、对角线。图 6．29中除结点a之外的叶子结点都是不合法的布局。
求所合法布局的过程即为在上述约束条件下先根遍历图6，29的状态树的过程。
遍历中访问结点的操作为，判别棋盘上是否己得到，个完的布局（即棋盘上是否已摆上，1个棋子），若是，则输出该布局；否则依次先相遍历满足约束条件的各棵子树，即先判断该子树根的布局是否合法，若合法，则先根遍历该子树，否则剪去该子树分支、算法
606为求所有合法布局的伪码算法：
void Tr 1（玉茈i. int n)（
//进人本函数时，在n × n棋盘前土到行已放置了互不攻的玉· 1个棋子。
现从第i行起继续为后续棋了选择合适亇位置
//当i > n时，求得一个合法布局，输出之。
it 0产巾榆出棋盘的当前布局： 在1，为4时，即为4皇后回聽 else for 0：丨；j <= n；+ + j）{
在第i行第j列放詈一个撳了；
（当前布局合法）Trial（i + 1．n)： 即湛足前述的3个约束条件
0
移走第i行第〕列的供子；
算法6．16
算法6，16可进一步求精，在此从略。算法6，16可作为回溯法求解的一般模式，类似问题有骑一L游历、迷宫问题、选最优解问题等等。
6．8树的计数
本节将讨论的树的计数回题的提法是：具确个结点的不同形态的树有多少裸？下曲我们先讨仑二叉树的情况，然后可将结果推广到树。
在时论一二叉树的计数之前应先明确两个不同的概念‰
称二叉树T和T／相似是指：二者都为空树或者二者均不为空树，且它们的左右子树分别相似。
称0叉树T和T '等价是指：二者不仅相似，而且所有对应结点上的数据元素均相同。
一又树的计数问题就是讨论具有''个结点、互不相似的二叉树的数目
在，，值很小的情况下，可直观地得到五= 1为空树= 1是只有一个根结点的树
‰：．．2和b3 = 5，它们的形态分别如图6．30（a）和图6．3以b）所示。那么，在> 3时又如何呢？图6．30二叉树的形态
（的n = 2， ）一般情形n>l
一般情况下，一棵具有，南0：l )个结点的二叉树可以看成是山一个根结点、一裸貝有
》个结点的左子树、和一棵具有，冖冖[个结点的右子树组成（如图6．30（所示），其中
0 < ”一1。山此可得下列递推公式：可以利用生成数来讨论这个递推公式。
对序列定义生成函数
( 6-8)
)Z -4- (bobz + bibl -4- b2ba -4- 1:3 2 (z) = (6-9 )
z?3 2 (z) — — B(zF1
B(z)
( 6- 10)
(6- 1 1 )
? 153 ?
（6 0）
因此，含有个结的不相似的．树有 了℃棵。
我们还可以从另一个角度来时论这个问题。从一二叉树的遍历己经知道，任意一槔一义树结点的前序序列和中序序列是惟一的。反过来，给定结点的前序序列和中序序列，能否确定一棵二叉树呢？跹是否惟一呢？
山定义，二叉树的前序遍历是先访问根结点I)，其次遍历左子树以最后遍历右子树 0即在结点的前序序列中，第、个结点必是根0而另一丿J曲，山丁中序遍历鼎先遍历左子树L，然后访问根I)，最后历右了树R，则根结点D将中序序列分割成两部分：在D 之前是左子树结点的中序序列，在D之临是右了树结点的中序序列。反过来，根据左子树的中序序列中结点个数，又可将前序序列除根以外分成左子树的前序序列和右了树的前序序列两部分。依次类推，便可递归得到整棵一叉树例6一5已知结点的前序序列和中序序列分别为：
前序序列: A B C I) E F G 中序序列；C B E DA F G
则可按上述分解求得整棵一树。其构造过程如图6，31所示。首先由前序序列得知图6．31由前序和中序序列构造一稗二叉树的过程
又树的根为A，则其左子树的中序序列为（CB五D）子树的中序序列为（(G) O反过来得知旦左了树的序序列必为（BCt)E〕，右子树的前序序列为（(G )。类似地，可由左子树的前序序列和中序序列构造得A的寿子树，山右了树的前序序列和中序序列构造得A的右子树。
L述构造过程说明了给定结点的前序序列和中序序列，可确定一棵二叉树。至．它的惟一性，汝者可试用归纳法证明之。
我们可由此结论来推论具有刀个结点的不同
图6．32具有不同中序序列的一叉树
形态的二叉树的数目
假设对二叉树的”个结点从1到n加以编号，且令其前序序列为1，2、 ，则由前面的讨论可知，不同的二叉树所得中序序列不同。如图6．32所示两裸有8个结点的二叉树，它们的前序序列都是123 678，而（a）树的中序序列为32465 ] 78：（b）树的中序序列为
到
0000
找状态访问
栈状态访问
找状态访问
找状态访问
3
栈状态访问
图6，33 中序遍历时进钱和出找的过程
23147685。因此，不同形态的二叉树的数目恰好是前序序列均为] 2，，，”的一叉树所能得到的中序序列的数目。而中序遍历的过程实质上是一个结点进栈和出栈的过程。二叉树的形态确定了其结点进栈和出栈的顺序，也确定了其结点的中序序列。例如图6，33中所示为月= 3时不同形态的二又树在中序遍历时栈的状态和访问结点次序的关系。由此，由前序序列0 “所能得到的中序序列的数目恰为数列0 “按不同顺序进栈和出栈所能
得到的排列的数目@这个数目为
0， 〈6刁3）山《叉树的il数可推得树的计数。山 “ 6．4．2森林与二叉树的转换”中可知一棵树可转换成惟一的一棵没有子树的二叉树，反之亦然。则具有个结点有不同形态的树的数目图6，34具确不同形态的树和一叉树 和具有”一1个结点互不相似的二叉树的数目相同。即'产01。图6．34展示了具有1个结点的树和具3个结点的二又树的关系。从图中可见，在此讨论树的计数是指有序树，因此（0和（d）是两棵有不同形态的树（在无序树中，它们被认为是相同的）。O)参考书冲译小第4页
第7章图
? ( Graph)是．种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系．并且每一层上的数据元素可能和下一层中多个元素（即其孩了结点）相关，但只能和上一层中个儿素（即其双聚结点）相关；而在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。由此，图的应用极为广泛，特别是近年来的迅速发展，已渗人到喈如语言学、逻辑学、物理、化学、电讯工程、计算机科学以及数学的其他分支中。
读者在“离散数学”课程中己学习了图的理论，在此仅应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构以及若T图的操作的实现。
7，1图的定义和术语
图是一种数据结构，加下一组基本操作，就构成了抽象数据类型抽象数据类型图的定义如下：
罴m，Graph {
数据对象v是具有相同特性的数据元素的集合，称为頂点集。
数据关系R：
v “《V且P（v），< v，>表示从v到“的弧，谓词p（v定义了弧< v “>的意义或信息}
基本撮作P：
CreateGraph(bG,V,VR)；
初始条件是图的顶点集.VR是图中弧的集合。
操作结果！按和“的定义构造图GO
DestroyGraph( 初始条件睏G存在。
操作结果：销毁图Ga LocateVex( G，
初始条件：图G存在，u和G中顶点有相同特征。
操作结果：若G中存在顶点u，则返回该顶点在图中位置《舌则返回其他信息。
GetVex(), v)J
初始条件《图G存在．v是c中某个顶点。
操作结果：返回v的值 PutVex(&G V. Vakue)；
初始条件：图G存在“是G中某个顶点。
操作结果；对v赋值value,
· 1 5 6 ·
FirsLAd)Vex(G, v) ;
初始条件：图G存在“是G中某个点。
操作结果：诉回v的第、个邻接顶点。名点在G中没有邻接庾点湖回“空、 NextAdj!)ox(G, v,后
初始条件：图G存在“是中某个顶点癉是的邻接顶点．
操作结果：返回v的〈相对于“的冫下一个邻接顶点，，若料是v的最后．个邻接点，则返
Insertvex( &?G，
初始条件：图G存在“和图中顶点有相同特征。
谋作结果：在图G中增添新顶点v.
DeletcVex(，v)；
初始条付：图G有在“是中某个顶点“ 作结果删除G中顶点v及其相关的弧 InsertArc()G，钔；
初始条件：图G存在“和w是G中两个顶点“
憷作结果：在G中增添孤。，、。、、若c是丸向的，则还增添对称弧 DeleteArc(&G,、，“）；
初始条件：图存在，v和是G中两个顶点。
臊作结果：在G中删除狐<v，、0、，若（；是无向的，则还除对称弧
，V
闪，V
J)FSTv?i“，0《C;，i 3 i上0）；
初始条件：图G存在，v让i上是顶点的疴用数
憷作结果《对图进行深度优先遍历。在遍历过程中对每个顶点调用函数v这it
目仅一次。一卩．v冚）失败，则操作失败 FFSTraverse(). Visit(却；
初始条件：图G存在江是@点的应用函数。
操作结果：对图进行广度优先痫历。在历过程中对每个顶点调用数俨在一次
且仅一次。一旦失败，则操作失败“
} Graph
在图中的数据元素聶常称做顶点（Vertex），V是顶点的有穷非空集合；VR是两个顶点之间的关系的集合。若> 0旷R，则〈0表示从@到的一条弧（Arc)，且称。为弧尾（'Vail )或初始点 (Initial node)，称为弧头(Head)或终端点
( Terminal node），此时的图称为有向图
7．1图的示例
(Digraph)0若，〉eVR必有〈，e VR '即
）有向图G凵伟）无向图
VR是对称的，则以无序对“）代替这两个有序
对，表示和w之间的一条边（E亟e），此时的图称为无向图（Un山grap的。例如图70（a）中G是有向图，定义此图的谓同p(v “）则表示从“到w的一条单向通路。
枞，呀六〈，六〈眦，〉巛，舄
腩7 ·
图70（b)中0为无向图。
一（嫔就河）
其中旷=恸凵u．，，“0 我们用表示图中顶点数目，用，表示边或弧的数目。在下面的时论中，我们不考虑顶点到其自身的弧或边，即若〈满〉eVR，则“关马，那么，对丁无向图“的取值范围是 0到一0面冖t有一以n一0条边的无向图称为完全图（C。mp@ed graph)o对于有向图“、的取值范围是0到以“一0。具有月一0条弧的有向图称为有向完全图。有很少条边或弧（如“0 g劢的图称为稀硫图（Spar沁gr叩h），反之称为稠密图（Den跹graph)o 有时图的边或弧具有与它相关的数，这种与图的边或弧相关的数叫做权（w (t)。这些权可以裘示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网 (Network)e
假设有两个图G一霪，00和0一（俨認00，如果且E ' CE，则称G '为G的子WSubgraph) c例如，图7，2是了图的一些例子。图7．2了图示例
（的0的了图以b）的产图
对于无向图G一（v，主的，如果边伟“ '）e E，则称顷点和'耳为邻接点（Ad处 m)，即和竹相邻接。边0，的依附()n 1 “ t）于顶点和，或者说“'）和顶点着和@相关联6顶点℃的度(D re的是和到相关联的边的数目，记为TD(V）。例如，0中顶点。3的度是3。对于有向图G一(V出A}），如果弧，的GA，则称顶点。邻接到顶点。'，顶点邻接自顶点。。弧钿，的和顶点，“'相关联。以顶点v为头的弧的数目称为。的入度(Inl)egree) ,记为L)(t')；以为尾的弧的数目称为@的出度(Outdegree) ' id为 ()T)(O)；顶点钞的度为TD(t')=ID(?)4-()D(v) ?例如，图Gl中顶点的人度ID（喏）一以出度()D(t'! )：2度T1-)(）一ID（仂）+ OD（）：3。 一般地．如果顶点喏的度记为
．那么一个有月个顶点，e条边或呱的图，满足如下关系
—ETD(t't)2
巧8
无向图G一霪，{ ED中从顶点v到顶点是的路径〈Path）是．个顶点序列恸一咗，一过），其中0艹《“：。跹E，10j0 “如果G是有向图，则路径也是，自向的．顶点序列应满足饨， ．v, ,压E，00飞m。路径的长度是路径上的边或弧的数目。第个顶点和最后一个顶点相同的路径称为回路或环（Cy）。序列中顶点不重复出现的路径称为简单路径除了第一个顶点和最后一个顶点之外，其余顶点不复出现的回路，称为简羊回路或简单环。
在无向图G中．如果从顶点到顶点有路径，则称。和过是连通的。如果刈十图中任意两个顶点0满eV'浏和的都是连通的．则称G是连通图（Conn“ “ d Graphh图 7．]伟）中的就是．个连图，而图7．3〈的中的纭则是非连通图，但0有3个连通分量，如图7，3〈b）所示。所谓连通分A(Connecled C。mp。以(t)，指的是无向图中的极大连通子图
图i.3无向图及其连通分
〔到无向图0；（的0的3个连分量
在有向图G中，如果对于每一对“嫣e v' “学0从彗到和从屿到。都存在路径，则称G是强连图。有向图中的极大强连通子图称做有向图的强连通分量。例如图
7．枞a）中的Gl不是强连通图，但它有两个强连通分量，如图7．4所示。
一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成棵树的”一I条边。图7．5是0中最大连通分暈的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间了第二条路径。 图7．4 G的两个强连通分黾 图7．5位的最大连通分量的一棵生成树
棵有靛个顶点的生成树有且仅有判一1条边 如果一个图有个顶点和小子”一I条边，则是非连通图。如果它多于一1条边，则一定有环。但是，有一1条边的图不一定
是生成树
0 9
如果个亻]向图恰有个点的人度为0，其余顶点的人度均为1，则是一棵有向树。
、个有向图的生成森林山若十棵有向树组成，含图中全部伸点，但只，自是以构成着《棵不相交的有向树的弧。图7．6所示为其一例图/．6一个有向图及其生成纛林
在前述图的基本操作的定中，关于“顶点的位置”和“邻接点的位置"只是一个相对的概念。因为，从图的逻辑结构的定义来看，图中的顶点之间不存在全序的关系（即无法将图中顶点排列成一个线忄1序列），任何一个坝点都用被看成是第一个坝点；另一方，任顶点的邻接点之间也不存在次序关系。但为了操作方便，我们需要将图中顶点按任意的顺序排列起来（这个排列和关系VR无关）。山此．所谓“顶点在图中的位置”指的是该顶点在这个人为的意排列中的位置（或序号）。同理，可对某个顶点的所有邻接点进行排队，在这个排队中自然形成了第一个或第差个邻接点。若某个顶点的邻接点的个数大于差，则称第々十1个邻接点为第个邻接点的卜一个邻接点，面最后一个邻接点的卜个邻接点为“空，。
7，2图的存储结构
在前面几章讨论的数据结构中，除了广义表和树以外，都可以有两类不同的存储结构，它们是由不同的映像方法（顺序映像和链式映像）得到的。由于图的结构比较复杂，任意两个顶点之司都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序映像的存储结构，但可以借助数组的数据类型表示儿素之间的关系。另方面，用多重链表表示图是自然的事，它是种最简单的链式映像结构，即以个由一个数据域和多个指钊域组成的结点表示图中一个顶点，其中数据域存储该顶点的信息，指针域存储指向其邻接点的指针，如图7，7所示为图7．1 中有向图和无向图0的多重漭表。们是，山丁图中各个结点的度数各不相同，最大度数和最小度数'刂能相差很多，因此，若按度数最大的顶点殳计结结构，则会浪费很多存储单元；反之，若按每个顶自己的度数设计不同的结点结构，又会给操作带
160 ·图7．7图的多重链表
）0的多重链表；(b) 0的多锖表来小便、因此，和树类似，在实际应用中不宜采用这种结构，而疴根据具体的图和需要进行的谋作，设计恰当的结点结构和表结构。常用的有邻接表、邻接多难表和十字链表。下面分别讨论。
7．2，1数组表示法
用两个数组分别存储数据元素（顶点冫的信息和数据元素之间的关系（边或弧）的信息。其形式描述如下：
·图的数组（邻接矩阵）存储表小
#define INFINIT'Y IN'] MAX 最人值四
# define MM VF.RTF.X NIJY？0 最大顶点个数
typed-f enun DN.区，Gcaph%ind' {有向图，有向网，无向图·无向网} typedef自t蜘ct ArcceJl {
VRltYPe adii “Type是顶点关系类型。对无权图，用1或0 ／7表示相邻否对带权图，则为权值类型。
InfoType № f #该呱相关信息的指针
} №℃Cell， Adj了[ A×一VERTEX NI书们0忪N圃们；
typedeE struct {
VertexTyve N團到； /7顶点向碌 AdiMatrix，re出 ，女邻接矩阵
int vexnuro，arcnultl； 图的当前顶点数和呱数
CraphKind kind' 图的种类标志 } MGcaph；
例如，图7，1中0和的邻接矩阵如图7，8所示“以二维数组表示有捏个顶点的图时，需存放“个顶点信息和个弧信息的存储量。若考虑无向图的邻接矩阵的对称性，则可采用缩存储的方式只存人知阵的下三角（或上三角）元素。
Cll.arcs = G2. arcs =
图7．8图的邻接矩阵
借助于邻接矩阵容易判定任意两个顶点之间是否有边（或弧）相连，并容易求得各个顶点的度。对于无向图，顶点的度是邻接矩阵中第行（或第i列）的元素之和，即
TD()D：乥A [门0 ]：MAX- VERTEX- NUM)
对于有向图，第，行的元素之和为顶点的出度0D0），第丿列的元素之和为顶点丐的人度）00。
网的邻接矩阵可定义为
0，，若恸：，V,>或（）e VR
例如，图在9列出了一个有向网和它的邻接矩阵。图}，9网及其邻接矩阵（的网凿（树邻接矩阵
算法7，]是在邻接矩阵存储结构MGraph上对图的构造操作的实现框架，它根据图 G的种类调用具体构造算法。如果G是无向网，则调用算法7，2。构造一个具有个顶点和e边的无向网G的时间复杂度是000F，“，其中对邻接矩阵G，“ cs的初始化耗费了0（，的的时间。
Status CreateGraph( MGraph bG）{ 采用敵纟旧邻接矩蔭）表小法，构造图 n叙& G in山；
'*itch〈G．k炻山{
ca凶《 return CreateI)G( G)；
构造有向图G
000e DN：return CreateDN( G);
／/构造豹向网G
return CreatelJDG(G);
汐构造无向图G
cage (I)N：妃豇n）； def》It：reeurn ERR()RJ
构造无向网G
}汐CteateGraph
算法7．1
CreatetJDN(MGtaph & 0 {
//采川数纟眍邻接矩）表示法，构造无向网‰
Neanf（．&G．，& Enclnfo）； 另0 “ f。为0则各弧不含其他信息 for f-i= 0：“““；+ + 1）虻f构造顶点向量 for () = 0；i<G.vexnufi1；+ + i） 初始化邻接矩阵 for 0 0；j < G 0×'地叫+ + j）{INFINITY,島； {配j．f司
For（：0；< G．a疒enu们；+ k）{ 构造邻接矩阵
／/输人一条边依附的顶点及权值玉还LocaEeVcx().、刁 j。Localevex(G. v2);／/确定国和在G中位置
。哟 在弧<，>的权值
(Inclnfo) Input( H G ℃ //若弧含有相关信息，则输人 G.ar〔：j]到：：G ℃寸0 0到； 置《VI “ 2》的对称孤．《．1》、
return 0只；
)
CreateUDN
算法
7．2
· 1 6 2 ·
在这个存储结构上也易于实现7，2节所列的基本操作。如.FIRST A刷（G．0找。的第一个邻接点。首先，由LOC ?"ERI杰.N'（G，找到。在图G中的位置，即。在一维数组ve × s中的序号则二维数组“ cs中第行上第一个a山域的值为“ 1 ”的分量所在列号丿，便为v的第一个邻接点在图G中的位置。同理，下一个邻接点在图G中的位置便为丿列之后第一个adj域的值为“ 1 ”的分量所在列号。
7．2．2邻接表
邻接*(Adjacency List)是图的一种式存储结构。在邻接表中，对图中每个顶点建立一个单链表，第个单彘表中的结点表示依附于顶点醐的边（对有向图是以顶点“ 为尾的弧）。每个结点由3个域组成．其中邻接点域（a山vex）指示与顶点邻接的点在图中的位置，链域（nextarc）指示下一条边或弧的结点；数据域()n的存储和边或弧相关的信息，如权值等。每个彘表上附设一个表头结点。在表头结点中，除了设有域0～arc）指向錈表中第一个结点之外，还设有存储顶点“的名或其他有关信息的数据域（data)。
如下图所示
表结点 头结点
nextarc
data
这些表头结点〔可以縫相接）通常以顺序结构的形式存储，以便随机访问任一顶点的链表，例如图；0叭的和（所小分别为图六}中和‰的邻接表。一个图的邻接表存储结构可形式地说明如下，
一图的邻接表存储表示一
# ?曳“ MAX. V尾× NUM 20 typ?d?f ArcNOde {
adjvex; //该呱所指向的顶点的位置
St et了CNOde诗nextaxe； 指向下一条弧的指针 Il证0'1' 0 info； /咳弧相关信息的指到 )ArcNocie;
t def struct VNOde {
VertexType data; 顶点信息
AreNOde ，指向第一条依附该顶点的孤的指针
}VN?de，AdiL?etLMAX-佣×． N皿」； typed?f {
AdjList vertices;
vexnuJu，；
图的当前顶点数和弧数
int
kind;
图的种类标志
} ALGraph：
若无向图中有个顶点“条边，则它的邻接表需个头结点和2e个表结点。显然，在边稀疏@《 2 ）的情况下，用邻接表表示图比邻接矩阵节省存储空间，当和边相
关的信息较多时更是如此
1 6 3，
在无向图的邻接表中，顶点。的度恰为第/个表中的结点数；而在有向图中，第i个铸表中的结点个数只是顶点孬的出度，为求人度，必须遍历整个邻接表。在所有链表中只邻接点域的值为i的结点的个数是顶点的人度。有时，为了便于确定顶点的人度或以顶点 “为头的弧，可以建立一个有向图的逆邻接表，即对每个顶点皓建立一个浒接以喏为头的弧的表，例如图7，10（的所示为有向图Gl的逆邻接表。
在建立邻接表或逆邻接表时，若输人的顶点信息即为顶点的编号，则建立邻接表的时间复杂度为00十刁，古则，需要通过查找才能得到顶点在图中位置，则时问复杂度为0（“的
在邻接表上容甥找到任顶点的第图7．蜘 邻接表和逆邻接表
一个邻接点和下一个邻接点，但要判定 Gl的邻接表；（蘄的邻接表；@ ‰的逆邻接表
任意两个顶点和屿）之间是否有边或孤相连，则需搜率筇个或第个漭表，因此，不及邻接矩阵方便。
7 · 2．3十字链表
十字彘表（Orth。№ n引I」st）是有向图的另一种式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种铸表。在十字表中，对应于有向图中每一条弧有“个结点，对应于每个顶点也有一个结点。这些结点的结构如下所示:
孤结点 帅 点结点
data
injO
tailvex headvex〕k！ tiinkiirstin firstou《
在弧结点中有5个域：其中尾域（ta小'ex）和头域（hea小-）分别指示弧尾和弧头这两个顶点在图中的位置，域nk指向孤头相同的下一条弧，而域tl而k指向弧尾相同的下一条弧，化域指向该弧的相关信息。弧头相同的弧在同一表上，弧尾相同的弧也在同一链表上。它们的头结点即为顶点结点，它由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等山r n和6 “艹t为两个域，分别指向以该顶点为胍头或弧尾的第一个弧结。例如，图7．Il（a）中所小图的十字链表如图7．Il（房所示。若将有向图的邻接矩阵看成是稀疏矩阵的话，则十字表也可以看成是邻接矩阵的链表存储结构， 在图的十字链表中，弧结点所在的链表非循环链表，结点之间相对位置自然形成，不一定按顶点序号有序，表头结点即顶点结点．它们之间不是接，而是顺序存储
1 6 4 ·(b)# define MAX _ VERTEX_ NUM 20typedaE gtruct VexN0de {
VertexType data
} VexNode ; hypedef a?ruct {for (k — O; k<G. arcnultl; -b
i OcateVex(C, VI ) ;
P ( ArcBox ) malloc ( sizeoE (ArcBo*)) i, j, G- xhistfjl first_in, G
// {tailvex, headvex, hl ?nk, t] ink, info}
G. ist[j-?. firsLLn G. xlistl t jrstout = p;
? 1 6b ?
if (Inclrtfo) Input( @ P—、'山fo
}汐CreateDG//若弧含有相关信息，则输人算法7，3
在-l字表中既容易找到以为尾的弧，也容易找到以为头的弧，因而容易求得顶点的出度和人度（或需要，可在建立十字链表的同时求出）。同时，由算法7，3可知，建立十字链表的时间复杂度和建立邻接表是相同的。在某些有向图的应用中，十字憐表是很有用的主具。
7，2．4邻接多重表
邻接多重表(Adjacency Mult山(t )是无向图的另一种式存储结构。虽然邻接表是无向图的一种很有效的存储结构，在邻接表中容易求得顶点和边的各种信息。但是，在邻接表中每一条边@，凸）有两个绎点，分别在第i个和第j个縫表中，这给某些图的操作带来不便。例如在某些图的应用问题中需要对边进行某种操作，如对已被搜索过的边作记号或删除一条边等，此时需要找到表示同一条边的两个结点。因此，在进行这一类操作的无向图的问题中采用邻接多重表作存储结构更为适宜。
邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示，它由如一卜所示的6个域绀成：
ilinll
ilink
其中，．k为标志域，可用以标记该条边是否被搜索过；iv“和jvex为该边依的两个顶点在图中的位置黼nk，指向下一条依附于顶点iv“的边訕nk指向下一条依绀于顶点 J “ x的边，in化为指向和边相关的各种信息的指针域。每一个顶点也用一个结点表示，它由如下所示的两个域组成：
firstedge
0
其中．data域存储和该顶点相关的信息，右“ ed “域指示第一条依绀于该顶点的边。例如，图702所示为无向图0的邻接多重表。在邻接多重表中，所有依附于同一顶点的边串联在同一链表中岫于每条边依附于两个顶点，则每个边结点同时链接在两个链表中。可见，对无向图而言，其邻接多重表和邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。因此，除了在边结点中增加一个标志域外，邻接多重表所需的存储量和邻接表相同。在邻接多重表上，各种基本操作的实现亦和邻接表相似。邻接多重表的类型说明如下：
一无向图的邻接多重表存储表示
*define ×一R] X二№ 20 def {unvisited, visited} 在噁d struct EBOx {
VisitIf mark 访问标记
166 图7．] 2 无向图0的邻接多重表
int jvex；／/ 该边依附的两个顶点的位置
struct EBox 诗过№k．jlink:// 分别指向依附这两个顶点的下 InfoType 卧info i 丝'该边信息指针
}EBOx;
Eyp?d?f 3EruCE VexBOx { VertexType山0》；卜0 和f汾刂0 指向第一条依附该顶点的边
条边
typedef struct {
VexBOX adimul igtLMAX．矸X．N丽1；
int vexnum, edqenum;无向图的当前顶点数和边数 } AMIGraph；
7．3图的遍历
和树的遍历类似，在此，我们希望从图中某顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。这一过程就叫做图的遍历（Tra “ rsi Graph)o图的遍历算法是求解图的连通胜问题、拓扑排序和求关键路径等算法的基础。
然曲，图的遍历要比树的遍历复杂得多。因为图的任一顶点都可能和其余的顶点相邻接、所以在访问了某个顶点之后，可能沿着某条路径搜索之后，又回到该顶点上。例如图7．1（中的Ge，由于图中存在回路，因此在访问了仂“ “ “之后，沿着边〈婊“ 0又可访问到仂。为了擗奂同一顶点被访问多次，在遍历图的过程中，必须记下每个巳访问过的顶点。为此，我们可以设一个辅助数组v国ted@。n一0，它的初始值置为“假”或者零，一旦访问了顶点“便置*ItedCil为“真”或者为被访问时的次序号。
通常有两条遍历图的路径：深度优先搜索和，、度优先搜索。它们对无向图和有向图都适用。
7．3．《深度优先搜索
深度优先搜索（帙p山First Sea的遍历类似于树的先根遍历，是树的先根遍历的
假设初始状态是图中所有顺点未曾被访问，则深度优先搜索可从图中是个顶点。出发．访问此顶点，然后依次从。的末被访问的邻接点出发深度优先遍历图．直至图中所和和，有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中，个未曾被访问的顶点作起始点，重复」述过程，直图中所有顶点都被访问到为什
以图7口3（的中无向图0为例，深度优先搜索遍历图的过程如图毳1 3〔的所示
假设从顺点出发进行搜索，在访问了顺点之后．选邻佞点。因为。，《曾访问，图70 3晌历图的过程
00无向图0 0睚僅先轉索的过程；（0了度优先索的过程
则从出发进行搜索。依次类推，接着从瞒满出发进行搜索。在访问了之后，由于的邻接点都己被访问，则搜索回到。山于同样的理由，搜索继续回到“直厼 1、此时由于℃ 1的另一个邻接点未被访问，则搜索又从仂到．再继续进行下去。甴此，得到的顶点访问序列为： 显然，这是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组训亩ed [ 0：冖0．其初值为“同"，“旦某个顶点被访问，则其相应的分量置为“ tr艹"整个图的遍历如算法7．4和7．5所示．萁屮> 0表小存在邻接。图中以带箭头的粗线表小遍历访回路径．过带箭头的虚线表示回溯的路径“图中的小圆表小已被访回过的邻接点，人圈表示访问的邻接凵
一算法/ 0和0 5使用的全局变量
Boolean is；0d0 №以目； 方访问标忐数组
Status（鬢1五3讠上F酊℃ " (玉nt的： 函数变量
void DESTraverse(Graph G，Status（Visit) (int.、冫{
／7对图G作深度仇先遍历。
Xh$itFunc Visit; 在使用全局变量` tFu阢，使s不必设函数指针爹数 for (v 0；v (). + + V) visitedLv FALSE； 0方回标志数组初始化 for（鼕二Qi vs:2G, vexnullli + + v)
if ( !vifiited[vl ) DFS()?的；对尚禾访问的顶点膶用
算法7．4
void DFS(Graph C，int v) {
汐从第v个顶点出发递归地深度仇先遍历图G。
visited[vl = TR〔VisiCFunc(v)；访问第v个顶点
for（“ = Firstm?jVe*(G，的；的 一0；“ ' NextAcl%Vex(G，v，）
if (!visitedl_wl) LIES().； ／'对v的尚未访问的邻接顶点递归调用
算法7，5
分析L述算法，在遍历图时，对图中每个顶点至多调用一次DES函数，因为一原某个顶点被标志成已被访问，就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程“其耗费的时问则取决于所采用的存储结构。当用0维数组表示邻接矩阵作图的存储结构时，查找每个顶点的邻接点所需时间为00的，其中为图中顶点数。而当以邻接表作图的存储结构时，找邻接点所需时间为00），其中，为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为0 +刁。
7．3，2广度优先搜索
广度优先N*(Breadth-First search）遍历类似于树的按层次遍历的过程。
假设从图中某顶点的出发，在访问了t'之后依次访问@的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点"先于“后被访问的顶点的邻接"被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访回的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以 为起始点，山近至远，依次访问和@有路径相通且路径．长度为1，2，一的顶点。例如，对图0进行广度优先搜索遍历的过程如图7．13（所示，首先访问和曲的邻接点仂和 ，然后依次访问屿的邻接点和及瞒的邻接款“和仂，最后访问的邻接点。由于这些顶点的邻接点均已被访问，并且图中所有顶点都被访问，由此完成了图的遍坊得到的顶点访问序列为 和深度优先搜索类似，在遍历的过程中也需要一个访问标志数组。并且，为了顺次访问路径长度为2、3、“．的顶点，需附设队列以存储已被访问的路径长度为1，2，．“的顶点。
广度优先遍历的算法如算法7．6所示
void EFSTraverse(Graph G，Stetus（誕Vi $ 0（土吡v) ) {
／/按广度优先非递归遍历图GO使用辅助队列Q和访问标志数组3。
for ()= 0：v<G.vexnuNI;十+到visitedCv_l = FALSE；
InitQueue（Q)i ／/置空的辅助队列Q for（v =山+ + v）
（！v讷让司〔到）{ v尚未访问 visited「v]。TRUE; V跹（V丛
EnQueue(Q，v); ／7 v人队列 while (!Queue?npty(Q))
DeQueue(Q，u)； ／／队头元素出队并置为
for（卜．让st№〕Vex（G，u) ; w> = “ = NextAdjVex(C，）还（！Visited[wl) ／为u的尚未访问的邻接顶点
Vi $址〔到TRUE;
EnQueue（Q
o纟if while
}／／BFSTraverse
算法7，6
分析上述算法，个頂点至多进一次队列。历图的过程实质上是通过边或弧找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，两者不同之处仅仅在于对顶点访问的顺序不同
7．4图的连通性问题
在这一节中，我们将利用遍历图的算法求解图的连通性问题，并讨论最小代价生成树以及重连通性与通信网络的经济性和可靠性的关系。
7．4．1无向图的连通分0和生成树
在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。对非连通图，则箭从多个顶点出发进行搜索，而每一次从一个新的起始点出发进行搜索过程中得到的顶点访问序列恰为其各个连通分量中的顶点集。例如，图7．3中的G是非连通图，按照图7．14所示G3的邻接表进行深度优先搜索遍历，3次调用I)FS过程（分别从顶点A、D和G出发）得到的顶访问序列为
A L M ] B F C D E G K H
这3个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图G、的3个连通 t70 ·
分量．如图7．3（b)所示。
没E（0为连通图G中所有边的集合，则从图中任顶点出发遍历图时．必定将 E(G)分成两个集合T（G)和G），其中 '1'( G)是遍历图过程中历经的边的集合； B（G）是剩余的边的集合。显然，T〈G）和图 G中所有顶点一起构成连通图G的极小连通子图，按照7，1节的定义，它是连通图的一棵生成树，并且称由深度优先搜索得到的为深度优先生成树；由广度优先搜索得到的为广度优先生成树。例如，图7．1 5（a）和图7．] 4 GN的邻接表 （b）所巫分别为连通图的深度优先生成树和广度优先生成树，图中虚线为集合 B(G)中的边
对于非连通图，每个连通分量中的顶点集，和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。例如，图7，1 5（的所示为0的深度优先生成森林，它由3棵深度优先生成树组成“
假设以孩了兄弟彘表作生成森林的存储结构，则算法7．7生成非连通图的深度优先生成森林，其中DFSTree函数如算法 /，8所示。显然，算法7，7的时间复杂度和遍历相同。
vo谰DF$Foregt (Graph ‰ CSTree (T)（
／／津立无向图G的深度优先生成森林的
／7（最左）孩了（右）兄弟链表T。
图7．15生成树和生成森林
for ()= 0；v<G.vexnuru; ++v) (a)的深度优先生成树， vis itedCv] 伟）的广度优先生成树： for (v =山v<C,vexnun；++的 （0）的深度优先生成森林
第v顶点为新的生成树的根结点
(CSrree) ?alloc (sizeoE (CSNode))；分配根结点
{ GetVex(G,v)，NULL，NULL应 //给该结点赋值
珏0 T) T P； 汐是第一棵4成树的根（T的根）
else q一少nextsibl ing P； 是其他生成树的根〔前、棵的根的“兄弟”）
P； q指示当前生成树的根 DESTree(). v, p) i 建业以p为根的生成树
/ DFSFO〕上引二
算法7．7
void DFSTree(Graph G, int，CSTree (T) {
／7从第v个顶点出发深度优先遍历图G，建立以1'为根的生成树。
visited「v]；TRUE; first；TRUE；
for（FisrtAdjVex(C，v)；“ = 0：= NextAdjVex(C，冫
(C$'l'cee) “1100 (sizeof (C3NQde))； 分配孩子结点
。{ Get.Vex(G.N)，NULL. NULL 0
(first) {
“是v的第一个未被防问的邻接顶点
T->lchild ' if
曰巧t = F訌$礅
／/是根的左孩子结点
el $0 {
“是v的其他未被访问的邻接顶点
q->ne'ctsib1iX1g
是上一邻接顶点的右兄弟结点
DFSTree()'
}// DFSTtee
q) ;
从第“个顶点出发深度优先历图建立了生成树q
算法7．8
7．4．2有向图的强连通分佩
深度优先搜索是求有向图的强连涌分量的一个的有效方法。假设以十字链表作有向图的存储结构，则求强连通分量的步骤如下：
( l )在有向图G上，从某个顶点出发沿以该顶点为尾的弧进行深度优先搜索遍历，并按其所有邻接点的搜索都完成〈即退出D吓函数）的顺序将顶点排列起来。此时需对 7．3口中的算法作如下两点修改：（的在进丿、DFSTraverse函数时首先进行计数变量的初始化，即在入口处加上count—O的语句；伟）在退出OFS函数之前将完成搜索的顶点号记录在另一个辅助数组finished(vexnuml中，即在I)FS数结束之前加上finished( * +
的浯句
（2）在有向图G上，从最后完成搜索的顶点（即{ imshed [ vexnum一1 ]中的顶点）出发，沿着以该顶点为头的弧作逆向的深度优先搜索遍历，若此次遍历不能访问到有向图中所豹顶点，则从余下的顶点中最后完成搜索的那个顶点出发，继续作逆向的深度优先瞍索遍历．依次类推，白至有向图中所有顶点都被访问到为止。此时调用吓“吓e时需作如下修改：求数中第二个循环语句的边界条件应改为从fin 这h司[ 0 10
由此，每一次调用DES作逆向深度优先遍历所访问到的顶点集便是有向图乙中个
强连通分量的顶点集
例如图7口1所示的有向图，假设从顶点仂出发作深度优先搜索遍历，得到
@ ] 72，
数组中的顺点号为口0．2，0)刂再从顶点讷出发作逆向的深度优先搜索遍历，得到两个顶点集0，。“和。：，这就是该有向图的两个强连通分量的顶点集。
上述求强连涌分量的第步．旦实质为：（]）构造一个有向图G，，设G亠0，{A的．则 G,一(V，00），对丁所响，《A，必有与,v,) e A,。即Gr中拥有和G方向相反的弧；（2）在有向图G上，从顶点finished[vexnutn- 0出发作深度优先搜索遍历。可以证明，在Gr上所得深度优先生成森林中每一棵树的顶点集即为G的强连通分量的顶点集「。
显然，利用遍历求强连通分是的时间复杂度亦和遍历相同。
7，4．3最小生成树
假设要在月个城市之间建立通信联络网，则连通”个城市只需要月一1条线路。这时，自然会虑这样一个问题，如何在最节省经费的前提下建立这个通信网。
在每两个城市之间都可以设置一条线路，相应地都要付出一定的经济代价。“个城市之间，最多可能设置”一0叾2条线路，那么，如何在这些可能的线路中选择月一]条，以使总的耗费最少呢？
可以用连通网来表不n个城巾以及个城市间可能设置的通信线路，其中网的顶点表示城市，边表示两城市之间的线路，赋于边的权值表示相应的代价。对于，，个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。在，我们要选择这样一棵生成树，也就是使总的耗费最少。这个问题就是构造连讪网的最小代价生成树卣对Spanning石。的《間你为最小生成树）的问题“一棵生成树的代价就是树下各边的代价之和
构造最小生成树可以有多种算法：．其中多数算法利用了最小生成树的下列种简称为Ms-I'的性质：假设、一（0 E）是一个连通网上是顶点集V的一个非空子集。若 0-p)是一条具有最小权值（代价）的边，其中`长0 “ e V'一出则必存在一棵包含边，湖的最小生成树
可以用反证法讯明之。假没网N的仃何一棵最小生成树都不包含0` “）。设T是连涌网上的一棵最小生成树，当将边0加人到T中时，由生成树的定义，T中必存在、条包含“）的回路。另方面，山于丆是生成树，则在T上必存在另一条边（，的，其中是〔0 “' Gv一0，且和之间，。和。'之间均有路径相通。删去边紜' “ '），便可消除上述回路，同时得到另一棵生成树尸。因为（厶(')的代价不高于（），则T'的代价亦不高于T，了是包含，0的一棵最小生成树。山此和假及矛盾。
普里姆（prim）算法和克鲁斯卡尔（Kr卟k走算法是两个利用MST性质构造最小生成树的算法。
下面先介绍普甲姆算法。
假设N一霪，{ 0）是连通网，"PE是上最小生成树中边的集合。算法从0：{ 不V），TE一0开始．車复执行下述操作在听有001 v一(J的边，劢〔E中找条代价最小的边褂〕并人集合丆E．同时“并人直至0一V为止。此时TE中必有1条边，则T—，口F 0为N的最小／卜成树
1 7 3 ·
为实现这个算法需附设一个辅助数组edge，以记冢从卩到V卩具有最小代价的边。对每个顶点eV一0，在辅助数组中存在一个相应分量山d離0一0，它包括两个域．其中toweost存储该边的权。显然，
closedge[i— l l. low四引一M山
O
(c)
图7，16普里姆算法构造最小生成树的过程
vex域存储该边依附的在0中的顶点。例如，图7．16所示为按普里姆算法构造网的一棵最小生成树的过程，在构造过程中辅助数组中各分量值的变化如图7，17所示。初始状态
0
4
地 k 0 思 5
；idjvex lowcost
6
adJVex loweOst ndivex
V《
4
2
0
到 3
ad)vex
IOWCOSi
0
0
0
0
0 到
adjvex lowcost
0
0
0
0
8djvex lowcost
0
0
0
0
《，Vt，Vs 0
图707图706构造最小生成槲过程中辅助数组中各分佩的值
时，山于0一{ 1心，则到v一0中各顶点的最小边，即为从依附于顶点1的各条边中，找到。条代价最小的边〈斯“〕一( l，3）为生成树上的第一条边，同时将眦（。）并人集合0 然后修改辅助数组中的值。首先closedgeL2」．尾w四巛改为0 '，以示顶点己并人的“、1在，@表小賦边，刎的权
然后，由于边3．上的权值小于osed 01 Iowco $ t，则需修改closedge[ll为边（0，。）及其权值。同理修改山sed「到和山se山：硨到。依次类推，直到0一0假设以一维数组表示网的邻接矩阵，且令两个顶点之间不存在的边的权值为内允许的最大值
(INT一MA №．则普里姆算法如算法六9所示
void MiniSpanTree PRIM( YGraph G，VertexType u丿{
用普里姆算法从第u个顶点出发构造网G的最小生成树T，输出T的各条边。
记录从顶点集U到v一〔J的代价最小的边的辅助数组定义；
“c上{
VertexType adjvex； VRType 10H005L；
// } closedgeFMM VERTEX．即明； k；LocateVex（G' u月
for〔j 0薹羊《G vex:nurn；十十-j） 辅助数组初始化
辽()! = k) closedge[j- =！山G．a代虬k北计adj蹈{adjvex，1 “c 0
／/初始，0到国
//选择其余1个顶点 求出T的下一个结点：第k顶点
／/此时closedgeCkI 1“亡0吡=
MIN{酗0 $劂ge [ v冂彐0凶00吡《clO$edgeCvj〕．10 0 > 0，0 } printf(c10sedgeCkl adjvex. G, vexgCkl)； 输出生成树的边回0* ge〔k」彐0：= ／/第k顶点并人U集
for 0 =山j<.G. '沁刈luni；+1 j）
迳（G · ℃可kl[到．adj 0 0 dge〔到过0艹0s0 #新顶点并人0后重新选择最
小边
亡“do矸G ““5球]，G.aresCk1Ujj. adj i；
} MiniSpanTree
算法7．9
例如，对图7．1 6（a)中的网，利用算法7．叭将输出生成树上的5条边为0，）， 分析算法7．9，假设网中有月个顶点，则第一个进行初始化的循环语句的频度为”，第一个循环语句的频度为”一1。其中有两个内循环：其一是在山sedg到．wc。st中求最小值，其频度为”一1；其二是重新选择具有最小代价的边，其频度为，，。由此，普里姆算法的时间复杂度为0），与网中的边数无关，因此适用于求边稠密的网的最小生成树
而克鲁斯卡尔算法恰恰相反，它的时间复杂度为叭山g的0为网中边的数囗），因此它相对于普里姆算法而言，适合于求边稀疏的网的最小生成树。
克鲁斯卡尔算法从另一途径求网的最小生成树。假设连通网N一（V，})，则令最小生成树的初始状态为只有个顶点而无边的非连通图T一（V巛D，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加人到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T 中所有点都在同连通分量就为止。
例如，图7．18所示为依照克鲁斯卜尔算法构造一棵最小生成树的过程。代价分别为图7．18克鲁斯卡尔算法构造最小生成树的过程
I，2，3，4的4杀边山丁满足」述条件，则先后被加人到T中，代价为5的两条边（“0 和陆“0被舍去、因为它们依附的两顶点在同一连通分量上，它们若加人T中，则会使 T中产生回路，而忄一条代价（一5）最小的边@泓）联结两个连通分量，则可加人Te由此，构造成棵最小生成树
上述算法至多对e条边各扫描一次，假若以第9章将介绍的“堆”来存放网中的边，则每次选择最小代价的边仅需] og的的时间（第一次需0（的珧又生成树T的每个连通分量可看成是一个等价类，则构造T加人的边的过程类似于求等价类的过程．山此可以以6．5节中介绍的MFS类型来描述T，使构造1的过程仅需0。g的的时间，山此，克鲁斯尔算法的时间复杂度为0（小@）。
7，4，4关节点和连通分趾
假若在删去顶点。以及和。相关联的各边之后，将图的一个连通分量分割成两个或两个以上的连通分量，则称顶点“为该图的一个关节点（art “ lion point)。一个没有关点的连通称为是重连通图（b “ nn “ ted graph)?在重连通图上，任意一对顶点之间至少存在两条路径，则在删去某个顶点以及依附于该顶点的各边时也不破坏图的连通世。若在连涌图上至少删去差个顶点才能破坏图的连通性，则称此图的连晒度为关节点和重连通在实际中有较多应用。显然，一个表示通信网络的图的连通度越高，其系统越可靠，无论是哪一站点出现故障或遭到外界破坏，都不影响系统的正常工作；又如，一个航空网若是重连通的，则当某条航线因天气等某种原因关闭时，旅客仍可从别的航线绕道而行；再如，若将大规模集成电路的关键线路设计成重连通的话，则在某些元件失效的情况下，整个片子的功能不受影响，反之，在战争中，若要摧毁敌方的运输线，仅需破坏其运输
网中的关节点即可
例如，图7．19中图位是连通图，但不是重连涌图。图中有4个关节、、r)和
若删去顶点6以及所有依附顶点B的边，G5就被分割成3个连通分量囝、c&、L、M， 176
》、@、、K》和{、下后类似地，者删去顶点為或0或G以及所有依附于它们的边，则0被分割成两个连讪分量，由此，关节点亦称割点。
利用深度优先搜索便可求得图的关点，并由此可判别图是否是重连通的。 图0图0 图7．20 0的深度仇先生成树
图在20所示为从顶点，A出发深度优先搜索遍历图GS所得深度优先生成树，图中实线表树边，虚线表示回边（即不在生成树上的边）。对树中任一顶点如而言，其孩子结点为在它之后地索到的邻接点，而其双亲结点和由回边联结的祖先结点是在它之前拽索到的邻接点。山深度优先生成树可得出两类关兯点的特性：
（的若生成树的根有两棵或两棵以上的子树，则此根顶点必为关节点。因为图中不存在联结不同子树中顶点的边，因此，若删去根顶点，生成树便变成生成森林。如图7、20 中的顶点
（2）若生成树中某个非叶子顶点@，其某棵子树的根和子树中的其他结点均没有指向，的祖先的回边，则为关节点。因为，若删去山则其子树和图的其他部分被分割开来。
如图7．20中的顶点13、0和G
若对图Gra旆：（N"、{ E録( } )重新定义遍历时的访问孓数“ ited，并引人一个新的数w，则山一次深度仇先搜索遍历便可求得连通图中存在的所有关节点。
定义巛ited吓'」为深度仇先搜索遍历善通图时访问顶点的次序号；定义
“是顶点v在深度优先生成树上的孩了结点； k是顶点v在深度优先生成树由回边联结的
的：Mi以0@非到，1。卦到，vi “忄k」祖先结点，若对 于某个顷巛 有在孩子结当 w是 的孩子结点时 w [ 》由定 义可知亠 茈到值即为
（钔e劂ge，
(ti.k)éEdge.
]冫“i [、，] ， 则该顶点 。必为关节巛。 因为 ited〔到 ， 表明 及其子孙均无指向 。 的祖先的回边。
。 在深度优先/1 成树的前序序列中的序号 ， 只需将OFS函数中头两个语句改为visited。 ]一+ + count（在DFSTraverse中设初值 count— I）即可山w《到可由后序遍历深度优先生成树求得，而。在后序序列中的次序和历时退出DFS吆数的次序相同，由此修改深度优先搜索遍历的算法便可得到求关节点的算法（见算法7，10和算法7湖1)。
?0 d FindArticu1 (Al-Graph G) { 连通图G以邻接表作存储结构，查找并输出c上全部关节点。全局量c。“t 对访问计数。
co =坛visitedC0] //设定邻接表上0号顶点为生成树的根 for（= ]；i<G. ve和1；++）vis跹0」= 0；//其余顶点尚未访问 p = G,vertice5t0]. firstarci v = p—>adjve%J DFSRrt,icnI（‰ v)l 从第v顶点出发深度优先查找关节点。 if (count < G. vexnum) { 生成树的根有至少两棵了些n @，G. vertices[0).data) ; //根是关节点，输出 "bile (p->nextarc) {
= p->adjvex; if (visitedlv] =；@ DFSArticul（g，v)；
〉// while
}夕FindArticu1 算法7．10
0攴d DFSArticuI(RLGraph G' int鼕的{
//从第vo个顶点出发深度优先遍历图G，查找并输出关节点。
visited(v01J。min - ·0以ount;闻是第师上个访问的顶点 for G、“rtice寸丰fir酊0 P' P一0吣雒℃）{对的每个邻接顶点检查／/ “为诩的邻接顶点 if (visited[wA “未曾访问，是@的孩了
DFSArticu1().； 返回前求得1。到
00“「到< min = 1 [明；
00还到>= vi3itedr?v00)些in（，G，“就让eg@0 ]，da蜘）；//关节点
} 01 (vis〔司<翦v这丑谰@玉气巳访问“是vo在生成树上的祖先
}汐for
10w「] = mi山
)// OFSArticu1 算法7, 11
例如，图GS中各顶点计算所得visited和low的函数值如下所列：
0
4
8
10
Il
12
G. vertices[il. data
B
0
D
五
F
G
H
visitedCil
12
10
13
8
6
2
3
扁w[i〕
求得low值的顺序
13
9
8
7
6
3
5
4
] 0
· ] 78 ·
其中J是第一个求得w值的顶点，由于存在回边（丿，L），则1。w凵]：Min sited! J」、 ited〔0：一2。顺便提一句，上述算法中将指向双亲的树边也看成是回边，山于不影响关节点的判别，因此，为使算法简明起见，在算法中没有区别之。
由于上述算法的过程就是一个遍历的过程，因此，求关节点的时间复杂度仍为0（” + 刁。若尚需输出双连通分量，仅需在算法中增加一些语句即可，在此不冉详述，留给读者自己完成。
7．5，有向无环图及其应用
一个无环的有向图称做有向无，简称DAG图ODAG 图是一类较豹向树更一般的特殊有向图，如图7，2 1列示了有向树、DAG图和有向图的例子。
有向无环图是描述含有公共了式的表达式的有效丁具。例如下述表达式
（0十0并0“（0+，，山）4（c十d）
图7，豹向树、DAG图和向图一例
的（（c十d）e)
可以用弟6章时论的二叉树来表示，如图7，22所示，仔细观察该表达式，可发现有一些相同的子表达式，如（山和（c + d) “等，在二叉树中，它们也重复出现。若利用有向 图7．22用二又树描述表达式 图7．23描述表达式的有向无环图
无环图，则可实现对相同子式的共享，从而节省存储空间。例如图7．23所示为表示同一表达式的有向无环图
检查一个有向图是否存在环要比无向图复杂。对于无向图来说，若深度优先遍历过程中洇到回边（即指向已访问过的顶点的边后则必定存在环；而对于有向图来说，这条回边有可能是指向深度优先生成森林中另一棵生成树上顶点的弧。但是，如果从有向图上某个顶点，出发的遍历，在d巛v）结束之前出现一条从顶点到顶点》的回边（如图7．24 所示），由于“在生成树上是，的子孙，则有向图中必定存在包含顶点和的环
有向无环图也是描述一项工程或系统的进行过程的有效工具。除最简单的情况之
] 79 ·
外，几乎所有的工程（p词eco都可分为若一了个称做活动（acti “ y）的子工程，而这些了工程之间，通常受着一定条件的约束，如其中某些子工程的开始必须在另．．些子工程完成之后。对整个一下程和系统，人们关心的是两个方面的问题：一是「程能否顺利进行；二是佶算整个程完成所必须的最短时间，对应于有向图，即为进行拓扑排序和求关键路径的操作。下面分别就这两个问题时论之。
7、5拓扑排庳
什么是拓扑排序（T叫对。gi巛№ (t)？简单地说，由
某个集合L的一个偏序得到该集合上的一个全序，这个图7．24含有环的有向图操作称之为拓扑排序。回顾离散数学中关于偏序和全序 的深度仇先生成树的定义，
若集合x上的关系R是自反的、反对称的和传递的，则称R是集合X上的偏序关系。
设R是集合x L的偏序（Partial Order），如果对旬个“，ex必有上R)，或vRc，则称是集合X上的全序关系《
直观地看，偏序指集合中仅有部分成员之间可比较，而全序指集合中全体成员之间均可比较。例如，图7．25所示的两个有向图，图中弧0、，表示上<，，则（a）表示偏序，图／．25表示偏序和全序的有向图
（表小偏序；( l的表示全序
（b）表示全序。若在（a）的有向图人为地加一个表示叻<必的弧〔符号“ <，表示。领先于1和，则（a）表示的亦为全序，且这个全序称为拓扑有序（T 01魄ica区扁(r) '而甴偏序定义得到拓扑有序的操作便是拓扑排序。
一个表示偏序的有向图可用来表示，个流程图·它或者是一个施丁流程图，或者是一个产品生产的流程图，再或是一个数据流图（每个顶点表示一个过程）。图中每一条有向边表示两个子工程之间的次序关系（领先关系)Q
例如，一个软件专业的学生必须学习一系列基本课程（如图7，26所示），其中有些课程是基础课，它独立于其他课程，如《高等数学》；而另一些课程必须在学完作为它的基础的先修课程才能开始。如，在《稃序设计基础》和《离散数学》学完之前就不能开始学习《数据结构》。这些先决条件定义了课程之间的领先（优先）关糸。这个关系可以用有向图更清楚地表示，如图乙27所示图中顶点表示课程，有向边（弧）表示先决条件。若课程是课程i的先决条件，则图中有弧00。
这种用顶点表小活动．用弧表示活动间的优先关系的，有向图称为顶点表示活动的网 ( Activity On Vertex Network) ,简称AOV-网。在网中，若从顶点到顶点j有．条有向路，则是丿的前驱；丿是的后继。若0刁冫是网中条弧，则是丿的直接前驱刁是的直接后继。 课程号 嗶程名称 先决条件
程序设门基础离散数学 0 o 语言的设调和分析 0，0
刂算机原理
图7．26软件专业的学生必须学习的课程
在粼№网中，不应该出现有向环．因为存在环意味着某项活动应以自己为先决条件、显然，这是荒谬的。若设if出这样的流程图，T程使无法进行。而对程序的数艍流图来说，则表明存在一个死循环。因此，对给定的，A()V．网应先判定网中是否存在环。检测的办法是对有回图构造其顶点的拓扑有序序列，岩网中所有顶点都在它的拓扑有序序列中、则该ADV网中
必定不存在环。例如，图7．27的亻向图有如下 图7，27表示课程之间优先关系的南向图
两个拓扑。有序序列，
（0，0
和
（C“ C闊，01．0，0，02，0，0，0，CG，C。CA)
当然，对此图也可构造得其他的拓扑有序序列)n若某个学生每学期只学一门课程的话则他必须按拓扑有序的顺序来安排学习计划如何进行拓扑排序？解决的乃法很简单；
(l)在有向图中选一个没有前驱的顶点目输出之。
（2）从图中删除该顶点和所有以它为尾的弧。
重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后 一种情况则说明有向图中存在环。
以图7，28（a）中的有向图为例，图中“和没有前驱，则可任选一个。假设先输出，在删除及弧〈“〉，“010之后，只有顺点仂没有前驱，则输出且删去仂及弧以0、以0和〈仂满冫，之后和凸都没有前驱。依次类推，可从中任选一个继续进行。整个拓扑排序的过程如图/．28所示“最后得到该南向图的拓扑有序序列为： 0．V'．01．0》．0 2．V 5 0图7过8 AOV一网及拓扑序序列产生的过程
（的AOV-网输出之后，（c）输之后；
〈巾出之后；（0輸出之后以0嵇出御之后
如何在到算机中实现？钊对上述两步操作，我们可采用邻接表作有向图的存储结构，性在头结点中增加一个存放顶点人度的数组d叩r “）。人度为零的顶点即为没有前驱的顶点，删除顶点及以它为尾的弧的操作，则可换以弧头顶点的人度来实现。
为了谱免重复检测人度为零的顶点，可另设一栈竹存所有人度为零的顶点，山此可得拓扑排序的算法如算法7．12所示。
Statue TopologicalSort(ALGraph G) {
／/有向图c采用邻接表存储结构。
／/若G无回路，则怖出G的顶点的一个拓扑序列并返回0K，否则即R
Findlnnegree( G，indeqt?ee)； 汐对各顶点求人度indegreeC0..vernum- 1 ]for 0 D；+丰0
(lindegreeCil) Pugh(). i)；
CO酊（〕；
／/建零人度頂点栈s
//人度为0者进栈
//对输出顶点计数
Hhil?（！StackFnptY(S))（
Pop(), i); printf(i，G.verticesCil.data); “亡。山／/输出i号硕点并计数 for (p。G. verti℃到．firstarc; p; P：p->ne-%tarc) {
汐对i号顺点的每个邻接点的人度1
一indeqree[kl)) p” h(S，k); //若人度为0．则人伐
} for
}／/ while
珏（CO皿上G．寸n）ERROR; 该有向图有回路 el return OK'
}，7 TopologicalSort
算法 7，12
分忄h算法7．1 2，对确门个顶点和e条弧的，自向图而言，建守求各猡点的人度的时间豆杂度为0（的；建零人度顶点栈的时间复杂度为0的；在拓扑排序过程中，若向图无环，则每个顶点进一次栈，出一次栈，人度减1的操作在WHILE语句中总共执行，次，所以，总的时间复杂度为00曰。上述拓扑排序的算法亦是下节过论的求关键路径的基础。
当有向图中无环，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索崩历时．最先退出DES函数的顶点即出度为零的顶点，是拓扑有序序列中最后个顶点。由此．按退出l)吓函数的先后记录下来的顶点序列（如同求强连通分量时臼园数组中的顶点序列）即为逆向的拓扑有序序列．
7．5．2关键路径
与A（〕v一网相对应的是A()E Bg ( Activity On Edg的即边表示活动的网。A()E一网是一个带权的有向无环图，其中，顶点表示事件（Event），孤表示活动，权表示活动持续的时间。通常，(C)E一网可用来估算上程的完成时间。
例如，图唟29是一个假想的有冂项活动的 AOE网。其中有9个事件仂泓以，' “，每个事件表示在它之前的活动己经完成．在它之后的活动可以开始。如表示整个工程廾始，以表示整个主程结束“表示和已经完成“和“可以月始、与每个活动相联系的数是执行该活动所需
的时间。比如，活动需要6人．的需要天等， 图29 一钅．AOE-网山于整个上程只有一个升始点和、个完成点，
故在正常的情况（无环）下，网中只有一个人度为零的点（称做源点）和一个出度为零的点（叫做汇点）。
和A（)V．网不同，对A00．网有待研究的问题是：0）完成整项工程至少需要多少时间？（2）哪些活动是影响上程进度的关键？
由于在AOE一网中有些活动可以并行地进行，所以完成丁程的最短时间是从开始点到完成点的最长路径的长度（这里所说的路径长度是指路释十各活动持续时间之和，不是路径上弧的数目）。路径长度最长的路径叫做关键路径（Cr冚Path)6假设开始点是仂，从仂到“的最长路径长度叫做事件醐的最早发生时间。这个时间决定了所有以，，为尾的弧所表示的活动的最早开始时间。我们用e ( i )表示活动@的最早开始时间。还可以定义一个活动的最迟开始时间山），这是在不推迟整个工程完成的前提下，活动@ 最迟必须开始进行的时间。两者之差山）一以0意味着完成活动@的时间余量。我们把 / 0）一i )的活动叫做关键活动。显然，关键路径上的所有活动都是关键活动，因此提前完成非关键活动尹不能加快T程的进度。例如图7．29中的网，从到的最长路径是（凸，仍，，、，“。），路径长度是18．即的最早发生时间是18。而活动@的最早廾始时间是5．最迟开始时间是8，这意味着：如果推迟3天廾始或者延迟3大完成．都不会影响整个I程的完成。因此．分枋关钅建路径的目的是辨别哪些是关键活动，以便争取提高关
183
键活动的工效，缩短整个上期。
由上分析可知，辨别关漣活动就是要找以0：／0）的活动。为了求得A00网中活动的以的和怖）．首先应正得事件的最早发彗时间“（》和最迟发生时间司0）。如果活动@山弧0，k}表示，其持续时间记为d禳(j'k)丛则有如下关系求评0〕和（需分步进行：
（1〕从（0）= 0开始向前递推其中，T是所有以第i个顶点为头的弧的集合。
（却从(n一1）一眦一]）起向后递推其中，S是所有以第i个顶点为尾的弧的集合。
这两个递推公式的计算必须分别在拓扑有序和逆拓扑有序的前提下进行。也就是说，“ 0一0必须在的所有前驱的最早发生时间求得之后才能确定，而湿0一1）则必须在马的所有后继的最迟发生时间求得之后才能确定。因此，可以在拓扑排序的基础上计算性（丿一1)+11 0
山此得到如下所述求关鍵路径的算法：
o）输人e条弧与，0，建立A()E一网的存储结构；
（2） 从源点出发，令艹@一：0，按拓扑有序求其余各顶点的最早发生时间眦0 ] (I<i<n—l)?如果得到的拓扑有序序列中顶点个数小于网中顶点数狲则说明网中存在环，不能求关谊路径，算法终止；否则执行步骤（3）。
（3） 从汇点“出发，令司勖 ：ve勖一]〕，按逆拓扑有序求其余各顶点的最迟发生时间0」0冖2 > 0《2）；
（4） 根据各顶点的和值，求每条弧s的最早开始时间e @和最迟开始时间吓）。
若某条弧满足条件e@一枞0，则为关键活动。
如上所述，计算各顶点的“值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改这a）在拓扑排序之前设初值，令“ 0 ]：0@緦< ”一l )这b）在算法中增加个计算乌的直接后继的最早发生时间的操作：若C刀+山云〈j，0）>以〕，则眦[一“「刀．1一d “ '（0，0）山为了能按逆拓扑有序序列的顺序计算各顶点的值，需记下在拓扑排序的过程中求得的拓扑有序序列，这需要在拓扑排序算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的眦值之后，从栈顶至栈底便为逆拓扑有序序列。
先将算法7，12改写成算法7，13，则算法7，便为求关键路径的算法。
· 184，
Status T叩01四j℃ alOrder（ALGraph G，Stack (T) { 有向网G采用邻接表存储结沟，求各须点事件的最早发生时间“（全局变笊），丿T为拓扑序列顶点栈．s为零人度顶点找“ 若G无回路，则用栈T返回G的个炻扑序列“且函敵值为0巛兮则为E朋0砾
FindlnDegree()' indegree);／/对各顶点求人度indegreeC0. , vernum I 建零人度顶点栈s;
InitStack(T)；count =山vel_O., G, vexnusn—刂 ；0：//初始化土le 0 StackEmpty(S)) {
Pop(S，-j〕；Push(y，的； +十count； 号顶点人T栈并计数 for (p；G. vertices[j」，firstarci出p；p ?>nextarc) { k p" ?djvex； 汐'对〕号顶点的每个邻接点的人度减1 一indegree[_kl 过的k)；若人度减为0，则人找
(veCiJ + " (p 。，infeli） veCkl) 曾vet} + (p -> info) ; for p -> info) = dut()i，k.>)
} //司滇e 跹(count<G.vexnum) return ERROR;该有向网有回路 el return OK；
) // Topological(hder
算法7．13
Statua CriticalPath((ALGraph引{
G为有向网啪出G的各项关腱活动。
0 Topo〕.ogica10rder（G．'I））return ERROR； v1C0, .G.vex:mutl ] ] veCC. 初始化顶点事件的最迟发生时间 ile 0 k跏p捫Y（的） 彦按拓扑逆序求各顶点的值 for（Pop()% j〕，V = G.vert ices;「到．f in跹℃；出P = P一》、{ k = p->adivex;下(p ->info) ;
（VI〔一№t《《兯v10汾vl[kll．“ d证；
) //for for (i鞏0；j<G.vexnun; + + ，纟求ee阉．和关活动
《or @。，f五3 re；p；p->nextare)〈 k : p->adjvex; (P->?info) ; ee*瓯到；el= Lag (ee r = el)？． printf () ' k' dl建．艹．邑，g）；彦输出关键活动
} Crit ica1Path
算法7．14
由于逆孙扑排序必定在网中无环的前提下进行，则亦可利用DES函数，在退出OFS 函数之前按式（7．3）计算顶点。的值（因为此时的所有直接后继的湿值都已求出）。
这两种算法的时间复杂度均为00/十刁，显然，前一种算法的常数因子要小些。由十计算弧的活动最早开始时间和最迟开始时间的复杂度为0（e），所以总的求关键路径的时间复杂度为O(n+e) a 例如，对图7．30（所示网的计算结果如图7．31所示，可见，和为关鍵活动· 组成一条从源点到汇点的关键路径，如图7．30（b冫所示。
，] 8 5图030 AOE.网及其关键路径图7．31图7．3嫲的所示八0枷网中@点的发生时间和活动的廾始时回
对．图7，29所示的网，可计算求得关键活动为艹艹艹，鲡和“。如图7，32所小，它们构成两条关路径：“产班，0 “0和（““0，，屿）“
实践已经证明：用A00网来估算某些上程完成的时间是非常有用的。实际十．求关路徑的方法本身最初就是与维修和建造工程一起发展的。但是，由十网中各项活动是互相牵涉的，因此，影响关键活动的因素亦是多方面的，任何．项活动持续时间的改变都会影响关键路径的改变。例如，对丁图7．30@ 所示的网来说，若。的持续时间改为3，则可发现，关键活动数量增加，关键
路径也增加。若同时将山的时间改成4，则0《
图32图四所示网的关路
。，．的不冉是关键路径。由此可见，关键活动的速度提高是有限度的。只在不改变网的关键路径的情况下、提高关键活动的速度习南效。
另一方面，若网中有几条关键路径，那么，单是提高一条关键路径上的关键活动的速度，还不能导致整个上程缩短期，而必须提高同时在几条关键路径上的活动的速度。
7，6最短路径
假若要在计算机上建一个交通咨询系统则可以采用图的结构来表示实际的交通网络。如图7．33所示，图中顶点表示城市，边表示城市间的交通联系。这个咨洵系统可以回答。旅客提出的各种问题。例如．一位旅客要从A城到B城，他希望选择一条途中中转次数最少的路线。假设图中每，站都需要换车，则这个问题反映到图就是要找一条图7．33个表示交网的例图
从顶点A到B所含边的数目最少的路径。我们只需从顶点A出发对图作疒度优先搜索，一旦遇到顺点13就终止。山此所得广度优先生成树上，从根顶点A到顶点的路就是中转次数最少的路径，路径．10A与召之间的帧点就是途径的中转站数，但是，这只是一类最简单的图的最角路径问题。时．对于旅客来说，可能更关心的是省交通费用：而对r司机来说，甲程和速度则是他们感兴的信息。为了在图上表示有关信息，可对边赋以权，权的值表小两城市间的距离，或途中所需时间，或交通费用等等。此时路长度的度量就不再是路径《边的数山而是路径上边的权值之和》考虑到交通图的有向性（如航运，逆水和顺水时的船速就不一样），本节将讨论带权有向图，并称路径上的第．个顶点为源点（S艹rse），最后一个顶点为终点（D吓tina前n）。下面讨论两种最常见的最短路径问题。
7．6．1从某个源点到其余各顶点的最短路径
我们先来讨论单源点的最短路径问题：给定带权有向图G和源点山求从丿到G中其余各顶点的最短路径。
例如，图7．34所示带权向图G。中从“到其余各顶点之间的最短路径，如图7．35 所小。从图中可见，从瞒到。两条不同的路径：（“世“）和（蜘“4 “0，前者长度为 60，而后者的长度为50。因此·厂者是从到的最短路径；而从到没有路径。
如何求得这些路径？迪杰斯特拉（Di赤亠a)提出了一个按路径长度递增的次序产生最短路径的法
函先，引进一个辅助向量D，它的每个分量冂表示当前所找到的从始点心到每个图应31带权有向图0
始点 终点 最加路径 路径长度图7．35 有向图0中从“到眭余各点的最短路径终点。的最短路径的长度。它的初态为：若从到有孤，则D囝为孤L的权值；否则置]为亠。显然，长度为
D1 31一Mint[)Cil 0 V}
的路径就是从。出发的长度最短的一杀最短路径“此路径为，。
那么，下一条长度次短的最短路径是哪一条呢？，假设该次短路径的终点是则可想血知，这条路径或者是（。“0，或者是0 “宀）。它的长度或者是从t，到妩的引0的权值，或者是D「刀和从哧到0的弧上的权值之和
一般情况．卜，假设S为已求得最短路径的终点的集合，则可证明：下一条最短路径
（其终点为到或者是弧0，0．或者是中间只经过S中的顶点而最后到达顶点的路。这可用反证法来证明。假没此路径上有一个顶点不在S中，则说明存在一条终点不在s而长度比此路径哣的路彳0但是，这是不可能的“因为我们是按路径长度递增的次序来产生各最短路径的，故长度比此路径短的所有路径均已产生，它们的终点必宁在S 中，即假设不成立。
因此，在一般情况下，下一条长度次短的最短路径的长度必是
冂= M到DC;的0《V— S}
其中，DO〕或者是弧0，(, )上的权值，或者是D以〕长S）和弧（“的上的权值之和根据以上分析，可以得到如下描述的算法：
o）假没用带权的邻接矩阵“。来表示带权有向图，“。0就刀表示弧“》上的权值。若恸，，不存在，则置“。0〕[“门为亠（在计算机上可用允许的最大值代替)0 S 为已找到从。出发的最短路径的终点的集合，它的初始状态为空集。那么，从出发到图上其余各顶点（终点总可能达到的最短路径长度的初值为：
DO〕= “（寸ca Vex(G?t')Cij eV'
（2）选择马，使得
000：Min{/)[il 0，0 V— S)
马就是当前求得的一条从出发的最短路径的终点。令
s：S U与}
（3） 修改从。出发到集合V巧」任一顶点可达的最短路径长度 如果 DCJ ] + -5 [刀[的< D以」
则修改D〔0为
@ ] 88 ·
一D「到干”吓0亓0
（4） 重复操作（2）、（3）共月1次。山此求得从。到图上其余各顶点的最短路径是依路径长度递增的序列。
算法7．巧为用C语訁描述的迪杰斯特拉算法
void Shortest?ath DIJ（MGraph G，吡〕，PathMatr ix，ShortPathTable）{
//用DijkstraBiX*有向网G的顶点到其余顶点v的最知路径p [到及其带权长度D二到。
若p「v莊到为即E，则“是从vo到v当前求得最知路径上的顶点。
汐' fi “ 1〔到为皿当且仅当$，即已经求得从到v的最短路径。
for〈v = 0；v<G.vexnLIJDi ++ v) {
finalCvl FALSE; D〔的能G．at℃死VO ]
for（椠0；W<G, + + p「到“。 设空路径辽(DCv]以NIT'Y以畦v莊v明= TRUE；= “；}
軋v明 Q；final-v0]；TRUE; 初始化，vo顶点于廾始主循环，每次求得@到某个v顶点的最地路椏，并加v到
其余G.艹““ ]个顶点
min 0 INFINITY； for（山w?<G.vexnujo; + + 谨0臼na ]〔到）
(DCwJ?cOnin) {v江明
当前所知离vo顶点的最近距离
“顶点在v一$中
吨到刁 到贞点离vo顶点近
f inat(jvl一T卜旺； 彦离讪顶点最近的v加人s集 for @一0：凶《．“““；“更翱当前最路径及距离 if ( !fina1[wJ & & (min “、“吓《》@ < D、兯以修改可到和可到“ 0'一
TRJE; p、〕= +〔到
膨0。r
)// ShortestPath．
算法7．巧
例如．图7．34所示有向网GG的带权邻接矩阵为 若对G6施行迪杰斯特拉算法，则所得从到其余各顶点的最短路径，以及运算过程中D向量的变化状况，如下所示
189 · 我们分析这个算法的运行时间。第一个F()R循环的时间复杂度是00出第过个 FOR循环共进行一[次，每次执行的时间是00D。所以总的时间复杂度是0（，的。如果用带权的邻接表作为有向图的存储结构，则虽然修改D的时间可以减少，但由于在D 向量中选择最小分量的时间不变，所以总的时间仍为00的。
人们可能只希望找到从源点到某一个特定的终点的最短路径，但是，这个问题和求源点到其他所有顶点的最短路径一样杂，其时间杂度也是00）的。
7．6．2每一对顶点之间的最短路径
解决这个问题的一个办法是：每次以一个顶点为源点，重复执行迪杰斯特拉算法以次。这样，便可求得每一对顶点之间的最短路径。总的执行时间为00的。
这里要介绍由弗洛伊德（F № yd）提出的另一个算法。这个算法的时间复杂度也是
00），但形式上简单些。
弗洛伊德算法仍从图的带权邻接矩阵灬'出发，其基本思想是：
假设求从顶点到碼的最短路径。如果从“到有弧，则从到丐存在一条长度为“。(i)匚门的路径，该路径不一定是最短路径，尚需进行次试探。首先考虑路径世，马）是否存在（即判别弧“）和（，(" )是否存在）。如果存在，则比较0，乌）和 0 “）的路径长度取长度较短者为从到屿的中间顶点的序号不大于0的最短路径。假如在路径上再增加一个顶点仂，也就是说，如果，'．．满）和，“．，t，，）分别是当前找到的中间顶点的序号不大于0的最鋣路径，那么0， “ “）就有可能是从的到的中间顶点的序号不大于1的最短路得。将它和已经得到的从到碼中间顶点序号不大于0的最短路椏相比较，从中选出中间顶点的序号不大于1的最短路径之后，冉增加一个顶点10继续进行试探。依次类推、在一般情况下，若 ）和 ．．荡）分别是从到和从酶到。的中间顶点的序号不大于一1的最短路径，则将（
宀）和已经得到的从到，，利中间顶点序号不大于一1的最短路径相比较，其长 190
度较短者便是从0到的的中间顺点的序号不大于的最蜘路径。这样，在经过”次比较后，最后求得的必是从到0的最短路径。按此方法，可以同时求得各对顶点间的最短路径。
现定义，个，`阶力阵序列其中
，@曱一G．a灬@山
1)山囝出一M到酽且诽归0北k．]下D艹且k．I l．0
从上述计算公式可见，I)'暨i ]是从v》到的中间顶点的序号不大了到的最短路径的长度；．」是从、气到的中间顶点的序号不大于k的最短路径的长度；0 “
〔刂@就是从v.到v,的最短路径的长度。
由此可得算法7．] 5。
void $扒0》叶凵与r h FIOYD( MGraph G，Pat-hMatrix，DistancMatrix）{ 用门。@算法求有向网G中各对地点v和“之间的最短路叶v莊到及其带权长度呼到「到、名叶到卜莊到为．则u是从v到“当前求得最短路径十的顶点。
for = v?r..G,vexnum; + +的 ／/各对结点之间初始已知路径及距离 for @ w<.G, vexnun；、到{
D吓就到
for (u一0；u<G. vexnum; “ u)「FALSE；国《到0和 0《INFINITY) { 从v到“有直接路径叶髫Ilwllv: = T 1 0 v《吓到〔WA T 1岿
} for
for (u一0；11<"G.卜}刂）
for气=伍v?<G. vexnum; + + v) for（' 0；w<.G,vexnum; + +
（DCv北到+ D@莊到一一D《以）0丿从v经u到凶的一条路史短
D〔到〔到地」」〔到卜韦 for气=山i<G. vexnum；+噲i)
p [ u莊到〔诔
} Shortestpath FLOYD
算法7．16
0
图36 带权有向图
〔们向网G，； 伟冫邻厙阵
例如，利用上述算法，可求得图7．36所示带权有向图G，的每一对顶点之间的最短路释及其路径长度如图/，37所示。
0 冂
、
宀
“
。
0
00
AB
AC
AB
AC
AB
ABC
AB
ABC
BC
BA
BC
BA
BC
BOA
CA
CA
CAB
CA
CAB
CA
CAB
图六37图7．中亻向图的各对頂点间的最短路径及其路径长度
192 ·
第8章动态存储管理
& 1概述
在前曲各章的讨论中，对每一种数据结构虽都介绍了它们在内存储器中的映像，但只是借助高级语言中的量说明加以描述，并没涉及具体的存储分配。而实际上，结构中的每个数据元素都占有一定的内存位置，在程序执行的过程中，数据元素的存取是通过对应的存储单元来进行的。在早期的计算机上，这个存储管理的工作是由程序员自己来完成的。在程序执行之前，首先需将用机器语言或汇编语编写的程序输送到内存的某个固定区域上，并预先给变量和数据分配好对应的内存地址（绝对地或相对地址）。在有了高级语言之后，程序员不需要直接和内存地址打交道，程序中使用的存储单元都由逻辑变量（标识符）来表示，它们对应的内存地址都是由编译程序在编译或执行时进行分配。
另一方面，当计算机是被单个用户使用时，那么整个内存除操作系统占用一部分之外，都归这个用户的程序使用（如PDP刁1 / 03的内存为32KB，系统占用'IKB，用户程序可用28KB）。但在多用户分时并发系统中．多个用户程序共享一个内存区域，此时每个用户程序使用的内存就由操作系统来进行分配了。并且，在总的内存不够使用时，还可采用自动覆盖技术、
对操作系统和编译程序来说，存储管理都是一个复杂而又重要的问题。不同语荪的编译程序和不同的操作系统可以采用不同的存储管理方法。它们采用的具体做法，读者将在后续课程一一编译原理和操作系统中学习。本课程仅就动态存储管理中涉及的一些基本技术进行讨论
动态存储管理的基本问题是系统如何应用户提出的“请求”分配内存？又如何回收那些用户不再使用而“释放”的内存，以备新的“请求"产生时重新进行分配？提出请求的用户可能是进人系统的一个作业，也可能是程序执行过程中的一个动态变量。因此，在不同的动态存储管理系统中，请求分配的内存量大小不同。通常在编译程序中是一个或月、个字，而在系统中则是几千、几万，甚至是几十万。然而，系统每次分配给用户（不论大小）都是一个地址连续的内存区。为了叙述方便起见，在下面的讨论中，将统称已分配给用户使用的地址连续的内存区为“占用块”，称未曾分配的地址连续的内存区为“可利用空间块'' 或“空闲块，
显然，不管什么样的动态存储管理系统，在刚丌T时，整个内存区是一个“空闲块'气在编译程序中称之为“堆"）。随着用户进人系统，先后提出存储请求，系统则依次进行分配。因此，在系统运行的初期，整个内存区基本士分隔成两大部分．低地最区包含若千占用块# 高地址区（即分配后的剩余部分）是一个“空闲块'。例如图& 1（a）所示为依次给8个用户进行分配后的系统的内存状态经过一段时间以后，有的用户运行结束，它所占用的内存区成空闲块，这就使整个内存区旱现出占用块和空闲块犬才交错的状态。如图8，刃
1 9 3
既一
U 1
0B
图〕动态在储分配过程中的内有状态〔的统运巧初期；丿糸统运行若j'时间之后
假如此时又，0新的用户进人系统清求分配内存，那么，系统将如何做呢？
通常有两种做法“．种策略是系统继续从高地卅的空闲块中进行分配，而不理会己分配给用户的内存区是否已空闲，貞到分配无法进行（即剩余的空闲块不能满足分配的请求）时，系统。刁去回收所有用户不再使用的空闲块，亓且重新组织内存，将所有空闲的内存区连接在．起成为一个人的空闲块。另一种策略是用户一旦运行结束，便将亡所占内看区释放成为空闲块，同时，每当新的用户请求分配内存时，系统需要巡视整个内看区中所有空困块，并从中找出一个“合适”的空闲块分配之。山此，系统需建立一张记录所有空闲块的“可利用间表"，此表的结构可以是“目录表”，也可以是“链表”。如图8．2所示为某
25佣0 39 000
0 ] 0冈0 31 0 59伽图& 2动态有储管理过程屮的内存状态和可利用空间表
o）内存状态：（目正丛（的表
系统还行过程中的内存状态及其两种结构的可利用空间表。其中图8．2（b）是目录表，表中每个表目包括3项信息：初始地址、空闲块大小和使用情况。图8．2（是链表，表中个结点表示一个空闲块，系统每次进行分配或回收即为在用利用空间表中删除或插人个结点。
1 91
下面将分别时论利用不同策略进行动态存储管理的方法。
& 2可利用空间表及分配方法
这一节主要讨论利用可利用空间表进行动态存储分配的方法。目录表的情况比较简羊，这类系统将在操作系统课程中详细介绍，在此仅就链表的情况进行讨论。
如上所述，可利用空间表中包含所有可分配的空闲块，每块是链表中的一个绿点。当用户请求分配时，系统从可利用空间表中剮除．个结点分配之；当用户释放其所占内存时，系统即回收并将它人到i'刂利用空间表中。因此，可利用空间表亦称做“存储池”。根据系统运行的不同情况，可利用空间表可以有下列3种不同的结构形式：
第一种情况是系统运行期间所有用户请求分配的存储量大小相同。对此类系统，通常的做法是，在系统廾始运行时将归它使用的内存区按所需大小分割成若干大小相同的块，然后用指针链接成一个可利用空间表。由于表中结点大小相同，则分配时无需查找，只要将第一个结点分配给用户即可；同样，当用户释放内存时，系统只要将用户释放的空困块插人在表头即可见，这种情况下的可利用空间表实质十是一个链栈。这是一种最简单的动态存储管理的力式，如第2章的地3口线性链表”中的静态表就是一例
第二种情况，系统运行期间用户请求分配的存储量有若干种大小的规格。对此类系统，般情况下是建立若干个可利用空间表，同一链表中的结点大小相同。例如，某动态存储管理系统中的用户将请求分配2个字，4个字或8个字的内存块，则系统建立3个结点大小分别为3个字、5个字和9个字的憐表，它们的表头指针分别为艹2、a和“8。如图& 3所示，每li、结点中的第个字设有域（link）、标志域0 “）和结点类型域 (type)o其中：类型域为区别3种大小不同的结点而设，巧，pe的值为“ 0 "、“ 1 "或“ 2。，分别表小结点大小为2个字0个字或8个字；标志域t为“ 0 "或“ 1 "分别表示结点为空闲块或占用块；链域中存储指向同一鲢表中下经点的指针，而结点中的值域是其大小分别为 2、4和8个字的连续空间。此时的分配和回收的力法在很大程度上和第一种情况类似，只是当结点大小和请求分配的量相同的彘表为空时，需查询结点较大的彘表，并从中取出一个结点，将其中一部分内存分配给用户，而将剩余部分插人到相应大小的链表中。回收时，也只要将释放的空闲块插人到相应大小的链表的表头中去即可。然而，这种情况的系统还有一个特殊的问题要处理：即当结点与请求相符的链表和结点更大的表均为空时，分配不能进行，而实际十内存空间并不一定不存在所需大小的连续空间．只是由于在系统运行过程中，繁出现小块的分配和回收，使得大结点链表中的空闲块被分隔成小块后插人在小结点的氯表中，此时若要使系统能继续运行，就必须重新组织内存，即执行“存储紧缩”的操作。除此之外，上述这个系统本身的分配和回收的算法都比较简单，读者可自行写出、
第3种情况，系统在运行期间分配给用户的内存块的大小不固定，可以随请求而变。
因此，可利用空间表中的结点即空闲块的大小也是随意的。通常．操作系统中的可利用
间表属这种类型
系统刚弄始五作时，整个内存空间是．个空闲块，即可利用空间表中只有一个大小为
整个内行区的结点．随着分配和回收的进行，可利川空间表中的结点人小和个数也随之而变，上述图& 2（的中的表即为这种清的可利用空间表。（的点构：《可利用空间表
由于表中结点人小不同，则结点的结构与前两种情况也有所不同，结点中除标志域和链域之外，尚需肩一个结点人小域岫，以指示空闲块的存储量，如图8 0所示。结点中的space域是一个地址连续的内存空间。
link
$p小弋
o 空块山用块
空闲块的人小意的结点结构
由于可利用空间表中的结点大小不同，则在分配时就有一个如何分配的问题。假设某用户需大小为到的内存，而可利用空间表中仅有一块大小为忉> ”的空闲块，则只需将其中大小为，》的一部分分配给申清分配的用户，同时将剩余大小为m一刃的部分作为一个结点留在链表中即可。然而，若可利用空旬表中有若f个不小于的空闲块时，该分配哪一块呢？通常，可有3种不同的分配策略；
o ）首次合法。从表头指针片始查找可利用空间表，将找到的一个大小不小于“ 的空闲块的一部分分配给用户。可利用空间表本身既不按结点的初始地有序，也不按结气的大小有序。则在回收时，只要将释放的空闲块插人在链表的表头即可。例如，在图 & 2（c）的状态时有用户进人系统并申请7KB的内存，系统在可利用空间表中进行查词，发现第一个空闲块即满足要求，则将此块中大小为7KB的一部分分配之·剩余8KB 的空闲块仍在链表中，如图8，5（a）所示。图8，5（d）为分配给用户的占用块 196 ·
〈2）最佳拟合法。将可利用空间表中．个不小丁n且最接近的空闲块的一部分分配给用户。贝刂系统在分配前首先要对可利用空间表从头到尾扫视一遍，然后从中找出一块不小丁，0目．最接近”的空闲块进行分配“显然，在图8．2（0的状态时，系统就应该将第二个空闲块的部分分配给用户U “分配后的可利用空间表如图8．5（b）所示。在用最佳拟合法进行分配时，为了避免每次分配都要扫视整个鲢表。通常，预先设定可利用空间表的结构按空间块的大小自小至大有序，由此，只需找到第一块大于的空闲块即可进行分配丰在回收时，必须将释放的空闲块插人到合适的位置上去。
（3）最差拟合法。将可利用空间表中不小于且是彘表中最大的空闲块的一部分分配给用户，例如在图& 2（c）的状态时，就应将大小为4 ] KB的空闲块中的一部分分配给1 7伽思
(d)
图8．5结点大小意的可利用空间表
）按首次拟合原则进行分配；(b)按吊佳拟合原则进行分配《
（．按最合原则进行分配；）分配给用户的占用块
用户，分配后的可利用空间表如图8．5（c）所示。显然，为了节省时间，此时的可利用空间表的结构应按空困块的人小自人至小有序。这样，每次分配无需查找，只需从表中删除第一个结点，并将其中一部分分配给用户，而剩余部分作为一个新的结点插人到可利用空间表的适当位置上去。当然，在回收时亦需将释放的空闲块插人到链表的适当位置」
E述3种分配略各有所长。一般来说，最佳拟合法适用于请求分配的内存大小范围较广的系统。因为按最佳拟合的原则进行分配时，总是找大小最接近请求的空闲块，由
1 9 7 ·
此系统中可能产生一些存储量甚小而无法利用的小片内存，同时也保留那些很大的内存块以备响应后面将发生的内存量特大的请求，从而使整个链表趋向于结点大小差别葚远的状态。反之，由于最差拟合每次都从内存量最大的结点中进行分配，从而使表中的结大小趋于均匀，因此它适用于请求分配的内存大小范围较窄的系统。而首次拟合法的分配是随机的，因此它介于两者之间通常适用于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。从时间上来比较，首次拟合在分配时需查询可利用空间表，血回收时仅需插人在表头即可；最差拟合恰相反，分配时无需查询链表，而回收时为将新的“空闲块”插人在链表中适当的位置上，需先进行查找；最佳拟合无论分配和回收，均需查找琏表，因此最费时间。
因此，不同的情景需采用不同的方法，通常在选择时需考虑下列因素《用户的遷辑要求；请求分配量的大小分布，分配和释放的频率以及效率对系统的重要性等等。
在实际使用的系统中回收空闲块时还需考虑一个“结点合并”的问题。这是因为系统在不断进行分配和回收的过程中，大的空闲块逐渐被分割成小的占用块，在它们重又成为空闲块回收之后，即使是地址相邻的两个空闲块也只是作为两个结点插人到可利用空间表中，以致使得后来出现的人容量的请求分配无法进行，为了更有效地利用内存，就要求系统在回收时应考虑将地址相邻的空闲块合并成尽可能大的结点。换句话说，在回收空闲块时，首先应检查地址与它相邻的内存是否是空闲块，只体实现的方法将在下面两节中讨庀的动态存储管理系统中加以详细说明。
8．3边界标识法
边界标识法伟ouud盯y tag me山。d〉是操作系统中用以进行动态分区分配的一种存储管理方法，它属于上一节讨论中的第三种情况。系统将所有的空闲块链接在一个双重循环链表结构的可利用空间表中；分配可按首次拟合进行，也可按最佳拟合进行。系统的特点在了：在每个内存区的头部和底部两个边界上分别设有标识，以标识该区域为占用块或空闲块，使得在回收用户释放的空闲块时易于判别在物理位置上与其相邻的内存区域是否为空闲块，以便将所有地址连续的空闲存储区组合成一个尽可能大的空闲块。下面分别就系统的可利用空间表的结构及其分配和回收的算法进行讨论。
& 3．1可利用空间表的结构
可利用空间表中的结点结构如卜所示：
l!ink
rlink
space
head
foot
1 9 8，
它表示一个空闲块。整个结点由3部分组成。其中sp “ e为一组地址连续的存储单元，是可以分配给用户使用的内看区域，它的大小由head中的壶e域指示，并以头部head和底部foot作为它的两个边界：在head和foot中分别设有标志域。且设定空闲块中tag 的值为“旷，占用块中tag的值为“ 1 ” i f。ot位于结点底部，因此它的地址是随结巛屮№ ace 空间的大小而变的。为时论間便起见，我们假定内存块的大小以“字”为单位来计，地址也以“字”为单位米计，结点头部中的size域的值为整个结点的人小，包头部head和底部 f“ t所占空间，并假设head和foot各占一个字的空间，但在分配时忽略不计。
借助C语言，在此将可利用空间表的结点结构定义为如下说明的数据类型：
typedef { 羽，内存字类型 union { // head和f凶t分别是结点的第一个字和最后的字
NORD
WORD uplink;
int int Size;
rli
OtherType Other；
}囚0即，he d，foot，Spacei
／/头部域，指向前驱结点
底部域，指向本结点头部
块标志，0：空闲，]：占用，头部和尾部均有。
头部域大小
头部域，指向后继结点
／／字的其他部分
spacet可利用空间指针类型
#define Footroc(p) p + p “0、卜i一 ！/7指向p所指结点的底部
可利用空间表设为双重循环表。head中的Ilink和clink分别指向前驱结点和后继结点。表中不i殳表头结点，表头指针p “可以指向表中任一结点，即任何一个结点都可看成是表中的第一个结点；表头指针为空，则表明可利用空间表为空“中的呷 link域也为指针，它指向本结点，它的值即为该空闲块的首地址。例如图& 6（a）是一个占有1 00KB内存空间的系统在运行开始时的可利用空间表。
8．3．2分配算法
分配的算法比较简单，假设我们采用次拟合法进行分配，则只要从表头指针pav所指结点起，在可利用空间表中进行查找，找到第一个容量不小于请求分配的存储量（的的空闲块时，即可进行分配。为了使整个系统更有效地运行，在边界标识法中还作了如下两条约定：
( l)假设找到的此块待分配的空闲块的容量为m个字（包括头部和底部若每次分配只是从中分配”个字给用户，剩余m一”个字大小的结点仍留在表中，则在若T次分配之后，表中会出现一些容量极小总也分配不出去的空闲块，这就大大减慢了分配（查找）的速度。弥补的办法是：选定一个适当的常景。当m一” < e时，就将容量为m的空闲块整块分配给用户《反之，只分配其中个字的内存块。同时，为了避免修改指针，约定将该结点中的高地址部分分配给用户
（2）如果每次分配都从同一个结点开始查找的话，势必造成存储量小的结点密集在头指针pav所指结点附近，这同样会增加杳词较人空闲块的时间。反之，如果每次分配从
1 9 9 ·
图8．6某系统的可利用空间表
（的初始状态；（0运行若「时间后的1L0（的进行冉分配后的状态
不同的结点开始进行查找，使分配后剩余的小块均匀地分布在表中，则可避係上述弊病。实现的方法是，在每次分配之后，令指针陣v指向刚进行过分配的结点的后继结点。
例如，图8．6（b）所示可利用空间表在进行分配之后的状态如图8．6（的所示。
算法8，〕是上述分配策略的算法描述。
S 00 Al locEoundTag（Space &@蹁n) {
//若有小小于n的空闲块．则分配相应的存储块．并返回其当地后否则返回
N刂 分配后可利用举间表不空，则p“指向表中刚分配过的结点的继
//结点
for (p=pav; p && p、．、& & p—>rlink!：pav;
P * p >rlink)； //查找不小于n的空闲块 n）return NULL： 汐找不到，返回空指针else { f， 下EL区（p) ;
．、rl ink；
else《el*e {
200
彦p指向找到的空闲块 指向底部
汐pav指向p结点的后继结点。
整块分配，不保留《'' e的剌金量
//可利用空问表变为空表 在表中删除分配的结点
P
/修改分配结点的头部和底部标志
分配该块的后n个字
改分配块的底部标志
p ?>size
置剩余块大小
f F00凵j00（p) ;
“ /指向剩余块底部
f —>uplink
P；
设置剩余块底部
/7指向分配块头部
//设置分配块头部
return p;
} else
} // AllQcEou.ndTag
返回分配块首地址
箅法
8口
8，3，3回收算法
一旦用户释放占用块，系统需立即回收以备新的请求产生时进行再分配。为了使物理地址毗邻的空闲块结合成一个尽可能大的结点，则首先需要检查刚释放的占用块的左、右紧邻是否为空闲块。由于本系统在每个内存区（无论是占用块或空闲块）的边界上都设有标志值，则很容易辨明这一点。
假设用户释放的内存区的头部地址为p，则与其低地址紧邻的内存区的底部地卅为 p一1；与其高地址紧邻的内存区的头部地址为p + p一>壶e，它们中的标志域就表明了这两个邻区的使用状况：若（p一D过> tag：0；则表明其左邻为空闲块，若（p十p一．> size）一一山则表明其右邻为空闲块。
若释放块的左、右邻区均为占用块，则处理最为简单，只要将此新的空闲块作为一个结点插人到可利用空闭表中即可；若只有左邻区是空闲块，则应与左邻区合并成个结点；若只有右邻区是空闲块，则应与右邻区合并成一个结点；若左、右邻区都是空闲块，则应将3块合起来成为一个结点留在可利用空间表中，下面我们就这嶁种情况分别描述它们的算法：
（0释放块的左、右邻区均为占用块。此时只要作简单插人即可。山于边界标识法在按首次拟合进行分配时对可利用空间表的结构没有任何要求，则新的空闲块插人在表中任何位置均可。简单的做法就是插人在pav指针所指结点之前（或之后），可描述如下：
p一> tag票 0；下00tL（P）—>?uphnk。P；FOOtL（0 ?>Eag：0； if（！pav) pav p->llink p ->rlink P; else { = pav—>lli-nk:
p ->rlink p -、Ili-nk中 q -冫= pav—>llink = V；
= P》 /7令刚释放的结点为下次分配时的最先查陶的结点
（2） 释放块的左邻区为空闲块，而右邻区为占用块。山于释放块的头部和左邻空闲块的底部毗邻，因此只要改变左邻空闲块的结点：增加结点的size域的值且重新设置结点的底部即可。描述如下：
p—>sizei
释放块的大小
upl上；
／/左邻空闲块的头部地址
．2 0 1
矛0殳置的空闲块大小
．．0可黻 汐设置的空闲块底部
（3） 释放块的右邻区为空闲块，而左邻区为占用块。由于释放块的底部和右邻空闲块的头部毗邻，因此，当表中结点山原来的右邻空闲块变成合并后的大空闲块时，结点的底部位置不变，但头部要变，由此，链表中的指针也要变。描述如下
' S Z e； //右邻空闲块的头部地址
P// p为合丌后的结点头部地址
q t. Il ink, q为凵，结点在可利用空间表中的前驱结点的头部地址 P ?*llink = q; q一 。门if正吓 向的前驱
rl inki ／/ Al为上结点在可利用空间表中的后继结点的头部地址
p ->rlink =冫?Ilink q)指向唧的后继 ' S乙e + =。' 51 e 新的空困块的大小
EuotLoc（t） upl ink = p i 汐'底部指针指向新结点的头部
o凶0
右邻区
左区
右邻区
0
0
(d)
图& 7回收存緒块后的可利用空间表
（的释放的存储块； 伟丿左邻区是空闲块的情况；
（0右邻区是窄困块情况；（巾左、右郓区均是困块的情况
（4〕释放块的左、右邻均为空闲块。为使3个空闲块连接在一起成为一个大绍点留在可利用空间表中，只要增加左邻空闲块的space容量，同时在表中删去右邻空闲块结点即可。所作改变可描述如下
／7释放块的大小
、uplink， //指问左郊块，7指向右邻块
。生过1z0； 设置新结点的大小 q =上一0 1 ] ink：ql q！。ql
%?rlink ql; q) > llink = q： 去右邻空闲块结点
Foot巛凵 、upl辶虫二s； 丿新结点底部指针指向其头部
总之，边界标识法由于在每个结点的头部和底部设立了标识域，使得在回收用户释放的内存块时，很容易判别与它毗邻的内存区是否是空闲块，且小需要查询整个可利用空间表便能找到毗邻的空闲块与其合并之；再者，由于可利用空间表上结点既不需依结点大小有序，也不需依结点地址有序，则释放块庙人时也不需查找链表。由此，不管是哪一种情昆，回收空闲块的时间都是个常量，和可利用空间表的大小无关。惟一的缺点是增加了结点底部所占的存储量。
在上述后3种情况下，可利用空间表的变化如图8．7所示。
8．4伙伴系统
伙伴系统（扁ddy ” m）是操作系统中用到的另一种动态存儲管理方法。它和边界标识法类似，在用户提出申请时，分配一块大小“恰当”的内存区给用户；反之，在用户释放内存区时即回收。所不同的是：在伙伴系统中，无论是占用块或空闲块，其大小均为2的次幂为某个正整数例如；当用户申请”个字的内存区时，分配的占用块大小为2《个字（2冖<月《20，山此，在可利用空间表中的空闲块大小也只能是2的次幂。若总的可利用内存容量为2 '墉个字，则空闲块的大小只可能为2飞21、．、2 “。下面我们仍和上节一样，分3个问题来介绍这个系统。
8．4．1可利用空间表的结构
假设系统的可利用内存空问容量为个字（地址从0到一I )，则在开始运行时，整个内存区是一个大小为2 "的空闲块，在运行了一段时间之后，被分隔成若干占用块和空闲块。为了再分配时查找方便起见，我们将所有大小相同的空闲块建于一张了表中每个子表是一个双重表，这样的表可能有m + 1个，将这m + 1个表头指针用向量结构组织成一个表，这就是伙伴系统中的可利用空间表。
双重憐表中的结点结构如图8．8（a）所示，其中head为结点头部，是一个由4个域组成的记录，其中的冚nk域和rlink域分别指向同一链表中的前驱和后继结点；tag域为值取“ 0 ” “ 1 ”的标志域，kval域的值为2的幂次忐；斗ace是一个大小为2氐一1个字的连续内存空间（和前面类似，仍假设head占一个字的空间）。
可利用空间表的初始状态如图8．8（b）所示，其中m个子表都为空表，只有大小为2 '" 的链表中有一个结点，即整个存儲空间。表头向量的每个分量山两个域组成，除指针域外另设n翮esize域表示该链表中空闲块的大小，以便分配时查找方便。此可利用空同表的数据类型．示意描述如下：
#define In 16 可利用空间总容量54 K字的2的幂次，于表的个敵为+ ] typedef虻0 t．b {o即b 《0 nk；
左指向前驱结点
int.
7块标志，0：※困，]适川
inv. kvai:
块大小．值为2的幂次k
WORD b r吓；
//头部域，指向后继结点
OtherType other;
字的其他部分
} 0〕b，headi
#即；内仔手类型，结点的弟一忄字也称为head
typedef struct HeadNode {
n；
/7该链表的空困块的大小
NORD b first;
该彘表的表头指针
)FreeList[111 + 1
享表头向量类型
黿tag— 0
(b)图8．8伙伴系统中的可利用空间表
（的空困块的结点结构以b〕表的初始状态；@分配前的表；（分配后的表
8．4．2分配算法
当用户提出大小为”的内存请求时先在可利用表上寻找结点大小与”相匹配的子表，若此子表非空，则将子表中任意一个结点分配之即可；若此子表为空，则需从结点更大的非空子表中去查找，至找到一个空闲块，则将其中一部分分配给用户，而将余部分插人相应的子表中，
假没分配前的可利用空间表的状态如图& 8（c）所小。若2 “ < ”：《2心一1，又第差十1 个子表不空，则只要删除此表中第个结款并分配给用户即可；若2 < < 2卜时由于结点大小为2-的子表为空，则需从结点大小为2的子表中取出一块，将其中半分配给用户，剩余的一半作为个新结点插人在结点大小为2 '的子表中，如图8．8（！所示。若 №为小于的整数冫，并且所有结点小于的子表均为空，
· 20 ·
则同样需从结点大小为2的子表中取出一块，将其中2 “的一小部分分配给用户，剩余部分分割成若干个结点分别插人在结点大小为2 ' ．、2 “的子表中。假设从第k-1 1 个子表中删除的结点的起始地址为狲乜假设分配给用户的占用块的初始地址为占用块为该空闲块的低地址区），则插人上述子表的新结点的起始地址分别为户十2-、户十 ．、/科2-，如右图所示（图中i一3）。
下曲用算法语言描述之
KORD b A1100№ddy (FreeL1st: &avail. n) {
／/ a“ il [ 0，，到为可利用空间表，n为申请分配量，若有不小于n的空闲块， 则分配相应的存储块，并返回其首地址；否则返回NULL
for（k孬山k<一一cn & &（avail[kl. nodesize<n+ ]《 !avaul[k]. first) i
+十k) i查找满足分配要求的子表
if（k)>Ul) return NULL；分配失败，返回NOLL 們13e进行分配
pa；“ “ai k ]、first;指向可分配子表的第一个结点了0 = [坶一0 IT ink；吓' pa一0了过； 分别指向前驱和后继 if（p苤。sue)艹0过[到，first = NULL'分配后该子表变成空表 e100 {从子表删去廾些结点 pre 》还= 6吣： 0以一》ll?nk pre;〕，first = ·
for巨：avail[k - ij.nodesize> z n+ l ' ++ i)（
pi = p，1 2 “、 pi -Oonjink。pi; +Jli.nk。pi!
pi、、0上凶= 0； Pi一0 kval k availlk—到、fir*t = pi;
} #将剩余块插人相应子表 pa?>tag 1；
return pa;
0' AllocBuddy
算法 & 2
8．4．3回收算法
在用户释放不再使用的占用块时．系统需将这新的空闲块届人到可利用空间表中去。这里，同样有一个地址相邻的空闲块归并成大块的问题。但是在伙伴系统中仅考虑互为 “伙伴”的两个空闲块的归并。
何谓“伙伴”？如前所述，在分配时经常需要将一个大的空闲块分裂成两个大小相等的存锗区，这两个由同一大块分裂出来的小块就称之“互为伙伴”。例如：假设虍为人小为的空闲块的初始地，且户MOD 2 “一0，则初始地址为虍和+ 2的两个空闲块互为伙伴。在伙伴系统中回收空闲块时，只当其伙伴为空闲块时才归并成大块。也就是说，若有两个空闲块，即使大小相同且地址相邻，但不是由同一大块分裂出来的，也不归并在一起。例如图中的A、B两个空闲块不是伙伴。
由此，在回收空困块时，应首先判别其伙伴是否为空闲块，若否，则只要将释放的空闲
块简单插人在相应了表中即可；若是．则需在相应子表中找到其伙伴并删除之，然后冉判别合并后的空闲块的伙伴是是空闲块。依此重复，直到归并所得空闲块的伙伴不是空闲块时，再插人到相应的子表中去。
起始地址为狲大小为2的内存块，其伙伴块的起始地址为：
+（若p MOD 2 “《一
buddy(p?k)一
/。（若MOD 2 “《一
例如，假设整个可利用内有区大小为= ] 024（地址从0到23），则大小为28，起始地为512的伙伴块的起始地址为768；人小为矛，起始地址为381的伙伴块的起始地址为
整个释放算法在此不再详细列出，请读者自行补充。
总之，伙伴系统的优点是算法简单、速度快；缺点是山于只归并伙伴而容易产生碎片。
& 5无用单元收集
以《3讨论的问题都是如亻可利用可利用空间表来进行动态存管理。它的特点是：在用户请求存储时进行分配；在用户释放存储时进行回收，即系统是应用户的需求来进行存储分配和回收的。因此，在这类仃储管理系统中，用户必须明确给出“请求"和“籽放"的信息。如在多用户分时并发的操作系统中，当用户程序进人系统时即请求分配存储区；反之，当用户程序执行完毕退出系统时即释放所占存储。又如，在使用C语訁编写程序时，用户是通过malloc和e两个函数来表示清求分配和释放存储的。但有时会因为用户的疏漏或结构本身的原因致使系统在不恰当的时候或没有进行回收而产生“无用单元”或“悬挂访问”的问。
'无用单元"是指那些用户不再使用而系统没有回收的结构和变量。例如下列C程序段
p= “11 ize）；
执行的结果，是使执行户：mal就（s以）为用户分配的结点成为无用单元，无法得到利用；而下列程序段执行的结果使指针变量q悬空，如果所释放的结点被再分配而继续访问指钅《q所指结点．则称这种访问为“悬拌访问"，并且由此引起的恶劣后果是可想而知的，206 另一方曲，山于结构本身的某些特性，也会产生同上类似问题。
例如在某用户科序中有3个广义表绿构，如图8．9所示，Ll、0和L*分别为它们的表头指钅吓L,是0和0共亨的子表，以本身又为其享．则L，为3个广义表所共亨。图8，9含共享子表的疒义
在这种情况下，表结点的释放就成为一个问题“假设表不再使用，而表0和以尚在使用，若释放表L,，即自Ll指针起，顺毓将所有结点回收到可利用空间表中（包括了表L, 和0十所有结点），这就破坏了表和L,，从而产生“悬挂访问反之，若不将表Ll中结点释放，则当Lt和L.I两个表也不被使用时，这些结点由于未曾“释放”无法被再分配而成为“无用单丿L ”。
如何解决这个问题？，有两条途径：
o）使用访问门数器：在所有子表或广义表上增加一个表头结点，并设立一个“刂数域”，它的值为指向该了表或广义表的指针数目。只有当该计数域的值为零时，此了表或下义表中结点才被释放。
（2）收集无用单元：在程序运行的过程中，对所有的链表结点，不管它是否还有用，都不回收，直到整个可利用空间表为空。此时才暫时中断执行程序，将所有当前不被使用的结点链接在一起，成为一个的可利用空间表，而后程序再继续执行。显然，在一般情况下，是无法辨别哪些结点是当前未被使用的。然而，对于一个正在运行的程序，哪些结点正在使用是容易查明的，这只要从所有当前正在工作的指针变量出发，顺毓遍历，那么，所有皚结在这些毓下的结点都是占用的。反之，可利用存储空间中的其余结点就都是无用
由此，收集无用单元应分两步进行：第一步是对所有占用结点加上标志。回顾第5章的广义表的存储结构可在每个结点上冉加设一个标志（m“ k）域，，假没在无用单儿收集之前所有结点的标志域均詈为“ 0 ”，则加丨标志就是将结点的标志域置为“ ] ”；第一步是刈整个可利用存储空间顺序扫描一遍，将所有标志域为“ 0 ”的结点链接成一个瓤的可利用空间表。值得注意的是十述第了步是容易进行的，而第一步是在极其困难的条件（即可利用行储几乎耗用殆尽）下进行的．因此，人们的精力主要集屮在研究标志算法上。下面我们介绍3种标志算法
（0递归法从上面所述可知，加标志的操作实质上是遍历广义表，将广义表中所有结点的标志域赋值“ 1 ”。我们可写出遍历（加标志）算法的递归定义如下：
若列表为空，则无需遍历；若是一个数据元素，则标志元素结点；反之．则列表非空，游先标志表结点：然后分别遍历表头和表尾
这个算法很简单，易于用允许i弟归的高级语訁描述之。但是，它需要一个较大的实现递归用的栈的辅助内存，这部分内存不能用于动态分配。并且，由于列表的层次小定．使得栈的容量不易确定，除非是在内存区中开辟一个相当大的区域留作栈，否则就确可能由于在标志过程中因栈的溢出而使系统瘫痪。
（2） 非递归算法程序中附设栈（或队列）实现广义表的历。从广义表的存储结构来看，表中有两种结点：一种是兀素结点，结点中没有指针域；另一种是表结点，结点中包含两个指针域：表头指针和表尾指针，则它很类似于二叉树的二叉链表。列表中的元素结点相当于二叉树中的叶子结点，可以类似于历二又树写出遍历表的非递归算法，只是在箅法中应尽量减少栈的容量。
例如，类似于二叉树的前序遍历，对广义表则为：当表非空时，在对表结点加标志后，先顺表头指针逐层向下对表头加标志，同时将同层非空且未加标志的表尾指针依次人栈，直到表头为空表或为元素结点时停止，然后退栈取出上一墚的表尾指针。反复上述进行过程，直到栈空为止。这个过程也可以称做深度优先搜索遍历。因为它和图的深度优先搜索遍历很相似
显然，还可以类似于图的广度优先搜索遍历，对列表进行广度优先瘦索遍历，或者说是对列表按层次遍历。同样，为实现这个暹历需附设、个队列〔这两个算法和二义树或图的遍历极为相似，故在此不作详细描述，读者完全可以自己写出）。在这两种非涕归算法中，虽然附设的栈或队列的容量比递归算法中的栈的容量小，但和递归算法有同样的问题仍需要一个不确定量的附加存储，因此也不是理想的方法。
（3） 利用表结点本身的指针域标记遍历路径的算法无论是在递月算法中还是在深度优先搜索的非递归算法中，不难看出，设栈的目的都是为了记下遍历时指针所走的路径，以便在历表头之后可以沿原路退回，继而对表尾进行遍历。如巢我们储用别的方法记下指针所走路径，则可以免除附设栈。在下面介绍的算法中就是利用已经标志过的表结点中的t、hp和tp域来代替栈记录遍历过程中的路径。例如：对图8．10中的广义表 L
图8，10待取历的广义表
，208 ·
加标志。假设在递归算法中指针p指向刚加上标志的b结点，则：当指针p由以多向表头c之前需将b人栈（此时a己在栈中）；鬥在表头标志之后需退栈，然后指针p在山b f} 向表尾f时需再次将b人栈这3〕在b的表尾标志完之后应连续两次退栈，使p重又指向a。与此对应，在本算法屮不i殳栈。而是当指针p由b移向c之前，先将b结点中的hp域的值改为指向a，并将b结点中的tag域的值改为“ 0 "；商当指钊p由b移向f之前，则先将b 结点中的tp域的值改为指向，tag域的值改为“ ] '，
下面详细叙述算法的基本思想（注：假没图& 10中的厂义表0已加十标志〕。
算法中设定了3个互相关联的指针：当p指向某个表结点时；t指向p的母表结点；q 指向p的表头或表尾。如图8．凵中（的和伟）所示。
当q指向p的表头结点时，可能有3种情况出现：0)设p的表头只是一个儿素结点，则遍历表头仅需对该表头结点打上标志后即令q指向p的表尾；0设p的表头为空表或是已加上标志的子表、则无需遍历表头只要令q指向p的表尾即可；．设p的表头为禾加标志的子表，则需先遍历表头子表，即p应赋q的值，相应往下移动改赋p的值。为了记下t指针移动的路径，以便在p退回原结点时同时能找到p的母表结点（即使t退回到原来的值），则在修改这个指针的值之前，应先记下t移动的路径，即令p所指结点的师域的值为t，且t域的值为“ 0 ”
另一方面，当q指向p的表尾时，也可能有两种情况出现：．p的表尾为未加标志的子表，则需遍历表尾的子表，同样p、t指针要作相应的移动“为了记下当前表结点的母表结点，同样要在改动p、t指针的值之前先记下路径；即令p所指结点的tp域的值改为t，然后令「赋值p,p!jt值q;(2)p的表尾为“空”或是己加上标志的子表，此时表明p所指的表已加上标志，则p应退回到其母表结点即[所指结点，相应地[也应后退一步，即退到结点的母表结点。综上所述可知，t的移动路径已记录在'结点的hp域或蜘域中，究竟是哪一个？则要由辨别tag域的值来定。它不仅指示t应按哪个指针所指路径退回．而且指示了下一步应做什么。若t结点是其母表表头，则应继续遍历其母表的表尾。若t 结点是其母表的表尾，则应继续找更高一层的母表结点。整个算法大致描述如下：（GL 为广义表的头指针）
t NULL; p GL; finished FALSE；陌h玉le（！finished) {
*hile (p一：> mark
p一“ mark
MarkHead(P); 若表头是末经遍历的非空子表，则修改指针记录路径，且P指向表头：古则P不变
(q & & q -、、mark ：0）MarkTail(p); //修改指针记路椏，且p指向表尾
艹BackTraek(finished)；若从表尾回溯到第一个结点，则fini9hed为TRUE
精后的广义表遍历算法如算法8．3所示。
void MarkList(CList (L) {
/7遍历非空广义表c以GL！“月，对表中所有未加标志的结点加标志。
丝t指示p的母表图& I l 遍历广义表
（的指针初始化指向表头；
对元素结点加标志后指过后指向表尾，山指针后退。步；
（的和@指针向表头方向推进一
（的指向表帛方向推进一步，q指向表头；
（指钅1继续后，q指向表尾《
(h)指针向表尾方向推进一陟，q指向表尾（表头为空表〕；
o 指钊继续向表尾方向推进一步以指向表斐
while 0 finished) {
迥e (p-.>mark =。的{/7 HarkHead(p)的细化：
//出表头为原子结点
汐继续遍历了表
o ／/完成对表头的标志
q指向〗p的表尾
· 21 0 ·& & q P //继续遍历表尾 else {方HockTrack( 0 nighed)的细化：
while (t & t —2tag //瞓．表结点，从表尾回溯 p就p； P q；
if（！凵finished TRUE; 结束 el {／/从表头回溯
P P > tag
}继续遍历表尾
》MarkLi9t
箅法& 3
图8，11展示对图& 10中的广义表进行遍历加标志时各指针的变化状况。（a）为算法8，3升始执行时的状态“（b）和（c）为指针向表头方向移动并改变结点的hp域指针的情形。（山表示当表头遍历完成将对表尾进行标志时的指针变化情况、从（e）和(f)读者可看到指针回溯的情形“在此省略了继续历时的指针变化状况，有兴趣的读者可试之补充。
比较上述3种算法各有利弊，第3种算法在标志时不需要附加存储，使动态分配的可利用空间得到充分利用，但是由于在算法中，几乎是每个表结点的指针域的值都要作两次改变，因此时间上的开销相当大，而．目，一且发生中断，幣个系统瘫痪，无法重新启动运新、而非递归算法操作简单，时间上要比第3种算法省得多，然而它需要占，有一定空间，使动态分配所用的存储量减少。总之，无用单元收集是很费时间的，不能在实时处理的情况下应用。
通常，无用单元的收集「作是由编译程序中的专用系统来完成的，它也可以作为．个际准吆数由用户自行调用（类似：J' free函数的使用）。不论哪一种情况，系统都要求用户建立一个初始变量表登录用户程序中所有表的表头指针，以便从这些指针出发进行标志。
下而我们可以对无用单兀收集算法作某种定怵估计。如上所述，整个算法分两步进行：第一步对占用结点加标志、不管用哪一种算法，其所用时间都和结点数成正比。假没总的占用结点数为N，则标志过程所需时间为CI N（其中。为某个常数第二步是从可用生间的第一个结点起，顺序扫描，将所有未加标志的结点锖结在一起。假设可用空间总共含有M个结点，则所需时间为Q M（其中0为某个常数）。山此，收集算法总的时间为 CIA' +铮M，同时收集到的无用结点个数为M一N
显然，无用单元收集这项T作的效率和最后能收集到的可以重新分配的无用结点数有关。 我们用收集一个无用结点所需的平均时间（ + ）/（M一N）来度量这个效率。假设以p：N / M表示内存使用的密度，则上述平均时间为(CIP + 0）/（1一。当内存中3／4的结点为无用结点，即p一1 / 4时，收集一个结点所需平均时间为1 / 3！：，+ '030。反之 ， 当内存中 I内 的结点为无用结点 ， 即 p一3／4 时 ， 收集一个结点所需平均时间为 3 ：，曰 4 ！：“ 由此可见 ． 可利用内存区中只有少量的结点为无用结点时 ， 收集无用单元的操
2 ] 1
作的效率很低。小仅如此，且当系统币又恢复运行时，这些结点又很快被消耗抻，导致另一次无用单元的收集。如此下去有可能造成恶性循环以至最后整个系统瘫痪。解决的办法可以山系统事先确定一个常数差，当收到的无用单元数为差或更少时系统就不再运行下去。
& 6存储紧缩
前面几中时论的动态存储管理方法都有一个共同的特点，即建立一个“空闲块”或 “无用结点”组成的可利用空间表，这个可利用空间表采用表结构，其结点人小可以相同，也可以不同。
这节将介绍另一种结构的动态存储管觋方法。在整个动态存储管理过中，不
] 2
28
(d)
图802堆存储管理示意图
(a)堆空间0申的有儲映像：（后的堆；(d)改后的存映像
管哪个时刻，可利用空间都是一个地址连续的存储区，在编译程序中称之为“堆"，莓次分配都是从这个可利用空间中划出块。其实现办法是：设立一个指针，称之为堆指针，始终指向堆的最低（或最高）地。当用户中请N个单位的存储块时，堆指针向高地址〈或低地址）移动N个存储单位，而移动之前的堆指针的值就是分配给用户的占用块的初始地。回顾第1章中提及的串值存储空间的动态分配就是用的这种堆的存储管理。例如．某个申处理系统中有A、B、c、D这4个串，其串值长度分别为12、6、10和8。假设堆指钅I- fr〔℃的初值为零，则分配给这4个串值的存储空间的初始地址分别为0、12、] 8和 28．如图802（羽和（b〕协示．分配后的堆指针的值为36。因此，这种堆结构的行储管理的分配算法非常简单。反之，回收用户释放的空闲块就比较麻烦。由J系统的可利用空间始终是一个讪川连续的存储块，因此回收时必须将所释放的空闲块合并到整个堆上去才能重新使用．这就是“存储紧缩”的任务。通常，有两种做法，一种是一旦有用户释放存储块即进行回收紧缩，例如，图8，1 2（的的堆，在串释放存储块时即回收紧缩成为图8，1 2 （c)的堆，同时修收串的存储映像成图& 12（d）的状态；另一种是在程序执行过程中不回收用户随时释放的存储块，直到可利用空间不够分配或堆指针指向最高地址时才进行存储紧缩。此时紧缩的目的是将堆中所的空闲块连成一片，即将所有的占用块都集中到可利用空间的低地址区．而剩余的高地址区成为一整个地址连续的空闲块，如图& 13所示．貝中@为紧缩前的状态，（b）为紧缩后的状态。图8，1 3紧缩前后的堆（存储空间）
@紧缩前；(b)米缩后
和上节讨论的无用单元收集类似，为实现存储紧缩，首先要对占用块进行“标志”，标志算法和上节类同（存储块的结构可能不同其次需进行下列4步襟作：
( I )计算占用块的新地址。从最低地址始巡查整个存储空问，对每一个占用块找到它在紧缩后的地址。为此、需设立两个指针巡查向前移动，这两个指针分别指示占用块在紧缩之前和之后的原地址和新地址。因此，在每个占用块的第一个存儲单位中．除了设寸长度域（存儲该占用块的大小）和标志域（存储区别该存储块是占用块或空闲块的标志）之外，还需设立一个新地址域，以存储占用块在紧缩后应有的新地址，即建立一张新、旧地址的对照表。
（2） 修改用户的初始变量表，以便在存储紧缩后用户程序能继续正常运行、
（3） 检查每个占用块中存储的数据。若有指向其他存储块的指针，则需作相应修改。
（4） 将所有占用块迁移到新地址去。这实质上是作传送数据的工作。
至此，完成了存储紧缩的操作。最后，将堆指针赋以新值（即紧缩后的空闲存储区的最低地址
可见，存储紧缩法比无用单元收集法更为复杂，前者不仅要传送数据（进行占用块迁移），而们要修改所有占用块中的指针值。因此，存储紧缩也是一个系统操作，且非不得已就不用。
2 1 3
第9章查找
本书在第2章至第7章中已经介绍了各种线性或非线性的数据结构，在这一章将讨论另一种在实际应用中大量使用的数据结构一一查找表。
查找表（S艹?ehTable)是由同一类型的数据元素（或记录）构成的集合0由于“集合” 中的数据元素之间存在着完全松散的关系·因此查找表是一种非常灵便的数据结构。
对查找表经常进行的操作有：（D查询某个“特定的．'数据元素是否在查找表中；（2）检索某个“特定的”数据元素的各种属性3）在查找表中插人一个数据元素4）从查找表中删去某个数据元素。若对查找表只作前两种统称为“查找”的操作，则称此类查找我为静态查找表(Static Search ble)。若在查找过程中同时插人查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据儿索、则称此类表为动态查找（历nam跹Search。
在曰常生活中，人们几乎每天都要进行“查找”工作“例如，在电话号码簿中查阅“某单位”或“某人”的电话号码；在字典中查阅“某个词”的读音和含义等等。其中“电话号码簿”和“字典”都可视作是一张查找表。
在各种系统软件或应用软件中，查找表也是最常见的结构之一。如编译程序中符号表、信息处理系统中信息表等等。
山十述可见，所谓“查找”即为在一个含有众多的数据元素（或记录）的查找表中找出某个“特定的”数据元素（或记录
为了便于讨论，必须给出这个“特定的”词的确切含义d首先需引人一个“关键字”的概念。
关键字（Key）是数据元素（或记录）中某个数据项的值，用它可以标识（识别〉一个数据元素（或记录）。若此关腱字可以惟一地标识一个记录，则称此关键字为主关键字 (Primary Key）（对不同的记星，其主关字均不同）。反之，称用以识别若干记录的关讲字为次关F(Secondary Key) ?当数据元素只有一个数据项时，其关键字即为该数据元素的值。
*frk(Searching)根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找是成功的，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等丁给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空"指针
例如，当用计算机处理人学人学考试成绩时，全部考生的成绩可以用图9，1所小表的结构储存在计算机中，表中每“行为一个记录、考生的准考证号为记录的关键字。假设给定值为179326，则通过查找可得考生陆华的各科成绩和总分，此时查找为成功的。若给定值为] 79238，则由于表中没有关键字为179238的记录，则查找不成功。
如何进行查找？显然，在一个结构中查找某个数据元素的过程依赖于这个数据元素在结构中所处的地位；因此，对表进行查找的方法取决于表中数据元素依何种关系〈这个关系是人为地加上的）组织在一起的。例如查电话号码时，由于电话号码簿是按用户（集体或个人》的名称（或砰名）分类且依筆划顺序编排，则查找的方法就是先顺序查找待查用户的所属类别，然后在此类中顺序查找，到找到该用户的电话号码为止。又如，查阅英文单词时，由于字典是按单词的7母在字母表中的次序编排的，因此查找时不需要从字典中第一个单词比较起，而只要根据待查单词中每个字母在字母表中的位置查到该单词。图9，]高考成绩表示例
同样，在计算机中进行查找的方法也随数据结构不同而不同。正如前所述，本章讨论的查找表是一种非常灵便的数据结构。但也正是由于表中数据元素之间仅存在着“同属一个集合”的松散关系，给查找带来不便。为此，需在数据元素之间人为地加上一些关系，以便按某种规则进行查找，即以另一种数据结构来表示查找表。本章将分别就静态查找表和动态查找表两种抽象数据类型讨论其表示和操作实现的方法“
在本章以后各节的讨论中，涉及的关键字类型和数据元素类型统一说明如下：典型的关键字类型说明可以是
typedef float KeyType；//实型 d整型
typedef eh“吖pe；//字符串型
数据元素类型定义为
typedef struct {
KeyType key; 关字域
／7其他域
} El p銣
对两个关键字的比较约定为如下的宏定义：
一一对数值型关字
# de臼“ EQ()t b) ((a)
# def LT()' b)《 （b 0
#define L00，b)
汐一一对字符串型关键字
# def璣（山b) (!strcmp((a) i (b))) %define LT(), b) (strcmp((a). ( b) )
*define（（str亡呷气，(b) ) < C)
9．1静态查找表
抽象数据类型静态查找表的定义为；
DT StaticSearchTable {
数据对象D：D是具有相同特性的数据元京的集合；各个数据元素均含喻类型相同，可惟一标识数据元素的关键字。
数据关系R：数据元素同展．个集合“ 基本操作p：
Create（．巾；
操作结果：构造一个含n个数据元素的静态查找表ST。
Destroy( & (T)；
初始条件：静态查找表ST存在。
操作结果：销毁ST.,
Search(，key)J
初始条件：静态查找表ST存在，k啩'为和关字类型相同的给定值。
操作结果：若ST中存在其关字等于key的数据元素，则函数值为该元素的值或在表中的
位置，古则为“空”
Traverse(ST,
初始条件：静态查找表ST存在，v跹是对元素操作的应用甬数
操作结果《按某种次序对ST的每个元素调用函数v让0一次且仅一次。 一旦到s过0失敢，则襟作失败。
StaticSearchTab1e
静态查找表可以有不同的表示方法，在不同的表示方法中，实现查找操作的方法也不同。
9．1. 1顺序表的查找
以顺序表或线性雠表表示静态查找表，则& arch函数可用顺序查找来实现。本节中只讨论它在顺序存储结构模块中的实现，在线性链表模块中实现的情况留给读者去完成
一静态查找表的顺序存储结
typedef {
ElemType薯
彦数据元素存储空间基址，建表时按实际长度分配，0号单元留空
length;
万表长度
}SSTab1e;
下面讨论顺序查找的实现
顺序查找（Sequentia吓earch）的查找过程为：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个j己录的关键字和给定值比较相等，则查找成功，找到所查记录《反之，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录，查找不成功。此查找过程可用算法9．1描述之。
int Search- Seq(SSTable Ke#ype e {
／7在顺序表ST中顺序查找其关踺字等于key的数据元素。若找到，则函数值为 该元素在表中的位置．否则为善
． ·
ST.elem「0].key key； 汐一哨兵，
fot ( i。ST.length； 阳誑ST、elem[il.key，key)； 一i)；从后往前找
return i ／/找不到时湖．为0 》Search- Seq
算法9，1
这个算法的思想和第2章中的函数一致。只是在search-Seq中，查找之前先对ST，el “走明的关键字賦值key，目的在于免去查找过程中每一步都要检测幣个表是否查找完毕。在此，ST．小过明起到了监视哨的作用。这仅是一个程序设到技巧上的改进，然而实践证明，这个改进能使顺序查找在I。'@、01 000时，进行一次杳找所需的平均时间几平减少一半（参阅参考书目0〕中342页表7，0。当然，监视哨也可设在高下标处。
查找操作的性能分析
在第1章中曾提及，衡量一个算法好坏的量度有3条：时间复杂度（衡量算法执行的时间量级）、空间复杂度（衡屋算法的数据结构所占存储以及大屋的附加存储）和算法的其他性能。对于查找算法来说，通常只需要一个或几个辅助空间。又，查找算法中的基卞操作是“将记的关鍵字和给定值进行比较"，因此，通常以“其关鍵字和给定值进行过比较的记录个数的平均值"作为衡量查找算法好坏的依据
定义：为确定记录在查找表中的位置，的和给定值进行比较的关鍵字个数的期望值称为查找算法在查找成功时的平均查找长度（Avera “ search Length)0 对于吉有个记录的表，查找成功时的平均查找长度为
ASL一〉2 （9一1）
其中：P，为查找表中第i个记录的概率．目，乥p，一1；
o为找到表中其关腱字与给定值相等的第个记录时，和给定值已进行过比较的关键字个数。显然，0随查找过程不同而不回。
从顺序查找的过程可见，0取决于所查记录在表中的位置。如：查找表中最后一个记录时，仅需比较一次；而查找表中第一个记录时、则需比较，！次。一般情况下0等于假设，冖ST彐en@1，则顺序查找的平均查找长度为
ASL = +一l )琅+ “ + 2P闩+ P，假设每个记录的查找概率相等，即
则在等概率情况下顺序查找的平均查找长度为
（9．2）
ASL 0一3） 2
有时，表中各个记录的查找概率并不相等。例如：将全校学生的病历惝案建立一张表存放在词算机中，则体弱多病同学的病历记录的查找概率必定高于健康同学的病历记录由于式（9一2）中的．ASL在丛冫地 一冫塏PI时达到极小值；因此，对记录的查找概率不等的查找表若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由小至大重新排列，以便提高查找效率。
然而，在一般情况下，记录的查找概率预先无法测定。为了提高查找效率，我们可以在每个记录中附设一个访问频度域，并使顺序表中的记录始终保持按访问频度非递减有序的次序排列，使得查找慨率大的记录在查找过程中不断往后移，以便在以后的逐次查找中减少比较次数。或者在每次查找之后都将刚查找到的记录直接移至表尾。
融序查找和我们后面将要词论到的其他查找算法相比，其缺点是平均查找长度较大，特别是当很大时，查找效率较低。然而，它有很大的优点是：算法简单且适应面广。它对表的结构无任何要求，无论记录是否按关踺字有序山均可应用，而且，上述所有讨论对线性表也同样适用。
容易看出，上述对平均查找长度的讨论是在习：1的前提下进行的，换句话说，我们认为每次查找都是“成功”的。在本章开始时曾提到，查找可能产生“成功”与“不成功”两种结果，但在实际应用的大多数情况下，查找成功的可能性比不成功的可能性大得多，特别是在表中记录数“很人时，查找不成功的概率可以忽略不计。当查找不成功的情形不能忽视时，查找算法的平均查找长度应是查找成功时的平均查找长度与查找不成功时的平均查找长度之和。
对于顺序查找、不论给定值差0为何值，查找不成功时和给定值进行比较的关字个数均为十1。假设查找成功与不成功的可能性相同，对每个记录的查找概率也相等，则 = 00D，此时顺序查找的平均查找长度为
（9一4）在本章的以后各中，仅时论查找成功时的平均查找长度和查找不成功时的比较次数，但哈希表例外。
9，1. 2有序表的查找
以有序表表示静态查找表时，&自reh函数可用折半查找来实现。
折半查栈（Binary Search）的查找过程是：先确定待查记录所在的范围（区间），然后逐d)若表中所有记的关满足下列关系
ST.elem-il. key?é'l-. em(i + ]」．key i— 划称表中记录按关字有序。
· ．
出缩小范围直到找到或找不到该记为止
例如：已知如下11个数据元素的有序表（关键字即为敵据儿素的俏）：
(0 5，13冒9，2匚3 7．5 6，64，7 5，80，8 8，9 2）
现要查找关键字为21和85的数据元素
假设指针“和分别指小待查元豕所在范围的下界和上界，指针指示区间的中间位置，即m滬一I（。“ +耵2」。在此例中，／。“和的初值分别为1和 Il，即0，10为待查范围。
下面先看给定值key—21的查找过程：
] 3 1 9 2 ] 3 7 5 6 64 7 5 8 0 8 8 9 2 忄／0 忄high
首先令查找范围中间位置的数据元素的关键字ST.与给定值key相比较，因为ST. elemrmld-.雇y > key，说明待查元素若存在，必在区间冒。艹m滬一0的范围内，则令指针high指向第个元素，重新求得一[0十5〕／2」一3
] 3 1 9 3 7 5 6 64 7 5 80 88 92 个个mid个high
仍以ST. elemCrmd]. key和key相比，因为ST.〕，key < key，说明待查元素若存在，必在+ 1而g到范围内，则令指针[。w指向第m + 1个元素，求得滬的霸值为
4，比较ST．elem[ m@．key和key，因为相等，则查找成功，所查元素在表中序号等于指针
mtd的值。
0 5 2 1 37 56 今柄“忄high 忄mid 再看key—85的查找过程：
75
80 88
9 2
05 13 37 56 64
75
80 88
92
f iow 忄mid
ST. elem[rnld]. key<key令柄一忉+ 1
high
ST. elerntmid_l. key<key令10在一m囝+ 1
ST. elem[tnid). key>key令high*zmid? 1
忄mid
个虧g
忄lotvt g方
忄g忄low
此时因为．卜界“>十界后，则说明表中没有关键字等于key的元紊，查找不成功。
从上述例子可见，折半查找过程是以处于区间中间位置记录的关键字和给定值比较，若相等，则查找成功，若不等，则缩小范围，直至新的区间中间位置记录的关键字等于给定值或者查找区间的大小小于零时〔表明查找不成功）为止匕述折半查找过程如算法9．2描述所示
int Search. Bin（SSTab1e ST, Key'l?ype key）{
在有序表中折半查找其字等于k“的数据川素、若找到，则函数值为
#该元素在表中的位罟．否则为0。
10 ]；high ST. length; /／置区间初值
while 00w mid
()Q (key，ST.elemrmid」. key) ) return； el if（閿' (key，ST. el《回midl.key)) high mid el$e 10“ m i d，
return 0；
找到待查元素
／／继续在前半区间进行青找 继续礼后半区间进行查找彦顺序表中不存在待查“素
／Search- Bin
算法2
忻半查找的性能分析
先看上述] ]个元素的表的具体例子。从十述查找过程可知：
找到第@个元素仅需比较]次；找到第和第@个元素需比较2次；找到第〔0、@、0 和@个元素需比较3次；找到第0、的、的和@个元素需比较4次。
这个查找过程可用图9，2所示的了叉树来描述。树中每个结点表示表中一个记录，结点中的值为该记录在表中的位置，通常称这个描述查找过程的二叉树为判定树，从判定树上可见，查找21的过程恰好是走了一条从根到结点．的路径，和给定值进行比较的关腱字个数为该路径1的结点数或结点@在判定树上的层次数。类似№，找到有序表中任一记录的过程就是走了一条从根结点到与该记录相应的结点的路径，和给定值进行比较的关腱字个数恰为该结点在判定树上的层次数。因此，折半杳找法在查找成功时进行比较的关键字个数最多不超过树的深度，而具有月个结点的判定树的深度为自” J+ 1丛所以，折半查找法在查找成功时和给定值进行比较的关键字个数至多为自嵫利+ 1。
如果在图9，2所示判定树中所有结点的空指针域上加一个指向一个方形结点的指针，如图9．3所示、并且，称这些方形结点为判定树的外部结点（与之相对，称那些圆形结点为内部结点），那么折半查找时查找不成功的过稃就是走了一条从根结点到外部结点的路径，和给定
图9．2描述折半查找过程的判定树
值进行比较的关键字个数等于该路径上内部结
及查找21的过程
点个数，例如：查找85的过程即为走了一条从
根到结点「9《到的路径。因此，折半查找在查找不成功时和给定值进行比较的关踺字个数最多也不超过山“ + 1。
那么，折半查找的平均查找长度是多少呢？ 仞判定树完全二叉树，但它的叶子结点听在层次之差最多为[ ·则，，个结点的判定树的深度和，，个结点的完佘叉树的深度同“
· ·
为讨论方便起见，假定有序表的长度” = 2b一1（反之以十1月，则描述折半查找的判定树是深度为/的满二叉树。树中层次为1的结点有1个，层次为2的结点有2 个，． ，、层次为/，的结点有2一个。假设表中每个记录的查找概率相等 @！找成功时折半查找的平均查找长度对任意的当“较大0050）时，可有下列近似结果
ASLi6 四一6）可见，折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构（对线性链表无法有效地进行折半查找）。
以有序表表示静态查找表时，进行查找的方法除折半查找之外，还有斐波那契查找和插值查找。
斐波那契查找是根据斐波那契序列。的特点对表进行分割的。假设开始时表中记录个数比某个裴波那契数小1，即”一一然后将给定值key和ST,訛m〔F一0．key进行比较，若相等，则查找成功，若key<ST. elemCFu-lJ. key，则继续在自ST,至 ST. elem(Fo 一1 ]的子表中进行查找，否则继续在自ST. elernCF?-I + 1 ]至ST. elem [ F。一1〕的子表中进行查找，后一子表的长度为F一2一1。斐波那契查找的平均性能比折半查找好，但最坏情况下的性能（虽然仍是0山即D)却比折半查找差。它还有一个优点就是分割时只需进行加、减运算。 ·
插值查找是根給定值k ” *确定进行比较的关键字s m「0. k y的找方法, key … ST. eletnjl]. ke
( h一|十1 ) ,其中ST. elen旧|和ST “ It 14〕分 ST. elem hi. key—S"I'. elcmtll. key
別为有序表中具有最小关键字和最大关键字的记录。显然,这种插值找只适于关键字均匀分布的表,在这种情况下,对表长较大的顺序表,其平均性能比折查找好-
1. 3静表的查找
上一小节对有序表的找性能的讨论是在“等概率”的前提下逬行的,即当序表中各记录的找穊率和等时、按图2所示判定树描述的找秤*进行折平查找,其件能最优。如果有序表中记录的查找概率不等,情况又如何呢?
先養一个只体例子。假设有序表中含5个记录,并且已知各记录的查找概率不等,分別为= 0 ? 1 ,一= 0. 2 , = (凵, = 0. 4和ps = 0.则按式( 9一l)的定义,对此有序表进行折半查找,查找成功时的平均查找长度为
= 0」>“ X 3十04 1」一0 >: 2十0. 2 : 3一
但是,如果在查找时令给定值先和第4个记录的关键字进行比较,比较不相等时冉继续在左f序列或右子序列中进行折半查找,则查找成功时的平均查找长度为
P.C. = 0」X 3 0 , 2 X 2十0」X 3十0. 4 X 1 0. 2 X 2一
这就说明,序表中各记录的查找穊小等时,按图2所不判定树进行折平找,其性能未必是最优的”那么此时应如何行查找呢?换句话说,描迩找过程的判定树为何类二树时,查找性能最仩?
如果只考虑找成功的情况,则便查找性能达最佳的判定树是其带权內路径度之和PH值
PH ~ >
取最小值的二叉树。其中: ”为二树上结点的个(即有序表的长度)为第个结点在二叉树上的层次数;结点的权“ , n) ,其中pt为结点的查找概率, c为某个常量。称p值取最小的二叉树为静态最优查找树( Sta Optimal Search Tree) e 由于构造静态最优查找树花费的时间代价较高,因此在本书中不作详细讨论,有兴趣的读者可查阅参考书目〔1〕。在此向读者介绍一种构造近似最优查找树的有效算法
已知一个按关键字有序的记录序列
( 8 )
其中 key〔” key< , : key 与每个记录相应的权值为
( 9一9 ) 一 具有同样权值的
现构造一棵二叉树,使这棵 :叉树的带权内路径长度PH值在所有CD尸H和均找度正,
树中近似为最小，称这类二贮树为次优查找树（№ “ ly ()ptimal search Tree)O
构造次仇查找树的方法是；首先在式（9一8）所示的记录序列中取第《0《们个记录构造根结点C〕．使得取最小值( )P．一m山适的D，然后分别对子序列，。'，，，0一0和{ 0凵“，，0 }构造两棵次优查找树，并分别没为根结点0的左子树和右子树。
为便于计算AP，引入累月权值和
（9 ] l )
釘设“到“ 0和，“一]一0，则
（9一0
（的1 3）由此可得构造次优查找树的递归算法如算法9，3所示。
vo Se白川dOpLi1叼1（niTree &T，F,lern?rype (I)j卜f)吡$司0，int 1，int high) {
由有序表@1“、伍qh」及其累计权值表“（其中s卦明一一的递归构造次优查找树TO
10 min訃以．“ 00到highl．0：司0 “一1上 for 0 = 1～+丛力《= high；．凵．的 //选择最小的，俏T一0 data：RI直韦珏” = 1 “）T ->lchild NULL;
01g0 SecondOptinal(T->lchild, R' 1 “，i- l)； high) T">rchild = N；
01 SecondOptimal(T—>rchi1d, R. s，土+ l ?
生成结点 左子树空
//构造左子树 /7右子树空
构造右子树
}／/ SecondOptisnal
算法9，3
例9刁已知含9个关键字的有序表及其相应权值为：
关字A C D E F G H I 权值] 4 3
则按算法9．3构造次优查找树的过程中累计权值SW和P的值如图9．4（a）所示，构造所得次优二叉查找树如图9，4（b）所示。
·
12 1 623 2 8 AP23 〈根）
（根）
（根） 图9湖构造次优二叉查找树示例累计权值和AP值，(b)次优查找树
山于在构造次优查找树的过程中，没有考察单个关键字的相应权值，则有可能出现被选为根的关键字的权值比与它相邻的关键字的权值小。此时应作适当调整：选取邻近的权值较大的关键字作次优查找树的根结点。
例9一2已知含5个关键字的有序表及其相应权值为
关键字A 则按算法9．3构造所得次优查找树如图9．5（a）所示，调整处理后的次优查找树如图9．5山）所示。容男算得，前者的PH值为132，后者的P科值为105。
大量的实验研究表明，次优查找树和最优查找树的查找性能之差仅为1％一29亻，很少超过3氵而
且构造次优查找树的算法的时间复杂度为
根的权小于子槲根权的情况（调之前的次优查找树；
o（司。g的，因此算法9，3是构造近似最优二叉查找
(b)调之后的次优查找树
树的有效算法。
从次优查找树的结构特点可见，其查找过程类似于折半查找。若次优查找树为空，则查找不成功，否则，首先将给定值差0和其根结点的关键字和比，若相等，则查找成功，该根结点的记录即为所求；否则将根据给定值軛二y小于或大于根结点的关键字而分别在左子树或右子树中继续查找直至查找成功或不成功为止（算法描述和下节讨论的一叉排序
224 ·
树的宵找算法类似．在此省略）。由于查找过程恰是走了一条从根到待查记录所在结点（或叶子结点）的一条路径．进行过比较的关键字个数不超过树的深度，因此．次优查找树的平均查找长度和帛“成正比。可见，在记录的查找佴率不等时，可用次优查找树表示静态查找树，故又称静态树表，按有序表构造次优查找树的算法如算法9，4所示。
typedeE BiTree 次优查找树采用二叉链表的存储结构 a上0 Create$OSTree( SO$Tree，$1') {
々由有序表5T构造一棵次优查找树。$的数据兀素含有权域“以 if（ST，length 的T N刂陆 eige {
F土nd$巫臼巫(T)； //按由有序表ST中各数据元素的艹ig址域求累计权值表“。
Second0piama1(), ST.elem. $ 0 ST. lengt-hh
return 0卜，
} Create 3弋仁
算法 9，4
9、1，4索引顺序表的查找
若以索引顺序表表示静态查找表，则Search函数可用分块查找来实现
分块查找又称索引顺序查找，这是顺序查找的一种改进方法。在此查找法中，除表本身以外，尚需建立一个“索引表"。例如，图9．6所示为一个表及其索引表，表中含有18个记录，可分成3个了表（蛰，R。一RIO，对每个了表（或称块）建立一个索引项，其中包括两项内容：关字项〔其值为该了表内的最人关字）和指针项（指示该．了表的第一个记录在表中位置索引表按关键字有序，则表或者有序或者分块有序。所谓“分块有序"指的是第二个了表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大子第二个子表中的最大关键
，，依次类推孬
起始址
因此，分块查找过程需分两步进行。先确定待查记录所在的块（子表），然后在块中顺序查找。假设给定值y一38，则先将短y依次和索引表中各最大关键字进行比较，因为 22 <桓y<，则关字为38的记录若存在，必定在第二个子表中，由于同一索引項中的指针指示第二个子表中的第一个记录是表中第7个记录，则自第7个记录起进行顺序查找，直到ST.eIemCIQ_1.key=key为止。假如此子表中没有关字等于0的记录（例：-v一29 时自第7个记录起至第12个记录的关键字和key比较都不等），则查找不成功。
由于由索引项组成的索引表按关選字有序．则确定块的查找可以用顺序查找，亦可用山半盘找．曲块中记录是任意刎的，则在块中只能足顺序找。
由此，分块查找的算法即为这两种查找算法的简单合成。
分块查找的平均查找长度为
（9刁4) 其中；为查找东引表确定所在块的平均查找长度，L*为在块中查找元素的平均查找长度。
一般情况下，为进行分块查找，可以将长度为阎的表均匀地分成／块，每块含有、个记录，即／冖「@又假定表中每个j己录的查找概率相等，则每块查找的概率为1冲，块中每个记录的查找概率为0
若用顺序查找确定所在块，则分块查找的平均查找长度为
（9一15丿可见，此时的平均查找长度不仅和表长有关，而且和每一块中的记录个数5有关。在给定“前提下是可以戩择的。容易证明．当取血时，穒取最小值一1，上这个佰比顺序查找有了很大改进，但远不及折半查找
若用折半查找确定所在块，则分块查找的平均查找长度为
ASL （9．16） 9．2动态查找表
在这一节和下一节中，我们将讨论动态查找表的表示和实现动态查找表的特点是，表结构本身是在查找过程中动态生成的，即对于给定值短y，若表中存在其关键字等于差0的记录，则查找成功返回，否则插人关键字等于0的记录。以下是动态查找表的定义：
抽象数据类型动态查找表的定义如下：
n“玉c arch铲0b10 {
数惦对象D山是具有同特性的数据元素的集合。各个数据元素均含有类型相i小可惟．标识数据兀素的关腱字。
据关系R：数据兀素同一个集合。
基本作P：
In就$T訃Te（&）；
操作结果：构造一个空的动态查找表的。
DestroyDSTable( &DT);
初始条件动态查找表DT存在。
操作结果：销毁动态查找表DT
SearchDSTab1e(DT, key)
初始条件：动态查找表存在，key为和关键字类型相同的给定值 226
操作结果：若DT中有其关鍵字等于key的数据元素．则函数值为该元素的值或在表中的
位置、否则为“空'》
InsertDSTab1e(&?ryr.的；
初始条件：动态查找表存在．。为待插入的数据元素。
操作结果：若中不存在其关键字等丁e，key的数据元素，则插入e到
DeleteDSTab1e(&DT, key)；
初始条件：动态查找表DT存在，key为和关踺字类型相同的给定值。
作结果：若DT中存在其关腱字等丁key的数据元，则删除之
TraverseDSTab1 e( DT，Visit 0）；
初始条件：动态查找表DT存在，si的是对结点操作的应用函数。
操作结果：按某种次序对的每个结点调用函數旧t的一次且至多．次。 一旦Vi的让0失
败，则操作失败
〉Dynarn icSearchTab1e
动态查找表亦可有不同的表示方法。在本节中将讨论以各种树结构表示时的实现方法。
9．2．]二叉排序树和平衡二叉树
I .二叉排序树及其查找讨程什么是二叉排序树？
二叉排序BJ(Binnry Sort Trce)或者是一棵空树；或者是具有下列性质的二叉树：（1 )若它的左子树不空，则左子树上所有结点的值均小子它的根结点的值；（2）若它的右子槲不空，则右子树上所有结点的值均大子它的根结点的值；（3）它的左、右子树也分别为一叉排序树
例如图9．7所示为两棵二叉排序树。图9．7二排序树示例
二叉排序树又称二又查找树，根据上述定义的结构特点可见，它的查找过程和次优一叉树类似。即当二叉排序树不空时，首先将给定值和根结点的关键字比较，若相等．则查找成功，否则将依据给定值和根结点的关鍵字之间的大小关系，分别在左子树或右子树上继续进行查找。通常，可取二叉链表作为二叉排序树的存储结构，则上述查找过程如算法 9，5（a）所描述
·
BiTree SearchBST(BiTree T，Kef%rpe key){
在根指钊T所指二又排序树中递归地查找某关键字等于ke、，的数据元素，
《若卉找成功．则返回指向该数据元素结点的到，否则回空指针叙( )T）．F?Q(key,T 查找结秉
I 0 LT(keys?r *data. key) teturn(SearehBG('I'-I>lehild.key)) i
else return〔SearchBST( l' prchlld，key))； /7在右子树中继查找(，7在左于树中继续查找)}// SearchBST
算法9．5〈a）
例如：在图90气的所示的一又排序树中查找关字等于蜘0的i己录（树中结点内的数均为记录的关键字丿。首先以差“ =（100）和根结点的关键字作比较，因为，>，则查找以的为根的右了树．此时右子树不空，且0 > 53，则继续查找以结点为根的右子树，由于0和0的右子树根的关键字] 00相等，则查找成功，返回指向结点@的指针值。又如在图9．7（的中查找关字等于的记录，和上述过程类似，在给定值差0与关键字巧、] 2及37相继比较之后，继续查找以结点0为根的右子树，此时右子树为空，则说明该树中没有待查记录，故查找小成功，诉回指针值为“ NULL ”。
2，二叉排序树的插人和删除
和次优二叉树相对，二叉排序树是一种动态树表。其特点是，树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插人。新插人的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩了或右孩子结点。为此，需将上一小节的过叉排序树的查找算法改写成算法9、5( l小以便能在查找小成功时返回插人位置。插人算法如算法〔所示。
Status SearchHST(BiTree T ey'T、' &@ {
/／在限指针所指二叉排序树中睇归地查找其关字等于key的数据元素，若查找成功，则指到P指向该数据兀素结点．并返回T即否则指针p指向查找路径上访问的 最后一个结点并返回L指针f指向T的双亲，其初始调用值为№、L
玉f( !的 在f；return FAIN身 //查找不成功 ge EQ(key,T ->data.key) {P．return 才查找成功
el订LT(keY.T€>data、key) return SearchEM(T->lchAd'keY'T'Ph方在左子树中继续查找 else return SearchBST(T—>、rchild'key， 方在右子树中继续查找 }夕SearchBST
算法9．5（b》
Status InsertBST( BiTree &T．Ft e）{
／，'当二叉排序树T中不有在关踺字等于e，key的数据元素时，抓人e并返回TRUE'
否则返回FALSE
if (!Searc:hBST《T. e.key，NULL? p〕{ 差查找不成功
(sizeoE (BiTN0de))：
一：、'℃hild璧NULL'
被插结点“ s为新的根结点
色18跹LT(e.ke9% P?>data?key) P ?> lehild s; 被插结点s为左孩子 else p?--->rchihd 被插结点蕢5为右孩子 return 1哋；
return FALSE ; 树中已关字相同的结点，不再插丿、 Insert HST
箅法9．6
若从空树出发，经过一系列的查找插人操作之后，可生成一棵二叉树 设查找的关键字序列为生5，24，53，45，1厶24．90丛则生成的二又排序树如图9，8所示。图9．8二叉排序树的构造过程
（的空树；(b)插人巧，〈．届人2耘(d)插人53；(e)插人12，( f)播人90
容易看出，中序遍历二叉排序树可得到一个关键字的有序序列（这个性质是由一叉排序树的定义决定的，读者可以自己证明之）。这就是说，一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列，构造树的过程即为对无序序列进行排序的过程“不仅如此，从上面的插人过程还可以看到，每次插人的新结点都是二叉排序树上新的叶子结点，则在进行插人操作时，不必移动其他结点，仅需改动某个结点的指针，由空变为非空即可。这就相当于在一个有序序列下插人一个记录而不需要移动其他记录。它表明，二叉排序树拥有类似于折半查找的特性，又采用了链表作存储结构，因此是动态查找表的一种适宜表示。
同样，在二叉排序树上删去一个结点也很方便。对于一般的二叉树来说，删去树中个结点是没有意义的。因为它将使以被删结点为根的子树成为森林，破坏了整棵树的结构、然而，对丁二叉排序树，删去树上一个结点相当于删去有序序列中的一个记录，只要在删除某个结点之后依旧保持二叉排序树的特性即可。
那么，如何在二叉排序树上删去一个结点呢？假设在二叉排序树上被删结点为簧产（指向结点的指针为p），其双亲结点为以（结点指计为0，且不失一般性，可设p是以的左孩子（图9，9（翻所示
下面分3种情况进行讨论：
o）若p结点为叶了结点，即片和均为空树。由于删去叶子结点不破坏棵树的结构．则只需修改其双亲结点的指针即可。
（2）若簧p结点只有左子树PL或者只有右子树PR此时只要令PI或PR直接成为其以下均間称指针p（或f等〕所指结点为氏或' f等丿结点．pL和「R分别表示其左子树和右子树
双亲结点0的左了树即可。显然，作此修改也小破坏二叉排序树的特性。
o）若耳p结点的左了和右了树均不空。显然，此时不能如十单处理一从图9.以可知，在删去罢p结点之前，中序遍历该二叉树得到的序列为{．“ CIC “．0，QSI SPPRF “．丛在删去哭p之后，为保持其他元素之间的相对位置不变．可以有两种做法：其一是令关p 的左子树为到的左子树，而．p的右子树为诫5的右子树，如图90（c)所示；其二是令谨p的直接前驱〔或直接后继）替代p，然后再从二叉排序树中删去它的直接前驱（或直接后继）。如图9．9（d)所示，当以直接前驱“替代p时，由于只有左子树S'.，则在去之后，只要令Sl为“的双亲泯q的右子树即可。图9．9在二叉排序树中删除唧
@以以为根的子树《（除．p之前
@删除憐p之后，以作为“ $的右子树的情形；
@）除0》之后，以吓代，的形
在二叉排序树上删除一个结点的算法如算法〔所示，其中山前述3种情况综合所得的删除操作如算法9．8所示。
DelQEeBST (Bitree，KeyType key）{
／/若二叉排序树T中存在关键字等于key的数据元素时，则蒯除该数据元素结点，
并返回THU否则返回FALSE
if 00 return F泔 汐不存在关诞字等于key的数据元素 else {
00 (key. TO、data, key)) {return D01就e (T) }；//找到关字等于key的数据元素 else ()T (key，T ．key)）return DeleteBST（T一>〕℃h 1
o苋，0 tetürn De〕.eteBST（T一>，key）；
} // DeleteBST
箅法 9．7
其中删除操作过程如算法9．8所描述：
Status Delete（BiTree）{
//从二叉排序树中删除结点p．并重接它的左或右子树
迁( !p ->rchild〕{ /7右子树空则只需甫接它的左子树 ?Ichildi [了e（q月
· 230 ·else if 0 p ，10h到d）{ /只需小接它的右了树
卩 、t℃ h到山00e（刂）；
左右了树均不
Ichild ;
while (s—>rchild) {q S；5 -.>rchild } 转左，然后向右到尽头
p 0一．data ' data； 汐' 5指向被删结点的“前驱，，
p）q一0 rc №〕d* Ichild： //接淆q的右子树 else q—:>lchild e?lchild; 重接q的左子树 delete S：
return TRUE;
} Delete
算法9，8
3．二叉排序树的查找分析
从前述的两个查找例了以0亠蜘0和々0艹冲〕见，在二又排序上查找其关键字
．
等 于给定值的结点的过程，恰是十了一条从根结点到该结点的路径的过程，和给定值比较的关键字个数等于路径长度加]（或结点所在层次数），因此，和折丫查找类似．与给定值比较的关键字个数不超过树的深度。然而，忻半查找长度为“的表的判定树是惟一的，曲含有个结点的二叉排序树却不惟。图9．中（a）和（b）的两棵二叉排序树中结点的值都相同，但前者山关字序列（0湖，53，1厶37，93）构成，面后者由关键字序列0201， 3 /，45，53，93）构成。0）树的深度为3，而（0树的深度为6。再从平均查找长度来看，假 i殳6个记录的查找概率相等，为06，则（的树的平均查找长度为
ASL/ 一0 + 2 + 2 + 3 + 3 +生〕旗的树的平均查找长度为
ASI, (一0 + 2 + 3 + 4 + 5 +到：：：2066图9．〕不同形态的叉查找树
（扪关諺字字列为曰5，2 5 3．1 2．3 7，的〕的一叉排序树：
〔关镶字序列为0 2，24.37．巧．5 3認幻的单支树
，23 ]
内此，含有“个结点的二叉排序树的平均查找长度和树的形态有关。当先后洒人的关键
字有序时，构成的二叉排序树蜕变为单支树。的深度为其平均查找长度为”
2
顾序查找相同丿，这是最差的情况。显然．最好的情况是它叉排序树的形态和折半查找的判定树相同，其平均查找长度和」。g。成正比；那么，它的平均性能如何呢
假设在含有（“》0个键字的序列中以，1、关鍵字小丁第一个关鍵字一下一1个关键字人T-第一个关键字，则由此构造而得的二叉排序树脊阎个记录的查找概率相等的悄
一
况卜，其平均查找长度为
P（胨的 。0，| 0〔P 0）了的 0（P(n一/一0 + 1后 （9一t的
其中尸(i)为含有个结点的一贮排序树的平均查找长度，则P (i)十]为查找左子树中每个X就字时听用比较次数的了均．P(n 一0到为查找右了树中每个关键字时所用比较次数的平均值。又假股表中个：0建字的排列是“随机"的，即任一个关俎字在序列中是第]个，或第？个 `或第，0、的率相同，则可对（9一10式从下等于0至一1取斗均值
P(r的一．〗：尸0、0
V riP(i) 0 0 一1月
容易看出1?-式括弧中的第一项和第二项对称。又，汾0时iP(l)：0，则上式可改写为月0 2
显然，P（的0，尸（0 =一山式（9一18）可推得
又
山此可得 一2 〔P（的 2
P (n)
山递推公式（9．19）和初始条件1>(1)：I可推得：则当
Inn
（9一0）
（9一1 9）
（9．2 0 由此可见，在随机的清况下，一又排序树的平均杳找长度和g门是等数量级的啕，在某些情况卜（有人研究证明，这种况出现的概率约为刂6．：00 0尚需在构成一贮排序树的过中进行“半衢化”处理，成为一叉平衡树。
1．平衡一叉树
平衡二叉树(Balanced Binary 0 ree或Height-Balanced “的更称AV长树。它或者是棵空树，或者是貝有卜列饣《质的一叉：它的左子树和右了树都是平衡一贮树，且寿子树和右子树的深度之差的绝刈值不超过]。若将．叉树上结点的平衡因子」（B詿“ 于的定义为该结点的左了树的深度减去它的右子树的深度，则半衡一叉树》所有结点的平衡因了只可能是一I、0和[。只要一树丨有一个点的平在因了的绝对值大T 1，则该二又树就是不平衡的“如图9．H00所示为两棵平衡二叉树，而图90枞的所示为两棵不平衡的二叉树，结点中的值为该结点的平衡因了。图9，归平衡与不平衡的二又树及结点的平衡因子
@平衡又树；（b冫不平的．叉树
我们希望山任亻可初始序列构成的二叉排序树都是AVL树，因为^ V匚树上任何结点的左右子树的深度之差都不超过]，则可以证明它的深度和虧gN是同数量级的（其中 N为结点个数）。山此，它的平均查找长度也和N同数量级。
如佝使构成的二叉排序树成为忄衡树呢？先看一个具体例子（参见图9口2）。假设表中关键字序列为03，24，37，90，53）。空树和1个结点的的树显然都是平窗的一树。在插人24之后仍是平衡的，只是根结点的平衡因了BF由0变为到；在继续插人37之后，由于结点的BF值山一1变成一2，山此出现了不平衡的现象。此时好比一根扁担出现．头重一头轻的现象，若能旖扁担的支撑点由改至@，扁担的两头就平衡了。山此．可以对树作．个向左逆时到“旋转"的操作，令结点为根，而结点的为它的左了，此时，结点0和@的平衡因了都为0．而目仍保持一叉排序树的特。在继续插人90和53之后，由于结点@的BF值由一I变成2，排序树中出现了新的不平衡的现象，需进行调整。但此时由于结点插在结点的人子树吓因此不能如丨作简单凋整：对丁以结点为根的子树来说，既要保持0叉排序树的特性，又要平．则必须以离作为根结点．使成图上悖平树的生成过程
(a)空树；（囝插丿0300插人20（山插人37；（向左逆时针右旋转平衡；
（0相继插人和53，（第次向右时针转Ah）第一次向左逆时针转平徜之
为岜的左子树的根，@成为它的右子树的根。这好比对树作了两次“旋转”操作一一先向右顺针，后向左谨时针（见图9口2山 0的，使一叉排序树由不平衡转化为平。
一般情况下，假没山于在二排序树上橘人结点而失去平衡的最小了树眼结点的指到为（即a是离人结点最近，且平衡因子绝对值超过]的祖先结点），则失去平衡后进行调整的规律可归纳为下列4种情况：
（0单向右旋平衢处理岫于在“的左子树根结点的左子树上插人结点，“的忄衡因了油1增至2，致使以“为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如图903〈a）所示。
（2） 单向左旋平衡处理：山．1在“的右了树根结点的右子树上插人结点“ a的平衡因子由一1变为一2，致使以“为根结点的子树失去平衡，则需进行一次向的逆时钅《旋转操作。如图9．13（的所示。
（3） 双向旋转（先左后右）平衡处理：由于在“的左子树根结点的右子树上插人结点, * a的平衡因子山I增牟2，致使以“为根结点的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。如图9．13（b）所示。
o ）双向旋转（先右后左）1／衡处理：山于在“的右了树根结点的左子树《庙人结点，“的平衡因子山一1变为一2，致使以“为根结点的了树失去平衡，则需进行两次旋转（先右旋后左旋）操作。如图9．1 3（d）所小。
上述4种情况中，0）和（2）对称，（3丿和（们对称。旋转操作的正确性容易由“保持一叉排序树的特：中序遍历所得关键字序列自小至人有序"证明之。同时，从图9．13可见，无论哪一神情况，在经过衡旋转处理之后，以0〕或c为根的新子树为平衡二叉
图903《又排序树的平衡旋转图例
o 凵00：00凵《型；（0型；（的RI，型
树，而且它的深度和插人之前以“为根的子树相同。因此，当平衡的二叉排序树因插人结点而失去平衡时，仅需对最小不平衡了树进行平銜旋转处理即可。因为经过旋转处理之后的了树深度和插人之前相同．因而不影响插人路上所有祖先结点的平衡度。
在平衡的二叉排序树BBS'P ]“插人一个新的数据丿素e的睇归算法可描述如下：
o ）若BBST为空树，则插人“个数据儿素为e的新结点作为BBST的根结点，树的
澤度增]；
（2） 若e的关键字和翮的根结点的关键字相等，则不进行插人；
（3） 若e的关键字小于HST的根结的关键字、而且在BEST的左子树中不存在和e有相同关键字的结点，则将e插人在BBST的左子树上，并且当插人之后的左子树深度增加0卜]）时，分别就下列不同情况处理之
0) BBS'I的根结点的平衡因子为一1（右子树的深度大于左子树的深度），则将根结
· ·
点的平衡因子更改为．的深度不变；
0 [下的根结点的平衡因子为重、右子树的深度相等则将根结点的平衡因子更改为1，BBS'F的深度增l .
囹BBST的根结点的平衡因了为以左了树的深度大于右了树的深度) ;若BBST的左子树根结点的平衡因子为1，则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右了树根结点的平徑因亻更改为0，树的深度不变；
若BBST的左子树裉点的平衡因子为一I，则需进行先向左、后向右的双向旋转平处理，并且在旋转处理之后，修改根结点和其左、右子树根结点的平衡因子，树的深度不变；
(4)若c的关腱字大于的根结点的关键字，而且在BBST的右子树中不存在和e有相同关透字的结点，则将e插人在BBST的右子树上，并且当插人之后的右子树深度增加（十1 )时，分别就不同情况处之。其处理操作和（三）中所述相对称，读者可自行补充。
假设在“ 6之3二叉树的存储结构"中定义的二叉表的结点中增加．个存储结点平衡因子的域，则i述在平衡的0叉排序树BBST上插人一个新的数据元素e的递归算法如算法9，I l所示、其中．左平衡处理的算法如算法9，12所示。算法9，9和算法9．10 分别描述了在平衡处理中进0右旋操作和左旋操作时修改指针的情况。右平衡处理的箅法和左斗衡处理的算法类似．读者可自己补充。
o跹排序树的类型定义为：
typedef REruct?BGTNode { F,lérnT data;struct BSTN?de )chlld?、左、右孩子指针(结点平衡因了)
} BSTNode，B?Tree，
void R Rotate（B驸白&?p）{
//对以p为根的1又排序树作右旋处理．处珥之后p指向新的树根结点，即旋转 处理之前的方0树的根结点P >Ichild 出lc “》、rchild;
Ic e>rchild P：P
》《7 R Rotate
指向的0》的左子树裉结点
，女1。的右子树挂接为p的左子树 p指向新的根结点
算法9，9
void〔Rotate（BSTree [的（
々对以0〕为根的一0《排学树们左旋处理．处呷之后指向新的树根结点，即旋转
，处理之前的右子树的根结点
re指向的p的右子树根结点
柘1 d； r亡的有子挂接为罢p的右子树
、1。hi尾 p指向新的根结点
}，丿0 Ro e
算法9，周 · 2 3 6 ·
define；田诗
:#def:ine 1山0 等高
#define闭]一] 少右高
InsertNJL (BSTree ElemT??rpe，0．翮口I r）{ 汐若在平衡的叉排序树1中不存在和e有相同关字的结点，则插人一个数据元素 e的新结点湖返回1，否则返回善若因插人而使一叉排序树失去平衡，则作平衡
？旋转处理，布尔变量taller反映'1长高与 if（！0 0/庙人新结点．'长高"，置t彐」彐誑
(BSTree) ma210c（sizeo H引卜od的）： 'data
T—.>lchlld -rchlld T EH; 1：al ler TRUE；
el { if (EQ(e key, at-a key)）树中己存在和e有相同关字的结点
{ № 1 r = FALSE$ return 0； 。则不再插人
-if (LT(e.key, T ->data. key)) { ／/应继续在瓦T的左子树中进行搜索
(!Jn$ectAVL ()—、>lchllcl, 0，tal ler)） return 0；//未插人
(taller) ／/已插丿、到坍T的左了树中且左子树“长高”
$"itch (T—>bf){ 万检查T的平衡度 case La： 下距车左了树比右了树高，需要作人平衡处理
LeftBal.ance（T栈球lerL$匡：break； caBe Fld. 原本左、右了树等高、现因左了树嘈高而仲树高
T 、bf LH；taller 苤TR〔〕break； cage REI： ，厚原本右子树比左子树高．现左满子树等高
T bft到（ =山S break》
} S"itch (T-> bf) 滂if else {应性在，的右了树中进行攫索
讦0 1n “了了航0 0'。了《j010， 0 0 t00 》return 0； ，0《插人〔（t引五，的 已人到' T'的右子树且右了树长高 5 ℃h（T 检脊，T'的平衡度 case LH:原左了树比右子树高，现左、右羊树等高
T ?bf EH； 匕0 L 1 er 下AL的 break
o鄄：原不左子树等高，现因右子树增高而使树增高
亡下刊，
/丿原本右子树比左了高要作右平处理
R ight:Bala.nce（T后
} switch 0'
》else
break；
、．bf匕； 上引〕er TRUE; break；
算法9，IL
VO LeftBa1anee（BSTree &.T、{ 对以指针T所指结点为根的一叉树竹骁半衡旋转处理，举算法结束时，指饣0、指向 //新的根结点 lc T一> ] 0 hi〕d： 0 le指向罴T的左了树根结点考检T的左子树的平衡度們相应甲衡处哩霪 新结卢插八在T的左孩子的左子树[．裴右旋处理
新结点插人在T的左孩子的右子树吓作双旋处理 rd觜向·的左孩子右了树根
· switch (rd 山0
〉5让ch（
:c d。冫蜃二EH；
L．Rotate（T一，oh到，
R Rotate（壕
}，/ switch〔le一
}下LeftBalance
／修改及其左孩子的平衡因了
是Ell; break： break：
LH；break；
刈、T的左于树作左旋平衡处理刈战T作布旋平衡处理算法9，12
5，平衡树查找的分析
在平衡树《进行查找的过稚和排序树相同，因此，在查找过程中和给定值进行比较的关键字个数不超过树的深度。那么，含有月个关踺字的平銜树的最大深度是多少呢？为解答这个问题，我们先分析深度为為的平衡树所具有最少结点数。
假设以表示深度为/，的平衡树中含有的最少结点数、显然，凿一0，NI一{，N'。
2．并且Nh一+．+ 1。这个关系和斐波那契序列极为相似。利用归纳法容易证
明：当》0时、= 一1，而0约等于0々其中： 1 + 5 ），则斗约等于 2
o 一0一。反之．含有个结点的平衡树的最大深度为1。（一l )）一2。因此，在平衡树上进行查找的时间复杂度为0（“）。
上述对二叉排序树和过叉平衡树的查找性能的讨论都是在等概率的前提．卜进行的，若查找概率不等，则类似于“ 9，静态树表的查找”中的讨论。为了提高杳找效率．需要对待查记录序列先进行排序．使其按关键字睇增（或递减）有序．然后再按算法9，1构造棵次优查找树。显然，次优查找树也是一棵二叉排序树，但次优查找树不能在查找过程中插人结点生成。二叉排序树（或称一叉查找树）是动态树表，最优或次优查找树是静态树表。
9．2．2树和树
1．&树及阻查找
B一树是．种平衡的多路查找树，它在文系统中很有用。在此先介绍这种树的结构及其查找算法。
一棵阶的13书，或为空树，或为满足卜列特性的m叉树：
o ）树中每个结点至多有棵了树，
（0若根结点不是叶子结点，则至少有两棵了树；
（3）除根之外的所有非终端结点少府‰《2子树；
（的所有的非终端结点中包含下列信息数据
实际上在汐树的每个结点中还应包含n个指向每个关键字的圮录的指钊。
· 2 3 8 ·
中：K, 0一|．，，，的为关键字，目K, <山0一 ．．，的为指向
子树根结点的指针，自指钅．t A, 1所指了树中所有结点的关键字均小于K，（0
所指子树中所有结的关键字均大于K。示‰ 0]一1 < “．一1）为关键字的个数（或扫为子树个数
（5〕所有的叶了结点都出现在同一层次上，并且不带信息（可以看作是外邗结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。
例如图9口4所示为一棵1阶的B一树，其深度为4。綫1 9.一裸阶的B-树
山一树的定义可知，在树上进行宵找的过程和二叉排序树的查找类似、例如，在图904的B。树上查找关字若的过程如下：首先从根开始，根据根结点指针t找到。，结点，因“结点中只有一个关键字．且给定值47 >关字35，则若存在必在指针A《所指的子树内，顺指到找到“结点．该结点有两个关键字（43和7围，43 < 4／< 78，则若存在必在指针Al所指的子树中。同样，顺指针找到结点，在该结点中顺序查找找到关钅建字47，由此，查找成功。查找不成功的过程也类似，例如在同一棵树中查找23、从根开始，因为23《35，则顺该结点中指针A、找到到〕结点，又因为到）结点中只有一个关键字吓，且23 > 18，所以顺结点中第二个指针AE找到e结点。同理因为23 < 27，则顺指钊往下找，此时因指钊所指为叶子结点，说明此棵B．树中不存在关啭字23，查找因失败而
由此可见，在B一树上进行查找的过秤是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程。
由于&树主要用作文件的索引，因此它的查找涉及外存的存取，在此略去外存的读写，只作示意性的描述。假设结点类型如一卜说明．# d《吡山3 typedef ru酰BTNOde { int keynu-lil struct RTNcxde parent； Kerrype key[m + lli struct RTNQde、ptrL m十]与
．/树的阶，暂设为3
结点中关键字个数．即结点的大小
／'指向双亲结点
7关键字向量，0号单丿L禾用
//子树指针向量
，
Record re身：0刂； } BTNOde，BTree； typedef struct.《 BTNOde
int t四；
} e Elti
记录指针向量，0号咩川未川年树结点和B．树的樊型
/指向找到的结
l ,，m，在结点中的关字序号
／/ I：查找成功．0：查找失败
&树的查找结果类型则算法9，13简要地描述了B一树的查找操作的实现
Resul t. ℃hBYcee（BTree 1，Key'Eype {
在阶树T上查找关键字K，返回结果（pt 0，tag)。若查找成功，则特征值tag ]，指钊pt
／丿所指结点中1个关啭字等了否则特征值t四= 0，等丁K的关飪字应插人在指到些所指
//结点中第和第0 1个关键字之间
p T；q= NULL：found= EALSE; i 0蕃 ／/初始化，p指向待查结点，q指向p的双亲 i (p && ffound) {
1 “ Search(). K) ; //在p ->key[ l . . ynu司中查找，
i使得：p ->keyl_-il-<- K<p ->key[ i +刂
0冫&．& p >?key[ i 0：和found= TRUE; //找到待查关腱字 else {、p；p = p 了“ 0的}
(tound) roturn (p, i. l )； ／7查找成功
e此0 return（午的； 汐查找不成功，返回卜的插人位置信息 }／/ SearchBTree
算法 9彐3
2．B一树查找分析
从算法901可见，在B-树上进行查找包含两种基本操作：0）在树中找结点；（2）在结点中找关键字。由于B树通常存储在磁盘f..，则前一查找操作是在磁盘上进行的（在算法9．11中没有体现），而后一查找操作是在内存中进行的，即在磁盘上找到指到 p所指结点后，先将结点中的信息读人内存．然后再利用顺序查找或折半查找查向等于K 的关键字。显然，在磁盘上进行一次查找比在内存中进行一次查找耗费时间多得多．因此，在磁盘上进行查找的次数、即待查关镶字所在结点在树上的层次数．是决定B一树查找效率的首要因素。
现考虑最坏的情况，即待查结点在B一树上的最大层次数。也就是，含N个关鍵字的 m阶B一树的最大深度是多少？
先看一棵3阶的B一树。按B．树的定义，3阶的B一树上所有非终端结点至多可有两个关键字，至少有一个关键字（即了树个数为2或3，故又称2一3树）。因此，若关键字个数
2时，树的深度为2（即叶子结点层次为2）；若关字个数飞6时，树的深度不超过3。反之，若B一树的深度为4，则关键字的个数必须冫7（参见图9．15（R)），此时，每个结点都含有可能的关键字的最小数目
一般情况的分析可类似一二叉平衡树进行，先时论深度为/ + 1的忉阶B一树所爬有的最少结点数
根据B树的定义，第一层至少有1个结点；第二层至少有2个结点；由于除根之外的 0 @
图吓不同关腱字数目的&树
（的空树；伟）N;l；（0 N一2；（山N、3；（N = 1；（0 N? 3 ;（的、，；过
每个非终端结点至少有‰ / 2]棵了树，则第三层至少有2 ( ) m / 20个结点广，，，。依次类推，第／+ ]层至少有2（‰ /种“个结点。而/ + 1层的结点为叶了结点。若阶B．树中具有N个关键字，则叶了结点即查找不成功的结点为N + 1岫此有： N4 ] 0 2 (Pm/21Y
反之
N ．| 1
《丨og‰湖 0一2 0 2
这就是说，在含有N个关键字的B．树上进行杳找时，从根结点到关键字所在结点的路径
N口
十涉及的结点数不超过g‰闸
2
3．启树的插人和删除
&树的生成也是从空树起，逐个插人关键字而得。但山丁B树结点中的关键字个数必须冫‰ /幻一1，因此，每次插人一个关键字不是在树中添加一个叶子结点，曲是凸先在最低层的某个非终端结点中添俪一个关腱字．若该结点的关键字个数不超过m 1．则插人完成，否则要产生结点的“分裂”，如图906所不。
例如，图9，1 6（a）所示为3阶的B-树（图中略去F结点〈即叶了结点）），假设需依次插人关腱字30，26，85和7。先通过查找确定应插人的位置。由根a起进行查找，确定 30应插人在d结点中，山于s d中关键字数目不超过2（即一0 ·故第一个关铈字人完成。插人30后的B一树如图9．16（b）所示。同，通过杳找确定关键字26亦应插人在要d结点中。由于d中关键字的数目超过厶此时需将d分裂成两个结点，关腱字26 及其前、后两个指针仍保留在要d结点中，而关键字乊及其前、后两个指针存储到新产生的结点d '屮。同时，将关键字30和指示结点d，的指针插人到其双兰结点中。山于
b结点中的关键字数目没有超过2，则插人完成。插人后的B一树如图9，] 6（d）所示。类似
．2 1 ]
地，在g中插人85之后需分裂成两个结点，血当继向插人到瑕亲结点时．由一于“中关键字数目超过2，则再次分裂为结点讨e和e '，如图9．16（@所示、最后在插人踺字，“ “ b和“，相继分．并生成一、个新的根结点又m，如图90 6陆） 。(j〕所小。(b)(c)(d)图．16在B一树中进行插人（省略'刂了结点）
．棵2 3树；（溘人30之后，（、（山插入26之后；
）插入之后；冫、（插^ 7之后 2 4 2 X 9. 1 6
? 243
一般情况下，结点可如下实现“分裂"。
假没0》结点中己有m一1个关键字，当插人一个关键字之后，结点中含有信息为：
且其中
此时可将谨p结点分裂为，p和苦射两个结点，其中p结点中含有信息为
（9一2 2〕
p '结点中有信息
（9一23）而关字下：“和指饣0下一起插人到? p的双亲结点中。
在B．树上插入关键字的过程如算法9，11所示，其中q和i是由查找函数SearchB
0“返回的信息而得。
Insert-Effree (Enree &.T, KeyType卜，grree q. int i）{
//在m阶树T上结点苦q的keyu-.% ke虬0之间插人关字
是若引起结点过大，则沿双亲进行必要的结点分裂调，使T仍是邙阶树，
卜；= NULLI finished；；FALSE;
While (q & ffinished) {
Insert()? .i. x.丿； 亻/将*和ap分别插人到q->key「0和q >??ptcr.i+刂 if (q-->keynun < finished苤T即 擂人完成 else { 分裂结点 s =「．2 split().出(p): x = q -
／% q ->key「s ' 1一m」，q ->ptrl g, . rnl和q 一> recptr [ s + 0到移人新结点ap ' p r沣；
i Search(士x); 在双亲结点到中查找%的插人位置《．else while
if @ f这朽0山 在T是空树（参数q初值为NULL)或者根结点已分裂为结点和呷
Newk00t()' q.孙aph ／/生成含信息（T，x．ap）的新的根结点T，原T和为子树指针 ret OK；
汐InBertBTree
算法9，
反之，若在B一树上删除．个关字．则首先应找到该关键字所在结点，并从中删除之．若该结点为最下层的非终端结点，且其中的关键字数目不少于‰ / 2 ]，则删除完成，否则要进行“合并”结点的操作。假若所删关键字为非终端结点中的K，，则可以指针Ai所指了树中的最小关键字Y替代K，，然后在相应的结点中去Y。例如，在图美16 @的 B-树上删去．可以0结巛中的50替代4 5，然后在0结点中删去50。因此，下面我们可以只需时论删除最下层非终端结点中的关键字的情形。有下列3种可能：
（1） 被删关键字所在结点中的关腱字数目不小于‰／0则只从该结点中删去该关腱字K，和柞应指针A，树的其他部分不变．例如，从图9．16（所示B“树中删去关键字 1 2，删除后的B树如图90 7（a)所小
（2） 被删关键字所在结柢中的关键字数目等于「艹' 2 ]一1，而与该结点相邻的右兄弟（或左兄弟）结中的关键'了数目大于‰明一吓则需将其兄弟结点中的最小（或最(a)(b)(d)
图9. 0在树中删除字的情形
人〕的美字上移至双亲结点中，而将双亲结点中小于（或人于）目紧靠该上移关腱字的关鍵字卜移至被删关键字所在结点中。1列如，从图9．] 7（a）中删去50，需将其右兄弟结点中的61上移至“结点中，而将-点中的53移至凵，从而使以和中关键字数目均不小于‰ / 2．1一]，而双亲结点中的飞讲字数目不变，如图9．17（b）所示。
．
（3） 被删关键字所在结点和其相邻的兄弟结点中的关字数目均等于「m / 2]一]假设该结点有右兄弟，就其右兄弟结点地址由双亲结点中的指针A，所指，则在删去关辩字之后，它所在结点中剩余的关键字和指针，加十双亲结点中的关镶字K，一起，合并到A，所指兄弟结点中（若没有右兄弟，则合并至左兄弟结点中）。例如，从图9．1 7（0所示 B-?j中删去，则应删去凵结点，并将凵中的剿余信息（指针“空"）和双亲〔结点中的6 [一起合并到右兄弟结点中。删除后的树如图g、17（的所小。如果因此使双亲结点中的关键字数目小了‰ / 2 ]一1．则依次类推作相应处理。例如，在图9．] 7（）的B一树中删去关键字37之后，双亲b结点中剩余信息（“指针c应和其双亲善a经i点中关锭字15 一起合并至右兄弟结点“．·中，删除后的树如图9，0（山所示。
在B．树中删除结点的算法在此不再洋述，请读者参阅参考书目「0后自己写出． d. B《树
B，树是应文件系统所需而出的一种B一树的变型树〔D。一棵m阶的树和m阶的
B，树的差异在丁，
( 1 )有棵子树的结点中含有个关键字。
（2） 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指钊，且叶子结点本身依关键字的大小自小而大顺序接。
（3） 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。
例如图9，18所示为一棵3阶的B十树，通常在B十树上有两个头指针，一个指向根结点，另一个指向关鍵字最小的叶子结点。因此，可以对B '树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找。 在@树上进行随机查找、插人和删除的过程基本上与B．树类似、只是在查找囿，若非终端结点上的关键字等于给定值，并不终止，面是继续向下直到叶子结点。因此，在望树，不管查找成功与否、每次查找都是走了、条从根到叶了结点的路径。B E树查找的分析类似于B一树。H树的插人仅在叶了结点上进行，当结点中的关键字个数大于m时要分裂成两个结点，它们所含关键字的个数分别为「一+ ．一1 ]和「一m + 一1目并且，它们的双亲结
点中应同时包含这两个结点中的最大关键字。B +树的删除也仅在叶羊结点进，当明子结点中的最大关字被删除时，其在非终端结点中的值可以作为一个“分界关键字"存在若因删除而使结点中关踺字的个数少于「：．]时，其和兄弟结点的合并过程亦和．树 《严说来，它己1、印六章中定跹的树了 2 1 6
9，2，3键树
键树又称数字查浅树山i@岫吓e “ 'Trees)6它是棵度产2的树．中的匈个结点中不是包含．个或几个关键字．而是只含有组成关键字的符号。例如，若关键字是数佰，则结中只包含一个数位寺若关字是单i司，则结点中只包含一个字母字符。这种树会给某种类型关腱字的表的查找带来方便。
假设有如卜《6个关踺字的集合
{CAI、CAC)、凵、LAN、CHA、('HANG、WEN、CHAU)、YUN、YANG、以〕NG、 WANG、ZHAO、LIU、WU、CHEN' （9一20 可对此集合作如下的逐层分割。
首先按其首字符不同它们分成。个了集：
{ CAI,CA()、CHA、CHANG、CilA()、CHEN}. {WEN、WANG、W(J ' ' {ZHAO: ? {凵、上AN、上()N（；、凵U，0'YUN,YANG} ,
然后对其中4个关键字个数大于1的子集再按其第二个字符不同进行分割。若所得子集的关键字多于1个，则还需按其第一《'i、字符不同进行再分割。依此类推，直至每个小子集中只包含一个关字为止。例如对首字符为0的集合可进行如下的分割，显然，如此集合、子集和元素之间的层次关系可以用一棵树来表小，这棵树便为树：例如，上述集合及其分割国用图9．19所示的键树来表示。树中根结点的五棵子树分别表示图909表示式0 2的关鍵字集的一棵键树
首字符为、w、Y和z的5个关谊字了集。从根到叶了结点路径中结点的字符组成的字符串表小一个关键字，明子结点中的特殊符号$表示字符串的结束。在叶子结点还含有指向该关键字记录的指针。
为了查找和插人方便，我们约定键树是有序树．即同一层中兄弟结点之间依所含号自左至右有序，并约宁结束符$小于任何字符。通常，键棚可亻两种存1诸绿构
山以树的孩了兄弟餷表来表小谊树则旬个分支结点包括3个域：寸m域：存储关诽字的个字饲吓t域存储指向第棵子树根的指针；“对域；存储指向右足弟的指针同时，了结点的Infoptr域有储指向该：（腱字记录的指。此旧的键树称双链树。例如，图9．] 9所示腱树的双鲢树如图 9．湖所示（图中只画出第一裸子树，其余部分省略）“
双链树的查找可如下进0：假没给定为K, ch((). . num到），其中K.山@．1至K. ch Lnum的表示待查关键字中num〕个字
图20双链树示例
符，K，重一“ m一0为结束符从双树的
根指针出发，墜指针找到第一棵了树的根结点，以K.山@j和此结点的symbol域比较，若相等，则顺6～域再比较下．字符，否则沿next域顺序查找、若直至“ 0 ”仍比较小等．则查找不成功
如果对双皚树采用以卜存儲表示
# define X豇 ， 睏 关鍵字的最大长度
Lypedef struct {
char chi!：巛E、TEN ，00忄字
，/建字长也它关祧家型
《7结点种炙0叫了、分支《
char $ № 1；
*Cruet DLTNode 指向兄弟结点的指到
Nod 1的(i kind; union（
Record钅rlfoptr； ，、00了结点的记录指镒
“ DI,TNode fit-st ; ·分支结点的孩子指钅》
} DLTNode．可，Tree; 》双皚树的类型则在双鲢树中查找记录的操作由算法9，巧实现
Record SearchDLTree（DLTtCQ T，Keyst9pe {
汐在非空双树T中查找关腱字等于的记录，若看在，则返回指向该记录的指到，否则返回
一．氈；杏找关的第位
?First： 准备查找下．位
· 8 · “查找结 if (!p)then return NULL e〕age 0蹿正0
}氵g@自e.h D鬥．№
找不成功 @成叻
算法9，巧 键中个结点的最大度（／和关键宁的“基”有关，若关谜字是单词，则一．若关字是数值，则d一凵“鍵树的深度六则取决」键字中字符或数位的个数。假设关
字为随机的（即关键字中每一位取草内仃何值的概率相同不则在双鲢树中查找每一位的平均查找长度为0十的。又假没关键字中字符（或数位）的个数都相等，则在双浒树中
进行查找的平均查找长度为；口的。
在双链树中插人或删除一个关键字，相当于在树中某个结点上插人或删除一樨了树，在此不再i羊述。
（2）若以树的多重表表小世树，则树的每个结点中应含有个指针域，此时的键码又称0对丛若从鍵中某个结点到叶了结点的路径上每个结点都只有一个孩子、贝刂可将该路上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记鼠的指针等信息。例如，图909所示键树中，从结点z到结点$为单支树，则在图9，2 ] 相应的“树中只有一个含有关键字ZHAO及相关亻訁息的叶子结点。由此，在Trie树中有两种结点：分支结点（含有（／个指到域和一个指示该结点中非空指针域的个数的整数域）和叶了结点（含有关键字域和指向i己录的指针域）。在分支结点中不没数据域．每个分支结点所表示的字符均山其双亲结点中（指向该结点）的指针所在位置决定。
$ A B C D F G H 1 J K L M N 0 p Q R S T U V WX Y Z图9、表示00的关字集的树（深度一的
在「rte树E进行查找的过程为：从根结点出发．沿和给定值相应的指钅丨逐层向下，门．半叶子结点，若叶子结点屮的关腱字和给定值相享，则查找成功．若分支结点中和给定值1小这个词是从“ “：索中取中间四个字符而构成，同00冫
相峋的指针为窄，或叶结惹中的々腱字和给定的不相等．则查找不成功。若没
typedef 9trvct T 0 0N000 {
Nod国《冒〕0自； union {
Struct (?fe\'$Type 叶子经《气 struct分支结点
}TrJeBode，TrieTree;澀树类型则键树查找操作可如算法9，] 6实现之。
Record ' EearchT?ie，1；00T下）：
/／在树T中查找关字等T丛的记录
for（p = T. i 々对5的每个字符逐个查找
，ki 0 =BRB?℃H & &新、 彦唧为分支结点
?bh.ptrlOLd(K,ch( 夕。求字符在字母表中序另
（卩& &卩一kLnU==LEAE && p 下return p &If. infopt：0 查找成功
else return NiJLL： 查找小成功 }汐
箅法9」6
从上述查找过程可见，在查找成功时走了一条从根到叶子结点的路径。例如，在图 9．2，上，查找关键字0 ] EN的过程为：从根结点。出发，经卩、）'结点，最后到达明了结点 而查找CHA!的过冒为从裉结点。出发，经卩0结点后到结点．。由于．该结点中和字符' ]，相应的指针为空，则查找，1、成功。山此，其查找的时间依赖．于树的深度。我们可以对关字集选择一种合适的分割．以缩减'Erie树的深度。例如，根（9一2们中关键字的特点，可作加．下分割。先按首了不同分成多个了集之后，然后按最后一个字符不同分割个子集，再按節二个字符．， ．．前后交叉分割。山此得到如图9．22所示的[树，在该树0除两个叶了结点在第四层匕外，其余唄了结点均在第三层上。还可限制
C L WX Y Z 时的．24〕字集采用另．．种分割法得到的'F小树（深度：们
0．7转换成该字眷字母表中序勺．并假谡字符的宁号为零。树的深度，假设允许Tric树的最大深度为丛则所有直至／一]层皆为同义词的关键字都进人同叶子结点。若分割得合适，则可使每个叶子结点中只含有少数几个同义词。当然也可增加分支的个数以减少树的深度
在Trie树上易于进行插人和删除，只是需要相应地增加和删除一些分支结点。当分支结中num域的值减为]时，便可被删除
双链树和]树是键树的两种不同的表小方法，它们确各自的特点。从其不同的存储结构特性可见，若键树中结点的度较大，则采用Trie树结构较双鲢树更为合适。
综上对树表的时论可见，它们的查找过程都是从根结点出发，走了一条从根到叶子（或非终端结点）的路径，其查找时间依赖于树的深度。山于树表主要用作文付索引，因此结点的存取还涉及外部存储没备的特性，故在此没有对它们作平均查找长度的分析
9，3哈希表
9．3．1什么是哈希表
在前面讨论的各种结构（线性表、树等）中，记录在结构中的相对位置是随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较”的基础0在顺序查找时，比较的结果为“ ”与才”两种可能；在折半查找、二叉排序树查找和B·树查找时，比较的结果为' <、
>，3种可能。查找的效率依赖于查找过程中所进行的比较次数。
理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系不使每个关键字和结构中一个惟一的存储位置相对应。因而在查找时，只要根据这个对应关系了找到给定值K的像不K）。若结构中存在关键字和K相等的记录，则必定在f( K）的存储位置上，由此，不需要进行比较便可直接取得所查记录。在此．我们称这个对应关系丿．为哈希（Hash）函数，按这个思想建立的表为哈希表。
我们可以举一个哈希表的最简单的例子。假设要建立一张全国30个地区的各民族人凵统计表，每个地区为一个记录，记录的各数据项为：
地区名
总人口
汉族
回族
显然，可以用一个一维数组C（0 3的来存放这张表．其中CCil是编号为下的地区的人口情况。编号便为记录的关键字，由它惟一确定记录的存储位置CO]。例如：假设北京市的编号为1，则若要查看北原市的各民族人口，只要取出CLI」的记录即可。假如把这个数组看成是哈希表，则哈希数不艟@一差0。然而，很多情况下的哈希数并不如此間单。可仍以此为例，为了杳看方便应以地区名作为关键字。假设地区名以汉语拼音的字符表示，则不能简单地取哈希函数／0）一而是首先要将它们转化为数字．有时还要作些简单的处理。例如我们可以有这样的哈希丞数．（l)取关键字中第一个字母在'宁母表中的序号作为哈希甬数。例如：BEIJ丨NG的哈希函数值为字母“ B "在字母表中的序号．等于02；或（20L求关键字的第·个和最后一个字母在字母表中的序号之和，然后判别这个和值．若比30（表长）大．则减去30例如：口乁NJIN的首尾两个字母“ T ”和“ N ”的序号之和为3 1．故取@为它的哈希函数值；或（3）先求每个汉字的第一个拼字母的ASCII 码（和英文字母相同）之和的八进制形式，然后将这个八进制数看成是进制数除以30 取余数，若余数为零则加上30而为哈希哂数值。例如：HE-NAN的头两个拼字母为 “ H ”和“ N，'，它们的ASCII码之和为瞟26后以（226除以〈30得余数为1 6，则1 6为 HEt丶AN的哈希函数值，即记录在数组中的下标值。E述人口统计表中部分关键字在这
3种不同的哈希甬数情况卜的哈希函数值如表9．]所列：从这个例了可见：
( l )哈希函数是一个映像，因此哈希函数的设定很灵活六只要使得任何关键字由此所得的哈希函数值都落在表长允许范围之内即可，
（2）对不同的关键字可能得到同一哈希地址，即扒，回者02，而/。（差0L0：．／002）、这种现象称冲突（“山*；0的。具有相同函数值的关字对该哈希函数来说称做同义词 (synonym)。例如：关腱字HEBEI和HEN AN不等，但fl ( HEBEI)一（HENAN)，又如：在（S日ANXI)：[2(SHANGHAI);／、3(HENAN)=%(SICHUAN)O这种现象给建表造成困难，如在第一种哈希函数的情况下，因为山西、上海、山东和四川这4个记录的哈希地址均为四．而C09〕只能存放一个记录，那么其他3个记录存放在表中什么位置呢？并且，从上表3个不同的哈希函数的情况可以看出，哈希函数选得合适可以减少这种冲突现象。特别是在这个例了中：只可能有30个记录，可以仔细分析这30个关键字的特性，选择一个恰当的哈希数来免冲突的发生。
然而，在一般情况下、冲突只能尽可能地少，而不能完全贈免。因为，哈希孓数是从关键字集合到地最集合的映像。通常，关键字集合比较大，它的元素包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。假设表长为则地址为0到”一1。例如，在c语言的编译程序中可对源程序中的标识符建立一张哈希表。在设定哈希数时考虑的关键字集合应包含所有可能产生的关键字；假设标识符定义为以字母为首的8位字母或数字，则关键字（标识符）的集合大小为“ 0“ 7！ = 1．09388又10。，佃在一个源程序中出现的标识符是有限的，设表长为10的足矣。地址集合中的元素为0到999。
因此，在．般情况下，哈希函数是一个压缩映像．这就不可免产生冲突因此，在建造哈H “巛哈希）的原0是杂凑
希表时不仅要设定。个“好"的哈希函数，而[4要i殳定一种处理冲突的方法：
综上所述，可如忄描述哈希表：根据设定的哈希函数H以“）和处理冲突的方法将组关踺字映像到．个有限的续的地蚓集（区间）上，并以关键字在地集中的“像"竹为记录在表中的存储位置，这种表便称为哈希表，这、映像过程称为哈希造表或散列．所得存储位置称哈希地址或散列地址下曲分别就哈希函数和处理冲突的方法进行i寸论。
9．3，2哈希函数的构造方法
构造哈希函数的方法很多。在介绍各种方法之前，首先需要明确什么是“好”的哈希函数。
若对于关腱字集合中的任一个关键字，经哈希函数映像到地址集合中任何一个地址的率是相等的，则称此类哈希数为均匀的（Unif。rm）哈希函数。换句话说，就是使关鍵字经过哈希函数得到．个“随机的地址”，以便使一组关键字的哈希地址均匀分布在整个地址区间中，从而减少冲突。
常用的构造哈希函数的力法有：
1，直接定址法
取关键字或关键字的某个线性函数值为哈希地址。即：
H以0）：：对或H(key) =a ·在0 +舀中自和5为常数（这种哈希函数叫做自身函数
例如：有一个从1岁到i00岁的人0数字统计表，其中，龄作为关键字，哈希函数取关踺字自身。如表9过所示，
表9．2直接定址哈希函数例之一
地卅年龄
2 7 0
这样，若要询问25岁的人有多少，则只要查表的第25项即可。
又如！有一个解放后出生的人囗调查表，关字是年份，哈希函数取关键字加一常数． H 0）一0 +（一1948），如表9，3所示
表9．3直接定进哈希数例之二
2 2
亻分
49
． ·
这样，若要查[ 9在年出生的人数，则只要查第（1970一1948）一豐项即可。
山十直接定址所得地址集合和关字集合的大小相同。因此，对于不同的关钟字不会发生冲突。但实际中能使用这种哈希函数的情况很少。
2．数字分析法
假设关键字是以r为基的数（如：以10为基的十进制数) ,并且哈希表中可能出现的关键字都是事先知道的，则可取关鍵字的若十数位组成哈希地址。
例如有80个记录，其关键字为8位十进制数。假设哈希表的表长为蜘‰，则可取两十进制数组成哈希地址。取哪两位？原则是使得到的哈希地址尽量避免产生冲突，则需从分析这80个关诽字着手。假设这80个关诽字中的一部分如下所列：山0 0 @ 0 @的
对关鍵字全体的分析中我们发现：第山位都是“ 8尸，第囹位只可能取1，2、3或4，第的位只可能取2、5或7，因此这，1位都不可取。由于中间的4位可看成是近乎机的，因此可取其中任意两位，或取其中两位与另外两位的叠加求和后舍去进位作为哈希地址
3，平方取中法
取关键字平方后的中间几位为哈希地址。这是一种较常用的构造哈希函数的方法。
讪常在选定哈希函数时不一能知道关字的全部情况，取其中哪几位也不一宁合适，而个数平方后的中间几位数和数的每一位都相关，由此使机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
例如：为BAS ℃源程序中的标只符建立一个哈希表。假设BAS℃语言中允许的标识符为“个字母，或一个字母和一个数字。在计算机内可用两位八进制数表示字母和数字，如图9．23（的所示。取标识符在计算机中的八进制数为它的关字。假设表长为 5 ] 2：2刂，则可取关鍵字平方后的中间9位二进制数为哈希地址例如，图9．23〈b）列出了一些标识符及它们的哈希地址、
4．折叠法
将关键字分割成位数相同的几部分（最后一部分的位数可以不同）．然后取这几部分的叠加和（舍去进位丿作为哈希地址．这方法称为折叠法( f引din的。关键字位数很多，而且
．关键字中每一位上数字分布人致均匀时，可以采用折叠法得到哈希地址。
60 Gl
记录
关键了
（关2
哈希地址（21
A
0 ] 00
1100
] 200
1 ]前 2 061
2062
216 ]
？] 6 2
216 3
0 m0000
] 2 ] 0000
] 440000 ] 3 / 0400 感3 ] 0 5 4 1 4 314 7
4 73智
4 7到304 4 74 5 6到
田0 2跹啊0
370
74 ]
745
图9．23
）字符的八进制表示对照表；(b)标识符及其哈希地址
例如：每一种西文图书都有一个国际标准图书编号(ISBN），它是一个10位的十进制数字，若要以它作关键字建立一个哈希表，当馆藏书种类不到10 0佣时，可采用折叠法构造一个四位数的哈希函数。在折叠法中数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。如国际标准图书编号0一2一20586一4的哈希地址分别如图9．2 4（a）和（b）所示。
5861 5864
4220 0224
04 04 1 88 6092 H 0）88 H 0）6092
图9．24由折叠法求得哈希地址
（位叠加；(b)间界疊加
5， 除留余数法
取关鍵字被某个不大于哈希表表长的数声除后所得余数为哈希地址。即
n 0）差0 MOD外户辶m
这是一种最简单、也最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（MOD），也可在折叠平方取中等运算之后取模
值得注意的是，在使用除留余数法时，对P的选择很重要。若选的不好，容易产生同义词。请看卜面3个例子。
眼设取标识符在计算机屮的二进制表示为它的关键字（标识符中每个字母均用两位
· ·
八进制数表示然后对／丿一2《取模。这个运算在计算机中只要移位便可实现，将关字左移在至只留卜最低的6位二进制数。这等于将关键字的所有高位值都忽略不计。因而使得所有最后一个字符相同的标识符，如al山、mpl，叩]等均成为同义词
若丿丿含有质因子p 0则所有含有因子的关键字的哈希地址均为埒的倍数例如，当p一2 1（一3 × 7）时，下列含因子7的关键字对2 1取模的哈希地址均为7的倍数。
总字 2 8 6 3 7 7
哈希地址 7 凵 0 11 0
假设有两个标识符xy和yx，其中x、y均为字符，又假设它们的机器代码（6位二进制数）分别为r）和c《y），则上述两个标识符的关键字分别为
一2龙（到十ccy)和々0y2
假设用除留余数法求哈希地址，且丿-，/是某个常数，q是某个质数。则当q一3时，这两个关漣字将被散列在差为3的地址上。因为
《月以0y0一H 020 MOL) q = {〔2 0》+（．0》MOD一[十0的M()D MOD q
= 2％（到M()D户卜巛词?MOD “ 2 ‰（，）MC-)D虍一（0）MOD MOD q
：{ 2 ‰ 0）M()D十MOD一2％（MOD MOD MOD q （因对任一x有0，MOD 0的）MOD q=(x ?MOD的MOD q)
当q一3时，上式为
一巨矛MOD 3斤0的MOD 3 + MOD 3一（2 “ MOD 3）以MOD 3一r00 MOD 3 } MOD 3 = 0 MOD 3
．
由众人的经验得知：一般情况卜，可以选虍为质数或不包含小于20的质因素的合数。 6．随机数法
选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 random （雇y），其中random为随机函数。通常，当关键字长度不等时采用此法构造哈希函数较恰当。
实际工作中需视不同的情况采用不同的哈希数。通常，考虑的因素有：计算哈希函数所需时间（包括硬件指令的因素
（2）关键字的长度；
(3)哈希表的人小；
（4） 关键字的分布情况，
（5） 记录的查找频率
9．3．3处理冲突的方法
在“ 9，3，1亻《么是哈希表"中曾提及均匀的哈希函数可以减少冲突，但不能遴免，因 · 256 ·
此，如何处理冲突是哈希造表，卜可缺少的另一方面。
假没哈希表的地址集为0一0冖0，冲突是指山关字得到的哈希地址为丿（〔0`》一l )的位置上已存记录．则“处理冲突"就是为该关漣字的记录找到另个的哈希地址。在处理冲矢的过程中可能得到一个地量序列
（H,e一1 0。即在处理哈希地址的冲突时，若得到的另一个哈希地址HI仍然发生冲突，则再求下一个地址地，若地仍然冲突，再求得HBO依次类推，直至不发生冲突为止，则H《为记录在表中的地址。
通常用的处理冲突的方法有下列几种． l.丌放定缸法
HI（H 0）十(,) MOD m 2 （9理5）其中：H以0）为哈希函数“`为哈希表表长；为增量序列，可下列3种取法：
．，，m一]，称线性探测再散列这2）d产0
“ 2）称二次探测再散列；（3）苤一伪随机数序列，称伪随机探测再散列。
例如，在长度为扫的哈希表中已填。自关键字分别为17，60，29的记录（哈希函数以0）一0 (C)「凵0，现有第四个记录，其关讲字为38，山哈希吆数得到哈希地址为 5，产生冲突。若用线性探测再散列的方法处理时，得到下一个地址6，仍冲突；再求下一个地址7，仍冲突；直到哈希地址为8的位置为“空”时止，处理冲突的过程结束，记录填人哈希表中序号为8的位置。若用二次探测再散列，则应该填人序号为4的位置。类似地可得到伪师机冉散列的地址《参图90的
] 7
29
60
] 7
29
38
38 @
29
3 8
1 7
29
图9，25用开放定理冲突时，关键字为38的记录插人前后的哈希表
（的插人的：（b）线性悚测冉列山0一次探测再散列这d）伪随机慊测再散列，伪随机数列9疒
从上述线性探测再散列的过程中可以看到一个现象；当表中i，i + 1 + 2位置上已填有记录时，下一个哈希地址为0、到+ 2和下+ 3的记录都将填人i + 3的位置，这种在处理冲突过程中发生的两个第一个哈希地址不同的记录争夺同个后继哈希地址的现象称做．二次聚集'，即在处理同义词的冲突过程中又添加了非同义词的冲突，显然，这种现象对查找不利。但另一方面，用线性探测再散列处理冲突可以保证做到：只要哈希表末填满，总能找到一个不发生冲突的地址H “而二次探测冉散列只有在哈希表长m为形如4到一30为整数）的素数时才可能六随机探测再散列，则取决于伪随机数列：
2、再哈希法
R14,(key) （9 26） R H,均是小同的哈希数，即在同义词产生地址冲突时到算另一个哈希数地址直到冲突不再发生。这种方法不易产生“聚集”，但增加了计箅的时间。
3，链地址法
将所有关腱字为同义词的记录存储在同线性链表中。假设某哈希函数产生的哈希地址在区间「0，忉一0上，则设立一个指针型向量
Chain ChainHasti[tnl；
其每个分量的初始状态都是空指针。凡哈希地址为i的记录都插人到头指针为 ChamHashCiJ的琏表中。在链表中的插人位置可以在表头或表屁；也可以在中间，以保持同义词在同一线性链表中按关键字有序：
例9．3已知一组关键字为（1 9，1缕，23，01，68，20，84，27，55，」1，10，79）
则按哈希函数H以(y)一0 MOD 13和谴地址法处理冲突构造所得的哈希表如图9．26 所示。
7
（同一衣中关键字自小至大亻序）
匚建立一个公共溢出区
这也是处理冲突的一种力法。假设哈希函数的值域为内，m一0，则设向量 HasbTableL0. . m一I」为基本表，每个分量存放一个记录，另设立向量
为溢出表。所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么．一旦发生冲突，都填人溢出表。
2 5 8
9．3．4哈希表的查找及其分析
在哈希表上进行查找的过程和哈希造表的过程基本一致。给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置没有记录．则杳找不成功；否则比较关键字，若和给定值相等，则查找成功，否则根据造表时设定的处理冲突的方法找“地址"，直至哈希表中某个位置为“空”或者表中所填记录的关键字等于给定值时为J].
算法9，17为以开放定等方法（除彘地址法外）处理冲突的哈希表的查找过程。
一开放定址哈希表的在储结构
int ba,$hsize 的9 9 7， //哈希表容量递增表，一个合适的素数序列 typedef struct. {
ElemType elema 数据元素存储基址．动态分配数组 int count； ，7当前数据元素个数
int S teindex； // h“ hs e [ “ tnde幻为当前容量 } HashTa.b1e；
#define SUCCESS〕
#define斟℃CESS 0
# define DUPLICATE
Status SearchHagh (HashTab1e出Ke、'Type K. int &p, int (c) {
在丌放定川哈希表H中查找关码为K的元素，若查找成功，以p指示待查数据元在表中位詈，并返回辍℃c s；否则，以p指示人位置，并返回UN引'CC $，
。用以计冲突次数，其初值置零．供建表插人时参考卩 Hash(K)： 求得哈希地址
Rhi1e( ).国en忄的、y！=間陆K“ & &该位置中填有记录并且关诞字不相等
00H Sion（吓+．》．0后 声求得下一探查地址p
if E00，H. elem[pl.key)
return SUCCESSI //查找成功，p返回待查数据元素位置
010e return〔〕NStJCCES$ 查找不成功（H．elemCpI, key =生，
p返回的是插人位置 }矛Sea在厘09h
算法9 17
算法9．] 8诵过调用查找算法（算法(7)实现了开放定址哈希表的插人操作。
IfisertHash (ElashTable &H? El巧1）e e) {
//查找不成功时插人数据元素e到开放定址哈希表H中，并返回酥；若冲突次数
／/过大，则雨肄哈希表
辽（Search-Hash（H，e,key. p. 0））
return以甲LICAT 表中已有与e有相同关键字的元素
01U0 if（0 0 izetH.：；“ 0山韦2）{ 冲突次数。未达到上限，（的阀值可调）
H. elem!_pl e；．0卜Fl.CO'川上；0： 、/插人e
else {RecreateHashTable(H)
}彦InsertHaSh
算法908 例9一4已知例的3中所不的一组关键字按哈希函数H以0） = key .M()I) 0和线性探测处
1 2 [ 3 ] 1
2，
图9，27哈希表a.elcm10；巧
（其哈希数为仫々“垤渌0 MQI) ] 3，处理冲突为线性探洳冉散歹归
给定值K一8，1的查找过程为岫先求得哈希地址H（84）一6，因a. elemt到不空且山“@．〕．k《y才81，则找第一次冲突处理后的地址]一（6十0 M(〕D ] 6 “ 7，而a. elem 「们不空目&国em [ 7]. key 8私则找第二次冲突处理后的地號H2：（6 + 2）MOD 16— 8，a，m [ 8 ]不空且a．elem「时k ” 84，则查找成功，返回记录在表中序号8。
给定值K = 38的查找过程为：先求哈希地址H（38）地2，a，e1em[12'．不空且a.elem 02」，key乒38，则找下一地址Hi一( )2十，）MOD还一13，由于a，elemC13]是空记录，则表明表中不存在关键字等于38的记录。
从哈希表的查找过程可见：
（0虽然哈希表在关键字与记录的存储位置之间建立了直接映像，但山于“冲突”的产生，使得哈希表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量哈希表的查找效率的量度。
（2）查找过程中需和给定值进行比较的关键字的个数取决于下列三个因素：哈希函数，处理冲突的方法和哈希表的装填因子。
哈希函数的“好坏”首先影响出现冲突的频繁程度“但是，对于“均匀的”哈希函数可以假定：不同的哈希函数对同一组机的关字，产生冲突的可能性相同，因为一般情况卜i殳定的哈希数是均匀的．则可不考虑它对平均查找长度的影响“
对同样一组关键字，设定相同的哈希函数，则不同的处理冲突的方法得到的哈希表不司，它们的平均查找长度也不同。如例9．3和例9．4中的两个哈希表，在记录的查找概率相等的前提下，前者（矫地址法）的平均查找长度为
ASL 0 2》 一口．6 + 2 4 + 3 +的
1 2
后者（线性探测再散列）的平均查找长度为
ASL 02） 一（1．6 + 2 + 3，3 + 4 + 9）= 2．5
容易看出，线性探测再散列在处理冲突的过程中易产生记录的二次聚集，如既使得哈希地址不相同的记录又产生新的冲突；而憐地址法处理冲突不会发生类似情况，因为哈希地址不同的记录在不同的表中。
在一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子。
哈希表的装填因子定义为
表中填人的讠i!蕈哈希表的长度 2 6 0 “标志哈希表的装满程度。直观地看諏越小．发生冲突的可能忭就越小；反之“越大，表中已填人的记录越多，再填记录时，发生冲突的可能性就大，则查找时，给定值需与之进行比较的关鍵字的个数也就越多：可以证明．的
线性探测散列的哈希表查找成功时的平均查找长度为
（9。2 7）随机探测再散列、二次探测再散列和冉哈希的哈希表查找成功时的平均查找长度为一丨n(l一的 （9 28）
链地址法处理冲突的哈希表查找成功时的平均查找长度为
.Snc I +一 （9．2的由于哈希表在查找不成功时所用比较次数也和给定值有关，则可类似地定义哈希表在查找不成功时的平均查找长度为：查找不成功时需和给定值进行比较的关键字个数的期望值。同样可证明，不同的处理冲突方法构成的哈希表查找不成功时的平均查找长度分别为
（9．30）
一线性探测再散列
0一30
一伪随机探测再散列等
（的3 2）
一链地址下而仅以随机探测的，组公式为例进行分析推导。
先分析长度为m的哈希表中装填有个记录时查找不成功的平均查找长度。这个问题相当于要求在这张表中填人第“ + 1个记录时所需作的比较次数的期望值。
假定！（的哈希数是均匀的。即产生表中各个地址的概率相等；（2）处理冲突后产生的地址也是随机的。
若没扒表示前个哈希地址均发生冲突的概率@表示需进行次比较才找到一个
“空位"的哈希地（即前冖1次发生冲突，第次不冲突）的概率。则府：一碧0 1
可见，在纨和之间，存在关系式
（9一3 3）
由此，当长度为碉的哈希表中已填有”个记录时，查找不成功的平均查找长度为
o，一〉)q，0：．习0丿凵一月m丑1
由于哈希表中月个记录是先后填人的，查找每一个记录所需比较次数的期望值，恰为填人此记录时找到此哈希地址时所进行的比较次数的期望值。因此，对表长为m、记录数为”的哈希表，查找成功时的平均查找长度为
，一习在0一〉二00
设对个记录的查找概率相等。即 从以上分析可见，哈希表的平均查找长度是Q的函数，而不是“的函数。山此，不管獠多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围内。
值得提醒的是，若要在非镒地址处理冲突的哈希表中删除一个记录，则需在该记录的位置上填人一个特殊的符号，以免找不到在它之后填入的“同义词”的记录。
最后要说明的是，对于预先知道目规模不大的关键字集，有时也以找到不发生冲突的哈希丞数，因此，对频繁进行查找的关键字集，还是应尽力设计一个完美的（perf “ 0的哈希函数。例如，对PASC丿、语言中的26个保留字可设定下述无冲突的哈希函数
H(key)：一I? + g(key[lj) I- g(key[Ll) 0一34）其中L为保留字长度，key [ 1 ]为第个字符，key [ 0为最后一个字符，×）为从字符到数字的转换函数，例如g（F）一15，g（N）一13，H（FUNCT、ON）：8斗15 + 13一36。所得哈希表长度为37（请参见参考书目「@] 327页一328页）
．262，
第10章 内部排序
概述
排序（Sor前g）是计算机程序设谚中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列．重新排列成一个按关键字有序的序列
从第9章的讨论中容易看出，为了查找方便，通常希望津算机中的表是按关键字有序的。因为有序的顺序表可以采用查找效率较高的折半查找法，其平均查找长度为 1（十l )一1，曲无序的顺序表只能进行顺序查找，其平均查找长度为十0／2。又如建造树表（无论是二叉排序树或B一树）的过程本身就是一个排序的过程。因此，学习和研究各种排序方法是计算机工作者的重要课题之一
为了便，于讨论，在此首先要对排序下一个确切的定义：
假设含”个记录的序列为
00D
其相应的关键字序列为
需确定1，2，“的一种排列／0，/0 动。，使其相应的关键字满足如下的非递减（或非递增的关系
（1 0．：0
即使式00．1）的序列成为一个按关键字有序的序列
0的3）这样种操作称为排序。
i．述排序定义中的关键字队0刂以是记录& 0一 吓的的主关键字，也可以是记录R的次关键字，甚至是若十数据项的组合。若K，是主关键字，则任何一个记录的无序序列经排序后得到的结果是惟一的；若K：是次关键字，则排序的结果不惟一，因为待排序的记录序列中可能存在两个或两个以上关键字相等的记录。假设K：K' 0 `
瓢j《'山关刀，目．在排序前的序列中&领先于R即i <刀。若在排序后的序列中R。仍领先于&，则称所用的排序方法是稳定的；反之，若可能使排序后的序列中领先于R，则称所用的排序方法是不稳定的
山于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：一类是内部排序，指的是待排序记录存放在计算机随机存储器中进行的排序过程，另、类是外部排序．指的是待排序记录的数量很大，以致内存一次不能容纳全部记录．
(.)若将式口0却中的“ "号改为“ '号．则满星菲i弟噌系．
刚不稳定的排序方法，要举出吲0；字洞实例说明它的小隐定性即凵以在排序过程中尚需对外存进行访间的排序过程。举章先集中讨论内部排序，将在下一章中讨论外部排序。
内部排序的力法很多，但就其全面性能面是很难提出一种被认为是最好的方法，每一种方法都有各自的优缺，适合在不同的环境（如记录的初始排列状态等）下使用。如果按排序过程中依据的不同原则对内部排序方法进行分类，则大致可分为插人排序、交换排序、选择排序、归并排序和调数排序等五类；如果按内部排序过程中所需的工作量来区分，则可分为3类：（l )简单的排序方法，其时间复杂度为00）；（2）先进的排序方法．其时间复杂度为0（司。“）；（3〕基数排序，其时间复杂度为0气吓的。本章仅就每一类介绍一两个典型算法．有兴趣了解更多算法的读者可阅读D．E，克努特著《计算机程序设计技巧》〔嗷第二卷，排序和查找）。读者在学习本章内容时应注意，除了掌握算法本身以外，更重要的是了解该算法在进行排序时所依据的原则，以利于学习和创造更加新的算法。
通常，在排序的过程中需进行下列两种基本操作：（1）比较两个关键字的人小；（2）将记录从一个位置移动至另一个位置。前一个操作对大多数排序方法来说都是必要的，而后一个操作可以通过改变记录的存储方式来于以避免。待排序的记录序列可有下列3种存储方式：（0待排序的一组记录存放在地址连续的一组存储单元上“它类似于线性表的顺序存储结构，在序列中相邻的两个记录和R宀0一
存储位置也相邻。在这种存储方式中，记录之间的次序关系由其存储位置决定，则实现排序必须借助移动记录；（2）一组待排序记录存放在静态縫表中，记录之间的次序关系由指针指示，则实现排序不需要移动记录，仅需修改指针即可；（3）待排序记录本身存储在、组地址连续的存储单元内．同时另设一个指示各个记录存储位置的地且向量，在排序过程中不移动记录本身，而移动址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。在第二种存储方式下实现的排序又称（链）表排序，在第三种存储方式下实现的排序又你地址排序。在本章的讨论中，设待啡序的一组记录以十述第一种方式存储，且为了讨论方便起见，设记录的关键字均为整数。即在以后讨论的大部分算法中，待排记录的数据类型设为：
#define MAXSIZE 20
、个用作示例的小顺序表的最大长度
typedef int t、戀de Struct {
定义关键字类型为整数类型
Ke 0 k白贮
关链字项
InfoType otherinfQ；
汐其他数据项
} RedType； typedef，ru酰{
记录类型
Red'Type + 0，
汐许明闲置或用作咱兵单元
length:
方顺序表长度
} S啦IS七；
/顺序表类型
因为在排序过中．只是改变记之间的次序关系，而不进行插人、删除臊作，且在排序结束时尚调整记录，故采用静态链表，
，264
1 0．2插人排序
10．2．1直接插入排序
直接插入排序（raight s。(t)是一种最简单的排序方法，它的基本操作是将一个记录插人到已排好序的有序表中，从而得到一个新的、记录数增]的有序表。
例如，已知待排序的一组记录的初始排列如下所示：〔D
R（49冫，R（38），R（65），R（90，R（76），R03），R（27），R（而），， （蜘一4）假设在排序过程中，前4个记录己按关键字递增的次序重新排列，构成一个含4个记录的有序序列
〈R（38），R09），R（65），R（97月 （1 0．5）现要将式（10．，4）中第5个（即关键字为76的）记录插入上述序列，以得到一个新的含5个记录的有序序列，则首先要在式（] 0一5）的序列中进行查找以确定巛76）所应插人的位置，然后进行插人。假设从R（97）起向左进行顺序查找，由于65 < 76 < 97，则R（76）应插人在巛65）和97）之间，从而得到下列新的有序序列
：R（38），R（19），R（65），R（7的，R（97）} （1 0．6）称从式（10．5）到式00．6）的过程为一趟直接插人排序。一般情况下，第?直接插入排序的操作为：在含有汾I个记录的有序子序列0， 一1中插人一个记录rCi--J后，变成含有i个记录的有序子序列．0并且，和顺序查找类似，为了在查找插入位置的过程中避免数组下标出界，在．明处设置监视哨。在自的1起往前搜索的过程中，可以同时后侈记，整个排序过程为进行一1捎插人，即：先将序列中的第1个记录看成是一个亻]序的子序列，然后从第2个记录起逐个进行插入，直至整个序列变成按关键字非递减有序序列为止0其算法如算法10．1所示；
void insert$ort,（SqList &-L) {
//对顺序表L作直接插人排序。
for（飞= 24土< L. lengtm + + i )
(LT(L. r( ?〕.key，L. r(i - l],key)) 汐“俨，需将L．r〔i」插入有序子表
以rC03生以rC i玉 复制为哨兵
L. rt到= L. CC 0珏
for〔j：i、．2；LT(). rtf) ] , key, L.．key)；
匚rurj +的：L.到； 记录后移
L、0 插人到正确位置
}
算法10．1
以式（10一4）中关腱字为例，按照算法也1进行直接插人排序的过程如图地1 所示0 巛表示关褲字为x的记碌，以下同
冖凵表示参与排序的顺表中下标从1到一1鵪记录序列，以后同。
为简便起见，图中省踮记R的符号，而只列其关鄖字。
· 265 ·
《初始关键字上
（38）〈65）四7）（76）
03）
（49）(（27）) （13
t监视哨L，rC0)
图10.〕直接插人排序示例
从上面的叙述可见．直接插人排序的算法简洁．容易实现，那么它的效率如何呢？从空间来看，它只需要一个记帚的辅助空间，从时间来看，排序的基本操作为：比较两个关踺字的人小和移动记录、先分析插人排序的情况。算法01中甲层的f以循环的次数取决于待插记录的关谊字与兯0一1个记录的关键字之间的关系。若l?. rL l _I .
key <匚r [ ll. key，则内循环中．待插记录的关腱字需与有序子序列匚
个记录的关鍵字和监视哨中的关键字进行比较，并将匚r〔I. 一0中i一〕个记录后移。则在整个排序过程（进行]耥插人排序丿中，当待排序列中记录按关键字非递减有序排列《以下称之为“正序"）时，所需进行关悱字间比较的次数达最小值“ 1（即1），记录不需移动：反之，当待排序列中记录按关谊字非i弟增有序排列（以下称之为“逆序”以I，总的比较次数达最人值0 + 2〕0 一1》2（即〗小记录移动的次数也达最大值
00 0一0．2（即习0一0）。若待排序记录是随机的，即待排序列中的记录可能出现的各种排列的概率相同，则我们可取上述最小值和最大值的平均值，作为直接插人排序时所需进行关键字间的比较次数和移动记录的次数．约为是/ 4。由此．直接插人排序的时间复杂度为00的。
10．2，2其他插入排序
从1．一的词论中可见，直接插人排序算法简便，且容易实现。当待排序记录的数量冂很小时，这是种很好的排序力法。但是，通常待排序序列中的记录数量“很人，则不宜采用直接插人排序。山此需要讨论改进的办法。在直接插人排序的基础十，从减少“比较"和“侈动"这两种操作的次数着眼，口得卜列各种插人排序的力法。
1 .折半插人排序
由十插人排序的基本操作是在一个序表中进行杳找和插人．则从9．1节的讨仑中可知，这个“查找"棵作可利用“半查找”来实现，由此进行的插人排序称之为折半插人排 · 266
& ( Binary係sertk0月S以0，其算法如算法加．2所小。
void刂自$ er主300．(SqList & 0 {
/剐顺序表L Il折半人排i短
将L」新存到L.
士r「10w highl中折半在找确序人的位置
key〕）high插人点在低半然 else 10囚 插人点在高半区
while
for（j 一j）以r「丿1 L亍到； ／/记录后移以rChigh?刂 //插人是for
} BInsertSort
算法世2
从算法地2容易看出，扔半插人排序所需附加存储空间和直接插人排序相同，从时间十比较，忻半插入排序仅减少了关字间的比较次数，而记录的伴动次数不变、因此，折半插人排序的时间复杂度仍为00的。
2，2．．路插人排序
2．路插入排序是在扒半插人排序的基础上再改进之，其目的是减少排序过程中移动记录的次数，但为此需要裎个记录的辅助空间。具体做法是：另设一个和L，r同类型的数组d，首先将l. “「0赋值给卦0，并将的0看成是在排好序的序列中处于中间位置的记录，然后从L “中第2个记录依次插人到0之前或之后的有序序列中。先将待插记录的关键字和卦0的关字进行比较，若L, r01 key，则将L? r[i ]插人到 d〔到之前的有序表中。反之，喇将L，r〔0插人到d〔0之后的有序表中。在实现算法时，可将d看成是“个循环向量，并设两个指针希和final分别指示排序过程中得到的有序序列中的第一个记录和最后1、记录在d中的位置。具体算法留作习题由汝者自己写出。
仍以式（10）中的关键字为例，进行2一路插人排序的过程如图也2所示。
在2一路插入排序中，移动记录的次数约为的。因此，2一路插人排序只能减少移动记录的次数，而不能绝对贈免移动记录。并且，当0还0是待排序记录中关键字最小或最大的记录时，2一路插人排序就完全失去它的优越性。因此，若希望在排序过程中不移动记录，只，自改变存储结构，进行表插人排序。
3．表插人排序
lldefine引Z 0 typedef {
丿静态锖表容量
RcdType rc；
记录项
int next；
指针硕
}SLNode;
表结点类型
typedef struct {
SLNode r[,3J?,EJJ /／0号单元为表头结点弋社leng%h；表当长度
静态表类型
L初始关字」； 38 9 7 排序过程中d的状态如下：
9）
六忄final
7 6
27
（3
个final
个first
@9 6的
（38）
，final
t first
（49 65 97〉
（38）
f final
忄巧t （3 8）
忄，al
忄fisst
（49 65
口3 38）
忄final
6吓t
（19 65 i，司
0 3 27 38）
09而65 76 97
27 3帥
忄final first
图10，2 3一路插人排序示例
假设以上述说明的静态表类型作为待排记录序列的存储结构，并fl，为了插人方使起见，设数组中下标为“ 0 "的分量为表头结点，并令表头结点记录的关键字取最大整数 MAXINTO则表插人排序的过程描述如下：首先将静态憐表中数组下标为巪”的分量（结点）和表头结点构成一个循环链表，然后依次将下标为“ 2 "至“月"的分量（结点）按记录关键字非递减有序插入到循环链表中。仍以式（10 4)中的关键字为例，表插人排序的过程如图10．3所示（图中省略记录的其他数据项)0
从表插入排序的过程可见，表插人排序的基本操作仍是一个记录插入到已排好序的有序表中。和直接插人排序相比，不同之处仅是以修改2 ”次指针值代替移动记录，排序过程中所需进行的关腱字间的比较次数相同。因此，表插人排序的时间复杂度仍是
另一方面，表插人排序的结果只是求得一个有序链表，则只能对它进行顺序查找，不能进行随机查找，为了能实现有序表的折半查找，尚需对记录进行重新排列。
重排记的做法是：顺序扫描有序锖表，将锖表中第》个结点移动至数组的第i个分量中。例如，图10．4（a）是经表插人排序后得到的有序谘表SL。根据头结点中指针域的指示，链表的第一个结点，即关键字最小的结点是数组中下标为6的分量，其中记应移至数组的第一个分量中，则将SL．r [ 1 ]和SL．r《6 ]互换，并且为了不中断静态链表中的 “镣"，即在继续顺链扫描时仍能找到互换之前在SL? r [ 0中的结点，令互换之后的SL出的中指针域的值改为“ 6 "（见图也缕（b））。推广至一般情况，若第个最小关键 · 258 ·
0
key域
MAXINT
49
38
6 5
9 7
7 6
0
MAXINT
4 9
38
65 9 / 7 6
2 7
遘9
灬
0000
亞
0
MAXINT
38
凸5
97
76
13
49
2
3
0
MAXINT 9
3 8
6 5
9 7 7 5
13
2 7 4 9
-0000
亞生0
初始状态
next域
o：3
MAXI.'、4T 49
38
97邝
13
49
-
00000
亞
MAXINT 19 38 65
9 7 7 6
] 3
灬00000000
MAXI.NT 49 38 65 97 76 13 27而
灬00000000
00000也00 -00000000
图地3表插人排序示例
字的结点是数组中下标为且力> 2的分量，则互换SL．和SL．r [ p ]，且令SL．中指针域的值改为加由于此时数组中所有小于i的分量中已是“到位“的记录，则当00 时，应顺链继续查找直到p冫，为止。图10、4所示为重排记录的全部过程。
算法10．3描述了上述重排记录的过程。容易看出，在重排记录的过程中，最坏情况是每个记录到位都必须进行一次记录的交换，即3次移动记录，所以重排记录至多需进行
30冖D次记录的移动，它并不增加表插人排序的时间复杂度。
void Arrange（SLinkListType &SL）{
//根据静态锖表SL中各结点的指针值调整记录位置．使得SL中记录按美键字非递减丿尸减有序顺序排列
p SL. next; p指示第个记冢的当前位鑼
· 269
for（i一]；is- $后]℃明t.还+卜 0（ $0 r 1， ．0 ]中记录已按关字有序排列．
，/篤i个记录在引，中的当前位置应不小于i
while（p心、的p 引冖「到找到第1个记录，并用p指小其在引，中当前位置
SL %_-p_l. next;q指示尚未调整的表尾
SL, r「p-?— FSL. rL iJ , '交换记录，使第土个记录到位
} №T刂e
初始状态P,
／/指向被走的记，使得以后可由“ hi循环找回
/ p指示尚未调整的表尾．为找第“ ]个记录作准备
算法 ] 0，3
0 2 4
97
邝
7
5
8
0
3
13
3卜
7 7巧
49
52
000000
maxillt
13
27
的 97
邝
9
38
（7）
4
tnaxint
13
7
胡 7 6
9
65
52
3
00000河0
tnaxitlt
6 97
5
6
（6）
0
《自Xttlt
] 3
（的
27
8
9
52
7
（力
（6）
（8）
4
(e)
(f)
t'naxtnt
65
97
7巧
5
（的
00
（的
（7）
图崮國 重排静态链表数组中记录的过程10．2，3希尔排序
希尔排序（S扁甲s Sort)又称“缩卜增量排序" ( Dimmishing Increment Sort)．它也是一种属插人排序类的方法，但在时间效率上较前述几种排序方法有较大的改进。
从对直接插人排序的分析得知．其算法时间复杂度为00的，但是，若待排记录序列为“正序”时，其时间复杂度可提高至00D。由此可设想，若待排记录序列按关键字“基本有序”，即序列中具有卜列特性
L. r[i．key《max{ L. r[j l . key} 口0一0 的记录较少时，直接插人排序的效率就可大大提高，从另一力来看，山于直接插人排序算法简单，则在“值很小时效率也比较高。希尔排序正是从这两点分析出发对直接插人排序进行改进得到的种插人排序方法。
它的基本思想是：先将整个待排记录序列分割成为若十子序列分别进行直接插人排序，待整个序列中的记。“基本有序”时．冉对全体记录进行一次直接插人排序。
仍以式00一0中的关雷字为例，先看一下希尔排序的过程。初始关键字序列如图地5的第]行所小。凸先将该序列分成5个子序列巛。& }，{ &，R?"
图10，5的第2行至第6行所示，分别对每个子序列进行直接插人排序，排序结果如图10，5 的第7行所示，从第1行的初始序列得到第7行的序列的过程称为一趟希尔排序。然后进行第二希尔排序．即分别对下列3个了序列巛RI，R4，&，RIO)，{ &，&，R"和《R “，进行直接橘人排序，其结果如图地5的第11行所示，最后对整个序列进行一悄直接插人排序。至此，希尔排序结束，个序列的记录已按关腱字非递减有序排列。
从上述排序过程可见．希尔排序的一个特点是：子序列的构成不是简单地“逐段分割 ，曲是相隔某个“增量，的记录组成 ．个子序列。如十例中．第一趟排序时的增量为
5，第二趟排序时的增量为3，由于在前两植的插人排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地往前挪动，而是跳跃式地往前移，从而使得在进行最后一耥增量为1的插人排序时，序列已基本有序，只要作记录的少量比较和移动即畸完成排序，因此希尔排序的时间复杂度较直接插人排序低。下面用算法语言描述上述希尔排序的过程，为此先将算法10，1改写成如算法瞪4所示的一般形式。希尔排序算法如算法也5所示。
void Shelllnsert（SqList &?L, int dk）{
对顺序表L作一希尔腼人排序。算法是和一直接插丿、排序相比，作了以下改：
1、前后记录位置的噌量是dk，而不是]；
2，垤明只是暂存单兀．不是哨兵。当< 0时．插人位置巳找到·
for（苤韭+ 1；讠<生length. 1 + i）
跹(LT(L,rii-1.ket/，L，0业Ike）{需将匚还插人有序增量子表 ／/暫存在L. r〔明 for 0 =一dk；了> 0 &&LT(L.rC0),key, L? rtjl? key)；
L.r[j+dkl “ 记录后移，查找插人位置仁r的+dk〕“ L，小 插人
}矛' Shellingert
算法10. 4
void $he11S?r上($qLi$t & [，，int dl上跹上int 0 {
//按增量序列d且a「0一产1 ]对顺序表L作希尔排序· for ()= k《十0
$he?iInsc:rt(L，山，k； ．@增量为醖的插人甾序 } // S№11S0
箅法10. 5
希尔排序的分析是一个复杂的向题，因为它的时间是所取“增量"序列的函数．这涉及一些数学上尚未解决的难题。因此，到目前为止尚未有人求得一种最好的增量序列，但大量的研究已得出一些局部的结论。如有人指出，当增量序列为d〔的：2。-一1时，希尔排序的时间复杂度为0的，其中'为排序趟数，1《< ' <山g20 + 1)」。还确人在大量的实验基础上推出：当N在某个特定范围内，希尔排序所需的比较和移动次数约为，当一～时，可减少到”山的。增量序列可以有各种取法叭但需注意：应使增量序列中的值没有除1之外的公因子，并且最后一个增帮值必须等子1。
也3快速排序
这一节讨论。类藉助“交换”进行排序的方法，其中最简单的 种就是人们所熟的起泡排序（Bubb№ Sort)。
．2 7 2 ·
起泡排序的过程很間单。首先将第一个记录的关键字和第二个记录的关键字进行比较．若为逆序（即L. 0 key+10. key），则将两个记录交换之，然后比较第二个记录和第二个记录的关键字。依次类推，直至第，冖1个记录和第”个记录的关键字进行过比较为止。上述过程称做第一趟起泡排序，其结果使得关诞字最大的记录被安置到最后个记录的位置上。然后进行第二趟起泡排序，对前，冖1个记录进行同样操作，其结果是使关键字次大的记录被安置到第“一]个记录的位置上。一般地，第i趟起泡排序是从 L，r [ 0到匚n一i十了]依次比较相邻两个记录的关键字，并在“逆序”时交换相邻记录，其结果是这”一十1个记录中关键字量大的记录被交换到第月乛+的位置上。整个排序过程需进行枞1《<起泡排序，显然．判别起泡排序结束的条件应该是“在一排序过程中没有进行过交换记录的操作”。图10，6展示了起泡排序的一个实例。从图中可见，在起泡排序的过程中，关腱字较小的记录好比水中气泡逐向上飘浮，而关诞字较大的记录好比石块往下沉，每一趟有一块“最大”的石头沉到水底（请参见“ 1?4，3节算法效率的度量”中起泡排序的算法）。
3 8
第 第 第 第 第初一一五 六
始耥
趟
关排 排 排
排 排
键序 序序 序 序
字后 后 后 后 后
图也6起泡排序示例
分析起泡排序的效率，容易看出，若初始序列为“正序"序列，则只需进行一排序，在排序过程中进行”一1次关键字间的比较，且不移动记录；反之，若初始序列为“逆序"序列，则需进行一1排序，需进行〗0一D：”一l) / 2次比较，并作等数量级的记录移动。因此，总的时间复杂度为0（）。
快速排序(Quick sort)是对起泡排序的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关诞字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
假设待排序的序列为{匚r「，匚r [ s + 0，一，L．r [诩，首先任意选取一个记录（通常可选第一个记录L. r卜〕）作为枢轴（或支点）〔pi四t），然后按下述原则重新排列其余记录将所有关键字较它小的记录都安置在它的位置之前，将所有关诞字较它大的记录都安置在它的位置之后。山此可以该“枢轴"记录最后所落的位置i作分界线，将序列
，2 7 3 ·
，0 0 0：分割成两个子序列{ 0 r卜
1的0，0《0 +的 ．，匚0这个过程称做一趟快速排序（或一次划分）。
一趟快速排序的具体做法是、附设两个指针w和卜igh，它们的初值分别为tow和卜igb，设枢轴记录的关鍵字为四OLk “，则首先从high所指位置起向前搜索找到第一个关键字小于四?otkey的记录和枢轴记录互相交换，然后从。w所指位置起向后搜索，找到第一个关键字大pivotkey的屺录和枢轴记录互相交换，重复这两步直至low— high 为止。其算法如算法10，6（a）所示。
int（&?L、建10 int high) {
，／交换顺序表L中子表L．rL1。“．h均h ]的记录，使枢轴记录到位，并返回其所在位置，此时 在它之前（后）的记录均不大（小冫于0
pivotkey匚用子表的第一个记录作枢轴记录
"h 10 (low<high) { 从表的两端交替地向中间扫描
树h玉le（1 `《h上gh &以ri_hLghl, key)>Z pivotkey) 一high;
L产10 0艹?L. r!high ;将比枢轴记录小的记录交换到低端 while 00“《high & &经过、《；；piVQtkey)
将比枢轴记录大的记录交换到高端
#返回枢轴所在位置 } Par巨0．00
算法10，6
具体实现上述算法时，每交换一对记录需进行3次记录移动（赋值）的操作、而实际上，在排序过程中对枢轴记录的赋值是多余的，因为只有在一排序结束时，即low ? high的位置才是枢轴记录的最后位置。山此可改写上述算法，先将枢轴记录暂存在r〔．的的位置上，排序过程中只作r00或r[hig到的单向移动，直至一峭排序结束后再将枢轴记录移至正确位置上。如算法06（的所示。
int pa以建100 (SqLi$t int〕．0 int high) {
交换顺序表L中子表rCl “ high二的记录，枢轴记录到位，并返回其所在位置．此时 在它之前（后冫的记录均不人（小）于它。
L以〔0」 L. r [ 10到； 用子表的第一个记录作枢轴记录 pivotkey苎La r [ 10．ke 枢轴记录关键字
while（10 < h №h）{ ／/从表的两端交替地向中间扫捃 while 00“ < Pivotkey) ．high;
//将比枢轴记录小的记录移到低端
pivot-key) +、1四；
将比枢轴记录大的记录移到高端
0r0 枢轴记录到位 return 10； 返回枢轴位置 } Partition
算法] 0．6〔b〉
以式（10一4）中的关键字为例，一趟快排的过程如图] 0， 7（a）所示 整个快速排序的过程可递归进行。若待排序列中只有一个记录，显然已有序，古则进行一趟快速排序后鴉分别对分割所得的构个了序列进行快速排序，如图10．7（b）所示。
plvotkt'、．
初始关键宇
进行1次交换之后 276 513 4 9
进行2次交换之后 49
进行3次交换之后 27 65
进行1次交换之后 2了
完成一趟排序
初始状态
一次分之后
分别进行快冲排序
38 13 49
(a)
13： 06
《38：结束 结束 《49
49
9765 }结束
65
结来
有序序列
0 3 2 7 3 8 4 9
图100，快冲排序示例
〔一快排过程；〕排序的全过程
65
7 6
递归形式的快速排序算法如算法10．7和算法1伍8所示。
void Q%rt (SqList &〔，int 10“，int h〕.gh) {
//对序表L中的子序列．high〕作快速排序 if（10“ high) { //长度大于I
p讷0t300 part: L，10 high)； 将L.
high」一分为一
QScr L．〕℃ pi 0L1忧一]）： 瘴对低子表递归排序，p。是枢轴位詈
QSore()? pivotloc + 1．high) : 汐对高子递归排序
}// QSort
算法 10，7
void QuickSort(SqList &い{ 冫対序表作快連引い行
0S0社( L しにlength) :
レ:′ QDJ ckSort
算法10 8
夬速排序的十均吋同内れ) = Inn ,其中なカ待排序序列中汜求的个数カ某个常数,錏強沚明、在所有同数量級的此英(先迸的)排序方法中,快速排序的常数因子最小。因此,就十均吋同面高、速卅庁是目前被カ是最好的一神内部排序方法。
ド面我們来分析快速排序的平均吋同性能。
假設T(n )カ対れ个記求L. rい..心迸行快速排序所需吋回.則由算法QuickSort 可
T朝)ーT”朝)十'l'は一1 )十T朝一い
其中T”、(れ)内対〃个妃求迸行一快速排序pa山朝n ( L , 1 , n)所需吋同,从算法純. 7 可見,它和記最数〃成正比,可以(:〃表示之はカ某个常数) ; T(kーい和T朝一い分:別カ対L. r[l.. kー寘和し砿いl.. n中記迸行快連排序QSort ( Lコ, kーい和QSort( L , い, 1 , n )所需日寸同。假没待排序列中的記是随机排列的,則在ー、排序之后訣取1至〃之回仼何一値的概率相同,快速排序所需吋的平均値則カ
TOVA朝) = (十一ゞCTavgは一1 )十朝一い」
( 1 8 )
假定町い1 )くわ(わカ某个常量英同式いト19 )的推昇,山式(川)可推出
ー十一十"?十
、(ー十2。( "十1)11、( "十い" ) 2 ( 10-9 )
通常,快速排序被仄是.在所有同数量級( 0 (れlc D )的排序方法中,其平均性能最好。但是,若初始記冢序列按美鍵字有序或基本有序対,快速排序将蜆化刃起泡排序, 其討回夏染度カ0 (が)。カ改迸之,通常依。一者取中"的法則来逸取枢紬i己隶.即比絞
s十t
し引. key、L.心〕. key和L. r 2 . key ,取三者中其美置字取中値的記泉労枢釉
只要将苡i己和L. r[s」互換,算法川. 6 (い不変。舞驗沚明,来用三者取中的規剿可人大改善快速排序在最坏情况下的性能。然而,即使如此,也不能使快速排序在待排記隶序列已按美鍵字有序的情况ド迭到0朝)的吋同夏奈度。カ此,可如下所述修改一次分" 算法:在指針higト減1和1。w增1的同吋迸行"起泡"操作.即在相鄧网个杞隶赴于"逆序"日寸迸行互換.同吋在算法中附i殳南个布尓型変量分別指示指w和high在从襾端向中囘的移功程中是否迸行i寸交換記求的操作,若指, w在从低端向中回的移:は
?2 7 6
程中没有进行交换记录的操作，则不再需要对低端子表进行排序；类似地，若指钊high在从高端向中间的移动过程中没有进行交换记录的操作，则不再需要对高端子表进行排序。
显然，如此“划分”将进一步改善快速排序的平均性能。
由以上i寸论可知，从时间上看，快速排序的平均性能优于前面讨论过的各种排序方法，从空间上看，前面i寸论的各种方法，除2一路插人排序之外，都只需要一个记录的附加空间即可，但快速排序需一个栈空间来实现递归。若每一趟排序都将记录序列均匀地分割成长度相接近的两个子序列，则栈的最大深度为g “」+ ]（包括最外层参量进栈），但是，若每趟排序之后，枢轴位置均偏向子序列的一端，则为最坏情况，栈的最大深度为月。如果改写算法10．7，在一耥排序之后比较分割所得两部分的长度，且先对长度短的子序列中的记录进行快冲排序，则栈的最大深度可降为00。g ' 也4选择排序
选择排序吓山佣Sort)的基本思想是：每一在一?十1 0：到，2，一删一l )个记中选取关讲字最小的记录作为有序序列中第下个记录。其中最简单[I、为读者最熟悉的是简单选择排序。(Simple Selection Sort)9
4．1简单选择排序
一简单选择排序的操作为：通过烈一次关讲字间的比较，从“一0}一1个记录中选出关键字最小的记，并和第汽上《0到的个记录交换之“
显然，对匚r「1.的中记录进行简单选择排序的算法为t令从1至月一1，进行尹冖1 选择操作，如算法10．9所示。容易看出，简单选择排序过程中，所需进行记鼠侈动的操作次数较少，其最小值为“ 0 ”，最大值为3（，冖1 )。然而，无论记录的初始排列如何，所需进行的关鍵字司的比较次数相同，均为”一l ) / 2。因此，总的时间复杂度也是00的。
void SelectSort (SqLiet & 0 {
对顺序表L作单选择排序“
for 0．=、L、length; + + i) { = SelectMinXey( L，i)；
j) L r [到艹艹L、r-_i
彦选择第1小的记录，并交换到位
在L一L.I翩g上h〕中选杼k最小的记录
//与第i个记录交换
}／7 Sel ectSort
算法10 9
那么，能否加以改进呢？
从上述可见，选择排序的主要操作是进行关键字间的比较，因此改进简单选择排序应从如何减少''比较”出发考虑。显然，在个关键字中选出最小值，至少进行腺一1次比较，然而，继续在剩余的，冖1个关键字中选择次小值就并非一定要进行一2次比较，若能利用前觐一]次比较所得信息．则可减少以后各趟选择排序中所用的比较次数。实际上．体育比赛中的锦标赛使是种选择排序。例如，在8个运动员中决出前3名至多需要场比赛，而不是7丰新．5 =讣场比赛（它的前提是．若乙胜内，甲胜乙，则认为甲必能胜内）。例如，图08（的中最低层的明子结点中8个选r之间经过第一轮的1场比赛之后选拔出4个优胜者“ C比V' "BAC)"、“ DIA() ”和“ WANG ”，然后经过两场半决赛和一场决赛之后，选拔出冠军．BAC)'%显然，按照锦标赛的传涕关系，业军只能产生于分别在次赛．半决赛和第一轮比赛中输给冠军的选乒中。山此，在经过"CHA"和，'、"CHA"和"DlAO ”的两场比赛之后，选拔出业军"CHA ”，同理，选拔殿军的比赛只要在“ Z凵AO "、
“凵U ”和“ DIA(-) ” 3个选手之间进有即可。按照这种锦标赛的思想可导出树形选择排序。图厩8锦标赛过程示意图
@选冠军的比赛程序；（b〕选拔亚军的两场比群；@达拨季军的两场比赛
世4．2树形选择排序
树形选择排序(Tree selection sort)，又称锦标赛排序），是一种按照锦标赛的思想进行选择排序的方法。首先对，0记录的关隸字进行两两比较，然后在其中「《]个较小者之间再进行两两比较．如此重复．自至选出最小关键字的记录为止
278 ·
这个过程可用一棵有n个叶子结点的完全一叉树表小。例如，图] 0．9（的中的二叉树表示从8个关键字中选出最小关字的过程。8个叶子结点中依次存放排序之前的8个关键字，每个非终端结点中的关键字均等于其左、右孩子结点中较小的关踺字，则根结点中的关踺字即为叶子结巨中的最小关键字。在输出最小关键字之眉，根据关系的可传i弟，欲选出次小关键字，仅需柯叶子结点中的最小关键字（1 3）改为．'最大值”，然后从该明子结点开始，和其芹（或右）兄弟的美腱字进行比较，修改从明子结点到根的路径卧各结点的关键字，则根结点的关鍵字即为次小关腱字。同理．可依次选出从小到大的所有关腱字（参见图] 0．9（0和（的）。山于含，自月个叶了结点的完全一叉树的深度为自。ge到0，则树形选择排序中，除了最小关键字之外，每选择一个次小关键字仅需进行围0次比较，因此，它的时间复杂度为0詞。ge劢。但是，这种排序力法尚辅助存储空间较多、和“最大值”进行多余的比较等缺点。为了弥补，威洛姆斯就在1964年提出了另一种形式的选择排序堆排序。图地9树形选择排序示例
选出最小关字为吓， 口到选出次小关褲字为27； （的选出居第。的关字为
10．4．3堆排序
堆hE*(Heap So出只需要一个记录大小的辅助空间，每个待排序的记录仅占有仔储空间
279
堆的定义如下；月个元素的序列 ，称之为堆。
若将和此序列对应的一维数组（即以一维数组作此序列的仔储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列，妩， ，，妩}是堆，则堆顶元素（或完全二叉树的根）必为序列中“个元素的最小值（或最大值）。例如，下列两个序列为堆，对应的完全二叉树如图10，还所示图1 000堆的示例
（的堆唢元取最大值；(b)堆顶元取最小值
@6，8 3，暫，，Il，0明
0 2．3 21，8 5，“17，3 0，到，91 }
若在愉出堆顶的最小值之后，使得剩余“一1个元素的序列重又建成一个堆，则得到 “个元素中的次小值、如此反复执行，便能得到一个有序序列，这个过程称之为唯排序。
由此，实现堆排序需要解决两个问题：0）如何由一个无序序列建成一个堆？（2）如何在输出堆顶兀素之后，调整剩余元素成为一个新的堆？
下面先讨论第二个问例如，图地I l（a）是个堆，假设输出堆顶元素之后，以堆中最后一个元素替代之，如图10. 11（b）所示。此时根结点的左、右子树均为堆，则仅需自上至下进行调整即可。首先以堆顶元素和其左、右子树根结点的值比较之，由于右子树根结点的值小于左子树根结点的值且小于根结点的值，则将石和97交换之；由于97替代了 27之后破坏了右了树的“堆”，则需进行和上述相同的调整，直至叶子结点，调整后的状态如图10，11（c）所示，此时堆顶为” I个元素中的最小值。重复上述过程，将堆顶元素27 和堆中最后一个元素97交换且调整，得到如图10．11（d）所示新的堆我们称这个自堆顶至叶子的调整过程为“选”
从一个无序序列建堆的过程就是一个反复“筛选''的过程。若将此序列看成是一个完全二叉树，则最后一个非终端结点是第‰' 2怀元素，由此“篩选"只需从第I 2怀元素月
始。例如，图．12（a）中的=又树表示一个有8个元素的无序序列
《4 g，3 8，65，97，76，[ 3，27，49 }
280
则筛选从第4个元素廾始．山于97 >，则交换之，交换后的序列如图〕0，12（b）所小，同理，在第3个元素的被筛选之后序列的状态如图10，1 2（0所示。山于第2个元素38不大于其左、右子树根的值，则筛选后的序列不变。图10．] 2（e）所示为筛选根元素49之后建成的堆
堆排序的算法如算法地] I所示，其中筛选的算法如算法地10所示。为使排序结果和10，1节中的定义一致，即：使记录序列按关键字非递减有序排列，则在堆排序的算法图地1 ]输出堆顶元素丌调整建新堆的过程
《的唯；0》0和的交换后的情形；《0调后的柄堆；
〔小和90到奂嚆再进行调建成的新堆图111 12建初始堆过程示例
(a)无序序列：〔的叨被筛选之后的状态；（园被筛选之后的状态；
(d)被唏选之后的状态；气〕被筛选之建成的堆
· 2 8 1
中先建一个“大顶堆”，即先选得一个关祧字为最大的记录并与序列中最后一个记录交换，然后对序列中前”．4记录进行唏选，重亲i将它调整为一个“大顶堆”，如此反复直至排序绿束。由此，“筛选”应沿关字较大的孩了结点向下进行 typedef SqList deapTypei 堆采用巫表存储表示
void beapAdjust (heapType &H. int醭{
季己知比r@的中记录的关键字除H，r[到，key之外均满足堆的定义，函数调整比过到 的关字，使H，r成为一个人」负堆（对其中记录的关键字曲言）
H. 5吓
for〈j。2 g；十 沿key较大的孩子结点向下啼选
辽〈、m && LT(H. rLf_', key，H (C) + Il key)冫 为y较大的记录的下标
ke碧）break' ／7 “应届人在位置5 t
到S 0； 在人 } # Hea?Adoust
算法
void HeapSort（Heaplype）{
．
o把H. rCI , . H过igth I建成大顶堆
将堆顶记和当前未经排序子序列0中 最后一个记录相互交换
HeapAdjust(), 1，将H囝1一0 1 ]軍新调整为大顶堆
／/ HeapSort
算法10 11
堆排序方法对记录数较少的文件并不值得提倡，但对较大的文件还是很有效的。
因为其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选"上。对深度为差堆，锛选算法中进行的关键字比较次数至多为2一1）次，则在建含月个元素、深度为 h的堆时，总共进行的关键字比次数不超过4 ”产又“个结点的完全二叉树的深度为山gz利+ 1则调整建新堆时调用HeapAdjust过程月一1次，总共进行的比较次数不超过卜式之值，
由此，堆排序在最坏的情况．其刊间复杂度也为00 g的。相对于快速排序来说．这是堆排序的最大优点。此外，堆排序仅需一个记录大小供交换用的辅助存储空间
也5归并排序
归并排序（Me “ S。(t)是又一类不同的排序力法。“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。它的实现方法早己为读者所熟悉，无论是顺序存储结构还是表存储结构，都在0彐的：P'的时间量级上实现。利用归并的思想容易实现排序。假设初始序列含有月个记录，则可看成是个有序的子序列，每个子序列的长度为1，然后两两归并，得到「到个长度为2或1的有序子序列；再两两归并，． ．，，如此
复誚至得到一个长度为烈的有序序列为止，这种排序方法称为2一路归丌排序。例如图
] 0口3为2一路归并排序的一个例子。
初始关字
一归并之后
二归并之后
三归并之后
图也t 3 2．路归豇排序示例
2．路归并排序中的核心操作是将一维数组中前后相邻的两个有序序列归并为一个有序序列，其算法（类似于算法杰0如算法10，12所小。
void Merge (RcdType RcdType ]，int i '社ms int n) { 是将府序的SRLi、趲和SR「m+ 1．归并为有序的」
将中记录山小到大地并人TN
+ +耘
if气<= m) TRCk.将剩余的詣陆到复制到然 if 0《：山1可k、将余的渊．i一到复制到TR }，女Merge
算法 10．1 2 假设两个有序表长度分别为和，
倥283 ·
一趟归并排序的操作是，调用「一]次算法merge将SRIl. .的中前后相邻且长度为/．
的有序段进行两两归并，得到前舌相邻、长度为2禹的有序段．炸存放在TRill一n。中．整个归并排序需进行「[。g2趟。可见，实现归并排序需和待排记录等数量的辅助空问，其时间复杂度为00前g过出
递归形式的2路归并排序的算法如算法] 0，] 3和算法] 0，]：1所示。值得提醒的是，递归形式的算法在形式上较間洁，但实用性很差。其非递归形式的算法可查阅参考书目
与快冲排序和堆排序相比，归并排序的最大特点是，它是一种稳宁的排序方法，但在一般情况下，很少利用2．路归并排序法进行内部排序，其他形式的归并排序如本书习题集中习题也1 7所述。
void MSOVt（RcdTyve S瞓0，RcdTYPe &，，社t）{ 在将$R这，的归并排序为〕这．瞓
跹嫲= = 0 THI《到$ $ else {
0 T 0 0； or上()R，TR2，$，m)；
M.Sort（，TR2，+ 0 0；
Merge（2，TRI.耘0；
将訃@一凵平分为SR陆一和L．0 递归地将SRC*.到归并为有序的TRW s到
递归地将圳．m到，，的归为有序的「，0
o将TR2卜一到和然2〔的0一0归并到吓]@一0
算法13
void（SqLi$t & 0 {
对顺序表L作归并排序
MSort(). r.以0 1，L. length)；
} MergeSort
算法10 ] 4
6基数排序
基数排序巛adix sorting）是和前面所述各类排序方法完全不相同的一种排序力法。从前几的过论可见，实现排序主要是通过关键字间的比较和移动记录这两种操作，而实现基数排序不需要进行记录关键字间的比较。 基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。
1 0．6 1多关键字的排序
什么是多关键字排序问题？先看、个具体例子已知扑克牌中52张牌面的次序关系为．@ 28
`牵2 <牵
每一张的两个' '关字”；花色（000 0牵）和而值003《“ < A），且“花色”的地位高于“曲值六在比较任意两张牌面的大小时，必须先比较“花色”，若“花色”相同．则再比较曲值。由此，将扑克牌理成如上所述次序关系时．通常采用的办法是：先按不同“花色”分成有次序的4堆，每一堆的牌均具有相同的“花色”，然后分别对每一堆按“面值”大小整理有序。
也可采用另一种办法：先按不同“面值”分成] 3堆，然后将这13堆牌自小至大叠在一起（“ 3 ”在“ 2 ”之0 “ 4 ”在“ 3 ”之上，． ．，最上面的是4张“ A，0，然后将这付牌整个颠倒过来冉重新按不同“花色”分成，1堆，最后将这，1堆牌按自小至大的次序合在一起（在最下面，牵在最上而），此时同样得到一付满足如上次序关系的牌。这两种整理扑克牌的方法便是两种多关键字的排序方法。
一般情况下，假设有握个记录的序列
0 0一10）且每个记录&中含有浸个关．，1），则称序列口0一] 0）对关谊字（K丛K〕，一，K “ 1）有序是指：对于序列中任意两个记录R,和地0《新0《都满足下列有序关系 其中K。称为最主位关键字，K -称为最次位关键字。为实现多关键字非序，通常有两种方法：第一种方法是：先对最主位关字进行排序，将序列分成若干了“序列，每个子序列中的记录都具有相同的℃值，然后分别就每个了序列对关腱字K)进行排序，按Kl值不同再分成若干更小的子序列，依次重复，直至对K “进行排序之后得到的每一子序列中的记录都具有相同的关键字（K六℃，“．，0的，而后分别每个了序列对K “进行排序，最后将所有子序列依次联接在一起成为一个有序序列，这种方法称之为最高位优先 (Most Significant D@tfir法，简称MSD法；第二种方法是从最次位关腱字K “起进行排序。然后冉对高一位的关键字K “进行排序，依次重复，直至对℃进行排序后便成为一个有序序列。这种方法称之为最低位优先（0“ t S nt D@0吣的法，简称 LSD法。
MSD和LSD只约定按什么样的“关键字次序"来进行排序，面未规定对每个关键字进行排序时所用的方法。但从上面所述可以看出这两种排序方法的不同特点：若按 MSD进行排序，必须将序列逐层分割成若干子序列，然后对各子序列分别进行排序；而按 LSD进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序，但对 K巛，《i <（02）进行排序时，只能用稳定的排序方法。另一方面，按LSD进行排序时，在一定的条件下（即对前一个关键字K(0 <》< d一2）的不同值，后一个关腱字K宀均取相同值），也可以不利用前几节所述各种通过关键字间的比较来实现排序的方法，而是通过若干次分配"和“收集"来实现排序．如上述第二种整理扑克牌的方法那样
．，驴一与是指必定存在0使得；当“的
1伍6，2链式基数排序
基数排序是借助“分配"和“收集"两种操作对单逻辑关腱字进行排序的一种内部排序方法
有的逻辑关键字可以看成由若十个关踺字复合而成的。例如，若关字是数值，且其值都在（〕飞K 999范围内，则叫把每一个十进制数字看成一个关孬即可认为K由3 个关腱字（，K，K '）组成，其中是阿位数，Kl是十位数，是个位数；又若关键字 K是由5个字母组成的单词，则可看成是由5个关踺字（和，，，KS，）组成，其中 K。是（自左钅右的）第个字母。山于如此分解而得的每个关键字K'都在相同的范围内（对数字，0《K；9，对字母' A ' < K，《Z '），则按LSD进行排序更为方便，只要从最低数位关键字起，按关键字的亻、同值将序列中记录“分配”到RADIX个队列中后再“收集”之，如此重复d次。按这种方法实现排序称之为基数排序，其中“基”指的是RADIX 的取值范围，在上述两种关字的情况下，它们分别为“ ]的和“ 26 ”。
实际上，早在计算机出现之前，利用卡片分类机对穿孔卡十的记录进行排序就是用的这种方法。然而，在计算机出现之后却长期得不到应用，原因是所需的辅助存储暈（RA、 DIX" N个记录空间）人丿巛直到0詞年有人提出用“计数”代替“分配”才使基数排序得以在计算机L实现，但此时仍需要”个记录和2 × RAC月X个计数单元的辅助空间。此后，有人提出用表作存储结构，则又省去了个记录的辅助空间0卜面我们就来介绍这种“链式基数排序”的力法。
先看一个只体例了、首先以静态表存储n个待排记录，并令表头指针指向第一个记录，如图地0（的所示；第一岫分配对最低数位关键字（个位数）进行，改变记录的指针值将涟表中的记录分配至1的i、队列中去，每个队列中的记录关字的个位数相等，如图地0（树所示，其中0．〕和卦0分别为第下个队列的头指针和尾指针；第一收集是改变所有非空队列的队尾记录的指针域，令其指向卜一个非空队列的队头记录，重将 10个队列中的记录链成一个彘表，如图地凵（c）所示；第二分配，第了收集及第一趟分配和第二收集分别是对十位数和百位数进行的，其过程和个位数相同，如图 14（山、）所示。至此排序完毕。
在描述算法之前，尚需定义新的数据类型
#define MAX NUM誑生KEY 8 另／啭字项数的最大值
#define RADIX 10 关谊字基数，此时是十进制整数的基数
*define MAX- SPACE I 00 typedef str {
KeyeType keysCMAX．膶0下KEY」： 关字InfoType Other Lens；
} SLCel 1； typedef { SLCe11 r「1 X．SPACE);
int )SLJristi typedef int Acrlype R自DI和；汐其他数据项
静态表的结点类型
静态链表的可利用空间，r「的为头结记录的当前关字个数 静态链表的当前长度静态链表类型指钅》数组类型 瓯6〕 et7〕
930
9
184
083
278
505
e〔明社2〕eL5〕 e〔7」8」 eL91
呱t〕 0〕0
053
269
278
朝3
505 8 1D9 圓4 589
@初始状态；（的一分配之后：@第一塒收集之0（的二分配之0
（第收集之后0 0第二分配之后口g）第三收集之后的序文件
算法15为式基数排序中一分配的算法，算法] 0．16为一收集的算法，算法 ] 0．17为式基数排序的算法，从算法中容易看出．对于个记录（假设每个记录含d个关腱字，每个关字的取值范围为个值）进行链式基数排序的时间复杂度为 0恸+ (d)），其屮每一趟分配的时间复杂度为0（的．每一趟收集的间复杂度为
00的，整个排序窬进行d分配和收集。所需辅助空间为2个队列指针。当然，由于
· 287 ·需用链表作存储结构，则相对于其他以顺序结构存储记录的排序力法而灬还增了”个指针域的生间。
void Distribute（S「℃eli & 0玉社辶ArrType &六ArrType (e) {
静态链表L的域中记录按（底y明，，一，keysi i一] I)有序“
／本算泫按第i个关鍵字ke ”巨]建立DIX个子表，使同一子表中记录的k可了相同 fL0. RADIX-〕]和RADIX-刂分别指向各子表中第一个和最后个记录。for 0；0；〕<、RadiXi十+ j ) 0到 各子表初始化为空表 for (); r [ 0」，next;内p = ]过国．next) {
ke卦 //以d将记录中第i个关键字映射到@一以一到，
将p所指的结点插人第〕个子表中
算法] 0．巧
void “匕（swell & r，int i．，ArrType的{
汐本算法按雇“《到自小至大地将ft0. 0所指各了表依次彘接成一个表、 eco. R№以一0为各子表的尾指针
（j =山 找第一个非空子表，su“为求后继函数 r@0-《=咗诩 ，/红的，n“凵卜向第一个非空了表中第一个结点 while（<．D以）{
tor ( j；；suec( j) ; 是succ(j)真 找下个非空了表 if（到）掹两-i、空予表
到．next. ”指向最后一个非空了表中的最后一个结点》汐C011e〔跹
算法 10．16
void Radix%rt(SLList &?L) {
〔是采田静态縫裁表示的顺序表。
//对L作基数排序，使得L成为按关鍵字自小到大的有序静态链表，L就[月为头结点。
for 0．0；i<_L. + + i) L. next = 1后
L．L、reenum．next /将L改造为静态链表
for 0：0；i<L.kevnum；“ 0 {汐按最低位优先依次对各关键字进行分配和收集
№上献L.r．讼f，e)； 第1分配 Collect(L.r，辶9后 过第1收集
} R司土
算法10．17
億7各种内部排序方法的比较讨论
综合比较本章内讨论的各种内部排序方法．大致有如下结果〔见下页表）。
从忄表可以得出如卜丿I个结论，
· · o）从平均时间性能而0快速排序最佳，其所需时间最省，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后两者相比较的结果是，在较大时，归并排序所需时间较堆排序省，但它所需的辅助存储量最多。
（2） 上表中的“简单排序”包括除希尔排序之外的所有插人排序，起泡排序和简单选掸排序，其中以直接插人排序为最简单，当序列中的记录“基本有序”或值较小时，它是最佳的排序方法，因此常将它和其他的排序方法，诸如快速排序、归并排序等结合在一起使用。
（3） 基数排序的时间复杂度事可写成00丿．的“因此，它最适用于控值很大而关甾字较小的序列。若关键字也很大，而序列中大多数记录的“最高位关键字”均不同，则亦可先按“最高位关键字”不同将序列分成若干“小”的子序列，而后进行直接插人排序。
（4） 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为0（，的的简单排序法也是稳定的，然而，快速排序、堆排序和希尔排序等时间性能较好的排序方法都是不稳定的。一般来说，排序过程中的“比较"是在“相邻的两个记录关键字"间进行的排序方法是稳定的。值得提出的是，稳定性是由方法本身决定的，对不稳定的排序方法而言，不管其描述形式如何，总能举出一个说明不稳定的实例来。反之，对稳定的排序方法，总能找到一种不引起不稳定的描述形式。由于大多数情况下排序是按记录的主关键字进行的，则所用的排序方法是否稳定无关紧要。若排序按记录的次关键字进行，则应根据问题所需慎重选样排序方法及其描述算法。
综上所述，在本章讨论的所有排序方法中，没有哪一种是绝对最优的。有的适用于” 较大的情况，有的适用于较小的情况，有的．一“因此，在实用时需根据不同情况适当选用，甚至可将多种方法结合起来使用。
本章时论的多数排序算法是在顺序存储结构上实现的，因此在排序过程中需进行大量记的移动。当记录很大每个记录所占空间较多）时，时间耗费很大，此时可采用静态链表作存储结构。如表插人排序、链式基数排序，以修改指针代替移动记录。但是，有的排序方法，如快速排序和堆排序，无法实现表排序。在这种情况下可以进行“地址排序"，即另设一个地址向量指示相应记录；同时在排序过程中不移动记录而穆动地址向量中相应分量的内容。例如对图10．15（a）所示记录序列进行地址排序时，可附设向量 adr() : 8）在开始排序之前令adr〔刂：：凡在排序过程中需进行邝] 一r的的操作时．均以adrCil 一adr引代替，则在排序结束之后．地址向量中的值指示排序后的记录的次序“ [ adr《0」为关鍵字最小的录，rcadr [ 8了为关键字最大的记录，如图思巧（b）所
· 28 9 ·
示。最后在需要时可根据a山的值重排记录的物理位置。重排算法妇下．
R 0的
R（6的
R（3
R（2的
R（9的
R口3）
R（7的
104.9)
5
5
3
8
2
R（13）
R（27》
R（38）
R《4帅
R（90
R（6
R 0的
2
3
4
8
6
7
0
ad r 0；卜冫
adr(l：8）
r( 0 8）
adr(l：8）
图地巧地址排序示例
（待排记录和地址向量的初始状态i (b)排序结中的地址向；（的排记录过程中的軚态
从01起依次检查每个分量位置上的记录是否正确到位。若司r湖一i，则忄0中恰为第 i个最小关键字的记录，该位置上的记录不需要调整《若adr@一k i，则说明r〔k〕中记录是第个最小关键字的记录，应在暂存记录rCi〕之后将r〔k ]中记录移至r@的位置建上。类似地，若则应将r [ adr〔k们中记录移至r〔k〕的位置上。依次类推，直至找到某个值j =adrtadrl???adrlkl???ll '等式adr[ll=i成立时，将暂存记录移至的位置上。至此完成一个调整记录位置的小循环。例如图] 0、巧的例了，山于图地0（的中 adr「0一6，则在暂存R（49）以后，需将R0 3）从许的的位置移至r00的位置。又，因为 ad和的：2，则应将R（65）从r「们的位置移至还6 ]的位置。同理，将R（27）移至到的位置，此时，因adr [到一]，则R（49）应置人r〔们的位置上。完成上述调整后的记录及地址向量的状态如图10，巧@所示。算法10，18即为上述重排记录的算法。
void Rearrange（gqList」）{
》adr给出顺序表L的的序次序，即L “@drl(i旧是第i小的记录。
汐本箅法按adr重排L．。僅其有序。
for（i 1；i<L- length；+丬1）
L疒[的： //暂存记录L．rCi]
while ()d《j ] 0：〕的{ 调整匚r dr〔j〕]的记录到位直到adr [到：i为正
记录按序到位
》Rearrange
算法10．18
从上述算法容易看出，除了在每个小循环中要暂存一次记录外．所有记录均一次移动(D r的位置捐的是r数组中第》个分量，下同“
， ·
到位。曲每个小循环至少移动两个记录．则这样的小循环至多有002」个，所以重排记录的算法中多移动记录[3刀到次。
本节最后要时论的一个问题是，“内部排序可能达到的最快悚度是什么”。我们已经看到，本章时论的各种排序力法，其最坏情况卜的时间复杂度或为0 0的，或为 00d。g的，其中00的是它的上界，那么00d。g月）是否是它的下界，也就是说，能否找到一种排序方法，它在最坏情况下的时间复杂度低于0（司。g的呢？
由于本章讨论的各种排序方法，除基数排序之外，都是基于“关键字间的比较”这个操作进行的，则均可用一棵类似于图0 16所示的判定树来描述这类排序方法的过程。图1生16描述排序过程的判定树
图10．16的判定树表示3个关字分别为和&的记录进行直接插人排序的过程，树中每个非终端结点表示两个关键字间的一次比较，其左、右了树分别表示这次比较所得的两种结果、假i殳K。凵《学：KS关，则排序之前依次排列的这3个记录00 的，R, ;之间貞可能有下列6种关系：0）& <和< (2)KI<K3<K2；（3）1<3 < KI K? i（4）K? < K《< 1<3；（5）〈，KS <；（6）K' < < Kl，换句话说，这3个记录经过排序只可能得到下列6种结果：（l ) { &．&，&吓（2）{ &，&，& }；（3月&，R。&
（4独&，蛰，& }；（5月&，&，&吓（6月&，碴，RI }，而图10．1 6中的判定树上6个终端绿点恰好表示这6种排序结果。判定树上进行的每一次比较都是必要的，因此，这个判定树足以描述通过“比较"进行的排序过程。并且，对每一个初始序列经排序达到有序所需进行的“比较"次数，恰为从树根到和该序列相应的叶子结点的路径长度。由于图也16 的判定树的深度为4，则对3个记录进行排序至少要进行3次比较。
推广至一般情况，对”个记录进行排序至少需进行多少次关镩字间的比较，这个问题等价于，给定个不同的砝码和一台天平，按重量的大小顺序排列这些砝码所需要的最少称重量次数问题。由于含个记录的序列可能出现的初始状态有利个，则描述月个记录排序过程的判定树必须有个叶子结点。因为，若少一个叶子，则说明尚有两种状态没有分辨出来。我们已经知道，若二叉树的高度为九，则叫子结点的个数不超过2一；反之，若有个叫子结点，则二反树的高度至少为「g' 0。这就是说，描述靛个记录排序的判定树上必定存在一条长度为自og ”！刃的路径。由此得到下述结论：任何一个借助“比较"进行排序的算法，在最坏情况下所需进行的比较次数至少为冂：！月。然而，这只是个理论上的下界，一般的排序算法在> 1所需进行的比较次数均大于此值，直到
· 2 9 1
19到年， 比 性 T)亠u山 首先找到了对 5 个数进行排序只需要 7 次比较的方法 之后 ， Lester Ford和Selmer Johnson将其推厂，提出了归并插人叭M ““ ]门s “前的排序，在
” < Il时所用的比较次数和「喱！月相同。0。根据斯特林公式，有i玉0一 00№罗1)，上述结论从数量级上告诉我们，借助于“比较"进行排序的算法在最坏悄况下能达到的最好的时同复杂度为00d。“）。山归并插人排序的过程谓参见题集第章中最后一题·
下表中猕M（的和F(n)分别表示对个数进行忻半插人排序、归并排序和归并插人排序时在最坏情况下
所进行的比较次。出第11章外部排序
上一章中已提到，外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，在排序过程中需进行多次的内、外存之间的交换。因此，在苹章讨论外部排序之前，首先需要了解对外存信息进行存取的特点。
1L 1外存信息的存取
汁算机一般有两种存储器：内存器（主存）和外存储器（辅存）。内存的信息可随机存取，且存取速度快．但价格贵、容量小。外存储器包括磁带和磁盘（或磁鼓），前者为顺序存取的设备，后者为随机存取的没备。
磁带信息的存取
磁带是薄薄涂上一层磁性材料的一条窄带。现在使用的磁带大多数有02英寸宽，最长可达3 600英尺，绕在一个卷盘上。使用时，将磁带盘放在磁带机上，驱动器控制磁带盘转动，带动磁带向前移动。通过读/写头就可以读出磁带上的信息或者把信息写人磁带中《图
在2英寸宽的帶面上可以记9位或7位二进制信息（通常称为9道带或7道带）。以9道带为例，每一
横排就可表示一个字符（8位表示、个字符，另一位作奇偶校验位）。因此，磁带上可记下各种文字信息或二进制信息。在磁带上信息按字符组山存放，而不是按字符存放
磁带上信息的密度通常为每英寸800位或1 6 00位或6250位（即每英寸的二进制字符数），移动速度是每秒200英寸。
磁带不是连续运转的设备，而是一种启停设备（启停时间约为5毫杪），它可以根据读．写的需要随时启动和停上。由干读/写信息应在旋转稳定时进行，而磁带从静止状态启动后，要经过一个加速的过程才能达到稳定状态，反之，在读/写结束后，从运动状态到完全停上，要经过一个减速的过程。因此，在磁带上相邻两组字符组（记录）之间要留一空白区，叫做间嚓IRG(Inter Record Gap)n根据启停时间的需要，这个间隙通常为10、3
英寸。如果每个字符组的长度是80个字符，] RG为3 / 4英寸，则对密度为每英寸1 600 个字符的磁带，其利用率仅为1 ' ] 6，有巧06的带用于] RG（参见图1L 2（a））。
为了有效地利用磁带，常常用组成块的办法来减少IRG的个数“在每次写信息时，不是按用户给出的字符组记人磁带，而是将若干个字符组合并成一块后一次写人磁带。
于是，每个字符组间就没有] RG．而变成块间的间隙IBG（Inter Blo Gap珧图IL 2(b)卩彳符在操作统的一些描述中疒记录过注意：操作系统屮的记录'不同于本书前面定义的记录
293
IRG
IRG
20个记录丨《20，忄记录t?G 20个记录IBC,
图比2嵫带L信息存放示意图
巛〕字符组长訓的带；()}成块存放的带
表示将20个长度为80字符的亨符组存放在迄带上的一个物理块中的情况。
成块的办法可以减少IRO的数目，从而可以提高磁带的利用率，块的长度大于IBG 的长度·
成块还可减少] 0操作。因为一次I/O操作司把整个物理块都读到内存缓冲区中，然后再从缓冲区中取出所需要的筒息（一个字符组）。每当要读一个字符组时，首先要查缓冲区中是否已有，若有．则不必执行00操作，直接从缓冲区读取即可。
软件要有处理成块、解块和保存字符组的功能。在使用者看来，每次读／写的却只是一个字符组
是否物理块越大，数据紧凑，效率就越高呢？实际上不是这样的。物理块不能太大．通常只有I K字节一8K字节。这是因为如果次读写太长，则出错的概率就增人，可靠性就降低；此外，若块太大，则在内存开辟的缓冲区就大，从而耗费内存空间也多。
在磁带上读写一块信息所需的时间山两部分组成：其中0 “为迟时间，读《与头到达传输信息所在物理块起始位置所需时回；/ “为传输个字符的时间。
显然，延谌时间和信息在磁带上的位置、当前i写头所在位置有关。例如，若读《写头龕第，和第凵刁个物理块之间的间隙上，则读第韧．个物理块上的信息仅需几辜秒；若读《写头位于磁带的始端，而要i卖的信息在磁带的尾端，则必须使磁带向前运动，跳过中间的许多块．直到所需信息通过汝，'写头时才能得到，这可能需要几分钟的时间。因此，由于磁带是顺序存取的设备，则读写信息之前先要进行顺序查找，并且当读/写头位于磁带尾端，而要读的信息在磁带始端时·尚需使磁带倒转运动。这是顺序在取设备的主要缺点，它使检索和修改信息很不方便。因此，顺序存取没备主要用于处理变化少、只进行顺序存取的大量数据。
2．磁盘信息的存取
磁盘是一种直接存取的存储没备山ASD），它是以存取时间变化不大为特征的。它不像磁带那样只能进行顺序存取．而可以直接存取任何字符组。它的容量人、速度快，存取速度比磁带快得多：磁盘是一个扁平的圆盘（与电唱机的唱片类似），盘面十有许多称为磁道的圆圈，信息就记载在磁道0由．于磁道的圆圈为许多同心圆，所以可以直接存取。磁盘可以是单片的，也可以由若盘片组成盘组。每一片有两个面。以6片盘组为例．由十最顶上和最低下盘片的外侧面不存信息·所以总共只有10个面可用来保存信息，如图1 1. 3所示
磁盘驱动器执行读写信息的功能。盘片装在一个主轴]，并绕主轴高速旋转，当磁 2 9 4道在读写头下通过时．便可以进行信息的以与。
可以把磁盘分为固定头盘和活动头盘。固定头盘的一道上都有独让的磁头．它是固定小动的．专负责读．写某道上的信息。
活动头盘的赃头是可移动的、 ，盘组也是可变的。一个面上只有个磁头，它可以从该曲上的一道移动到另一道。磁头装在一个动臂匕．小同血上的磁头是同时移动的，并处十同一圆杜面上。各个面上半径相同的磁道组成一个圆柱血，圆柱面的个数就是盘片面上的磁道数。通，每个面上亻j 200。“ 1佣道。在磁盘上标明一个具体信息必须用一个维地址柱面号、盘面月、块号：
其中，柱面号确定读/写头的径向运动，而块号确定信息在盘片圆圈上的位置。
为了访问．块信息，首先必须找柱面，移动臂使磁头移动到所需柱面上（称为定位或冒查）；然后等待要访问的信息转到磁头之下；最后，读/写所需信息。
所以，在磁盘上读写一块信息所需的时间山3部分组成：其中：' “为寻查时间（seek lim的．即读@写头定位的时间；
存取装置
图11 . 3活动头盘示意图鱺为等待时间巛、“ y前@，即等待信息块的初始位置旋转到读写头下的时间；
o、为传输时间(tra小这s山自。
由于磁盘的旋转速度很快，约2、i前、3 600转/分，则等待时间最长不超过25毫秒（旅转一的时间丿，磁盘的传输速率一般在1（了字符/秒和5 × 0字符/秒之间，则在磁盘上读／写信息的时间主要花在寻杳时间十（其最大寻查时间约为0．1秒）。因此，在磁盘上存放信息时应将相关的信息放在同一柱面或邻近柱面上，以求在如写信息时尽量减少磁头来回移动的次数，以免不必要的冒查时间。
1 1 . 2外部排序的方法
外部排序基本上由两个相对独立的阶段组成。当先，按可用内存大小，将外存L含个记录的文件分成若于长度为／的子文件或段（segment)，依次读人内存并利用有效的内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写人外存，通常称这些有序子文件为归并段或顺串（．山然后，对这些归并段进行逐趟归并，使归并段（有序的子文件）逐渐由小至大，直至得到整个有序文件为止。显然，第一阶段的．．L作是上一章己经讨论过的内容。本章主要讨论第一阶段即归并的过程。先从一个具体例子来看外排中的归并是如何进行的
假设有一个含000个记录的文件，首先通过10次内部排序得到10个初始旧并段 R蜘，其中每一段都含以00个记录。然后对它们作如下图所示的两两归并．直至得到一个有序文件为止。
RIt
有序交付
从上图可见，由个初始归炸段到一个有序文件，共进行了4归葑，每一从个归并段得到‰了个归并段。这种归并方法称为2一路平衡归并。
将两个有序段归并成一个有序段的过程，若在内存进行，则很简钽于一章中的 merge过程便可实现此归并冫卩是，在外部排序中实现两两归并时，不仅要调用m “ ge 过程，曲且要进行外存的读写，这是由于我们不可能将两个有序段及归葑结果段同时存放在内存中的缘故。在] 1．05中已经提到，对外存上信息的读／写是以“物理块”为单位的。假设在例中每个物理块可以容纳200个记录，则每一归并需进石到次“读，和50次“写”，4归并加上内部排序时所需进行的读/写使得在外排中总共需进行500 次的读下写“
一般情况下，
外部排序所需总的时间内部排序（产生初始归并段）所需的时间00十
外存信息读写的时间×嗝）+ 内部归并所需的时间（0钮）
其中：是为得到一个初始归并段进行内部排序所需时间的均值；是进行一次外存读／写时间的均值；“是对“个记录进行内部归并所需时间；m为经过内部排序之后得到的初始归并段的个数0为归并的数为总的读．'写次数。由此，上例10佣0个记录利用2．路归并进行外排所需总的时间为：
10嫲的5的00．1到× ] 0 0000
其中岫取决于所用的外存设备，显然山较后要大得多。因此，提高外排的效率应主要着眼于减少外存信息读写的次数
下面来分析d和“归并过程”的关系。若对上例中所得的10个初始归并段进行5一路平衡归并（即每一趟将5个或5个以．下的有序子文件归并成一个有序子文件），则从一卜图可见，仅需进行的趟归并，外排时总的读/写次数便减至2 × ] 00 + 100一300，比2一路归并减少了200次的读0引南宁文件
可见·对同一文件而凵．进fi外排时所需读写外存的次数和归并的趟数、成止比。
· 296
而在一般情况下，对个初始归丿亻段进行路平衡归并时，归力的数可见，若增加或减少便能碱少“．卜面分别就这两个方面讨论之。
让3多路平衡归并的实现
从式口]一2）得知，增加々卩」以减少、，从角减少外存读写的次数。但是．从下面的i寸论中又可发现，单纯增加差将导致增加内部归并的时间“，，“那么，如何解决这个矛盾呢？
先石2一路归并。令“个记录分布在两个归并段上，胺m ““过程进行归并。每得到归并后的一个记录．仅需一次比较即可．则得到含“个记录的归并段需进行“一]次比较冉看差路归并：令“个记录分布在个归并段上，显然，归并后的第一个记录应是差个归并段中关鍵字最小的记录，即应从每个归并段的第一个记录的相互比较中选出最小者，这需要进行一1次比较。同理，每得到归并后的有序段中的一个记录，都要进行一1 次比较。显然，为得到含“个记录的归并段需进行一0 (k一0次比较。由此，对门个记录的文件进行外排时，在内部归过程中进行的总的比较次数为$一的一l)。假设所得初始归并段为m个，则山式口1 i刂得内部归并过程中进行比较的总的次数为
[log@0以一00一00 L 10iogek甌m
由于 随差的增长而增长，则内部归并时间亦随差的增长而增长。这将抵消由于增大而减少外存信息读写时间所得效益．这是我们所不希望的“然而，若在进行0路归并时利用“败者树以Tr@鼠I.。$ “〕，则可使在差个记录中选出关键字最小的记录时仅需进行g以」次比较，从而使总的归并时间由式003）变为山“到0冖0 ‰，显然，这个式羊和差无关，它不再随差的增长而增长。
那未，什么是“败者树”？它是树形选择排序的一种变型。相对地，我们可称图也8 和图也9中的二叉树为“胜者树”，因为每个非终端结点均表示其左、右孩子结点中的“胜者"。反之，若在双亲结点中记下刚进行完的这场比赛中的败者，而让胜者去参加更高一层的比赛，便可得到一棵“败者树"。例如，图1L 4（a）所示为一棵实现5一路归并的败者树 ] 0〕一到，图中方形结点表示叶子结点〈也可看成是外结点），分别为5个归并段中当前参加归并选择的记录的关键字：败者树中根结点[ s过！的双亲结点的为“冠军"，在此指示各归丌段中的最小关键字记录为第二段中的当前记录；结点1《3一指示b〕和卜2两个叶子结点中的败者即b2，而胜者bl和（b3是叶子结点b3、b4和b0经过两场比赛后选出的获胜者）进彳」比较，绿点Is · 0则指小它们中的败者为bl。在选得最刁、关键字的记录之后，只要修改叶子结点b3中的值．使其为同一归并段中的下一个记录的关雷字．然后从该结点向上和双亲结点所指的关键字进行比较，败者留在该双亲结点．胜者继续向上直至树根的双亲。如图11. 4（b）所示．当第3个归并段中第2个记录参加归并时，选得的最小关键字记录为第个归并段中的记录。为了防+在归并过程中某个归并段变空，可以在每个归并段中附加个关键字为最大值的记录。当选出的“冠军"记录的关键字为最大值
297 图比1实现5一路归丌的败者树
时，表明此次归并已完成。由丁实现0路归并的，收者树的深度为「怖g? 0十1，则在个记录中选择最小关字仅需进行压种0次比较0收者树的初始化也容易实现，只要先令所有的非终端结点指向一个含最小关腱字的叶子结点，然后从各个叶了结点出发整非终端结点为新的败者即可。
下面的算法性]简单描述利用败者树进行0路归并的过程。为了突出如何利用取者树进行归并，在算法中避升了外存信息存取的细节，可以认为归并段己在内存。算法出2描述在从败者協选得最小关锥字的记录之后，如何从叮到根调整败者树选得下一个最小关键字。算法压3为初建，收者树的过程的算法描述。
typedef int 产败者树是完全二叉树且不含叶了，可采用顺序存储结构 typ?def struct《
Kempe key;
)F.xNOde. F.xternall k士1到 ／/外经点，只存放待归并记的关键字
void队Merge (LoserTree &、External (b) {
／／利用败者树烁将編号从0到k到的k个输人归并段中的记归并到愉出归段、
季bC01至bCk- 0为败者树I-的k个子结点、分别存放个输人归并段中当前记录的关谊字。
For 0 = 0；i<k: + +到 inp门上岫「过．key真 分别从k个输人归并段读人该段当前
//第一个记录的关键字到外结点
CreateLoserTree( (5)； 建败者树Is．选得最小关字为b〔囟№Y
Rhile (bt1sC0」」.key！ MAXKEY)
// q指示当前最小关键'7所在归并段
output（q)； 编号为q的归并段中当前（关键字为b〔qI key }的记录
//写至愉出归并段
№p key'q)： 从编号为q的输人归并段中读人下一个记录的关字 Adjust(lg. q) ;
output（1sLQ的：
}，7 K- rg
· 2 9 8
调郝敷者树·选择新的最小关键字
将含最人关键字Y的记录写至输出归并段
算法I l，]void Adjust (IoscrTree Lis.到{
沿从明子结点瞠到到根结点烁@一自勺路径调者树
．的双亲结点
· 13 [ L “5指小新的性者
》/ Adjust
算法1L 2
0 d CreateLoser%:ee( LoserTree &烁）{
／7己知b@」到bLk一为完全二树15的叶子结点存有k个关键字，沿丛叶子冫'到根的k条路径将Is调整成为者树。
囝k .key MINKEYi设里N卜EY为关字可能的最小值 for 0；；i<ik：+ + i)设置中“败者”的值
for（i = k一]；i冫以：0； //依次从b()- 1坤k一， ，b@」出发调
”郝取者 )// Createl.nser'l'ree
算法1L 3
最后要提及一点訣值的选择并非越大越好，如何选择合适的々是一个需要综合考虑的问题。
1L 4置换、．选择排序
由0．2式得知，归并的数不仅和成反比，也和m成正比，因此，减少m是减少$ 的另条途径。然而，我们从1L 2节的讨论中也得知是外部文件经过内部排序之后得到的初始归并段的个数，显然，”t：‰ '／．1?其中“为外部文件中的记录数，为初始归并段中的记录数。回顾上一章讨论的各种内排方法，在内排过程中移动记录和对关键字进行比较都是在内存中进行的。因此，用这些法进行内部排序得到的各个初始归并段的长度（除最后一段外）都相同，且完全依赖于进行内部排序时可用内存工作区的大小，则 m也随其而限定。山此，若要减少“即增加／，就必须探索新的排序方法。
置换选择啡序(Replacement-se ecuon Sorting )是在树形选择排序的基础上得来的，它的特点是：在整个排序（得到所有初始归并段）的过程中，选择最小（或最大）关腱字和输人、愉出交又或平行进行。
先从具体例子谈起。已知初始文件含，自2 [个记录，它们的关键字分别为5 1，49，39， 16，38．29．14，6 1，1 5，30，I，4 8，5 2，3，63，2 7，4．13，89，'巧，58，33，76。假设内看工作区可容纳6个记录．则按十章讨论的选择排序可求得如下4个初始归并段
RUN I：29．3 8．3 9 6 g，
299
RUNS : 3，4，1 3 . '
即0湖0 3，1：下，．
若按置换．选进行排序，则可求得如十3个初始归葑段：
RUN堠29，，3 9，9，到,61
RUN?，3，凵，] 5，2 0 3以18，5 2，6 3，89 RI-JN3 : 4，] 3，，3 3：，5，
假设初始苻排文付为输人文件FI，初始归并段文件为输出文件FO，内存工作区为 WA，FO和WA的初始状态为空，并设内存一下作区WA的容量可容纳“个记录，则置换．选择排序的操作过程为，
(1)从F ]输人w个记录到工区WA。
（2） 从WA中选出其中关踺字取最小值的记录，记为MINIMAX记录。
（3） 将M [ NIMAX记录输出到FO中去。
（4） 若FI不空，则从FI输人下一个记录到WA中。
（5） 从WA中所确关键字比M ] NIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。
（6） 京复（3）、（5），直在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。
(7)重复、@，直至WA为空。由此得到全部初始归并段。
例如，以．《所举之例的置换一选择过程如图l l . 5所示。
吓六
5 1，1 9 @ 39 6認趴2 9
凵，61，1 5，30.1，，5 2，3，63，2孙4 0
2 9
5 0 4叭3 9湖6，3 8
1 0 6 t，1 5．30，0 4 5 2，3訪3六
6吓0，30，1，，5 2，3，63 7，私
2 9
的，4 9．3 9，46。38」4
2六翮
到09，3 g 6， 的湖的，3，63，：与，4．
29，38
，4叭3六4 6，6匚凵 吓，30，1．48，52認，63，2 7，
两，，3 9
51，4 ，4 6，6 1，1 4
1 30，1? 48，5 2，3，6 3，27．
51.，巧，4 6 [，1 4
3 1凵8，5 2，3 3 “ 27，4．
2 9，3 8，3 9，4 6
5，，1 5， ，6 1 4
蜘，1，48，5 3
2 9，3 8，3 9，4 6
到0 9 5，30，61.凵 吓48，5 2，3，6 3，27，
1、0
的，3 3的湖9
2叭：．3弘，4 g，5 1
，3 8能4 [
29 ，3 8到 34 ·国9匕51
300
绫表
2叭38、39讞6国叭5匕引
29 8，39 6，，5 1，61.
凸，35，3 9，46，4 9，5〕 ，51，
，巧，3 5 2，凵 3，6 3，
2 9，38，3 9，，4荪5 E匕
图比5置换选择排序过程小例
在WA中选择MIN ] MAX记录的过程需利用“败者树”来实现关于'败者树”本身，上节已有详细讨论，在此仅就置换一选择排序中的实现细节加以说明。0）内存工作区中的记录作为败者树的外部结点，而败者树中根结点的双亲结点指示工区中关键字最小的记录；（2）为了便于选出M ] N ] MAX记录，为每个记录附设一个所在归并段的序号，在进行关键字的比较时，先比较段号，段号小的为胜者；段号相同的则关键字小的为胜者；（3）败者树的建立可从设工作区中所有记录的段号均为“零”开始，然后人Fl逐个榆人“ 个记录到工作区时，自下而上调整者树，由于这些记录的段号为“ l '，，则它们对于“零”段的记录而言均为败者，从而逐个填充到败者树的各结点中去。算法1L 4是置换．选择排序的简单描述，其中，求得一个初始归并段的过程如算法1 1，5所述。算法1 L 6和算法 1L 7分别描述了置换一选择排序中的败者树的调整和初建的过程。
Lyp?d?f {
RcdType ℃0 记录
从记录中抽取的关腱字
int. rnum； 汐所属归并段的段号
} RedN0de，WorkArea到； ／/内存工作区．容量为“
void Replace Selection (LoserTree &，or黼&，FILE f土，FILE { 汐在败者树和内存工作区十用置换．选择排序求初始归并段，0．为输人文件
（只读文件）指针．为输出文件（只写文付）指，两个文件均已打开
Corifit:ruet．0．； 初建敗者树
江指示当前生成的初始归并段的段刂，
/ rm指示中关腱字所属初始归并段的最大段号
*hile（吣< { ，/ ' rc：1"标恚输人文件的换．选择排序已完成 get-run翮）； //求得一个初始归并段
frr?te( &R?NFND．S：」，“。吡邝酰RcdType). 1．(?)；将段结束标恚写人输出文件 re =．〕0订 设置下一段的段号
}彦Replace- $ el ℃ ion
算法 Il．4
void get run（LoserTree & 1雪，WorkArea &）
彦求得一个初始归并段，为输人文件指钅吓f0为输出文件指针
*hile（“a[ 13 [ 0」」． 疒0）{ /选得的“N “鼐记录属当前段时
丿c.指示MIN AX记录在中的位置 ?dlq?key;
fwrite（&剴q]. rec. sizeof( RcdType)，1話0
'将刚选好的耵N“隙记录与人输出文件 if (feofffi))《q《rrm:rn“囟的．key MARKEY } 输人付结束，虚设记（属气帕“ 0段）输，\ 1．非空时
Eread（& RaLq。〔e匚，zeof（Rcd'l'ype)严从人虻件读人下一记录 “、key Ra,_ Cl厂rec key； /7提取关键字 if（a「q」key minimax）{ 新读人的记录园下一段 wal_ ql .
else wal_ql. rnuul》粞人的记星屈当前段
Select. MiniYax 0 “岁选择的N月记录)/// get run
法] I . 5
vo司5e1 0 (LoserTree，NorkArea、旧，int q)（ 从吓过起到取者树的根比较选择N AX记录，并山q指示它所在的归并段 t> 0 1 t．t/2 , p：1sttl) 辽〈[国．rnurn?< wai_q_，rnum “的pl .苤= wa[ql. rnul" & &凶p」，kev<,wa-q)，key） q指示新的胜利者
}岁3国“ t MimMax
法IL 6
void Cot'!还旷刂0 Loser（I Tr（℃ 1 $，而rk r》）{ 输人个记录到内存丁作区“，建得敢者树，出关字最小的记录并山s指示其在“中的位訛
for 0 0；i< + +的
「刂，rnuro = wa[i_l.key = 1sti
for 0 “一i>=山
丝工作区初始化
fread（&橇J00 0e0，eo臼女凿井@，
/7输人一个记录
rec. ke、，；
汐提取关字
其段号为” 1 "
Select. MiniMax〔Is，，i) ;
调整敢名
}，丿Construct I.?ser
算法 it . 7
利用者树对前面例了进行置换一选择排序时的局部状况如图飞l. 6所示，其中图1L 6（的一（g）显示了败者树建过程中的状态变化状况。最后得到最小关钅建字的记录为艹[的，之后．输出wa@．．并从Fi中人卜一个记录至waL0《，由于它的关键字小于刚刚输出的记录的关键字．则设此输人的记录的段号为2（如图] 1. 6（h）所示），而由于在输出wa [嫔之后新输人的关键字较wa [ 0辰y大，则该新输人的记录的段号仍为如图1L 6@所示）。图1L 60所示为在输出6个记录之后选得的M然IMAX记录为
3〔理，
(d) 图1 1 . 6 置换、选择过程中的败者树
～（建立败者树，选出最小关镶字记录wa [明； 儲》一（l)选好新的MINIMAX记录
wa冂]时的败者树。图11. 6（k）表明在输出该记录wa「0之后，由于输人的下．个记录的关键字较小，其段号亦为2，致使工作区中所有记录的段号均为2由此败者树选出的新的MI № MAX记录的段号人刁当前生成的归并段的序号．这说明该段已结束，曲此新的 M ] NIMAX记录应是下一归并段中的第一个记录。
从上述可见．由置换一选择排序所得初始归并段的长度不等。且可证明，当输人文付中记录的关键字为随机数时，所得初始归并段的平均长度为内存工作区大小w的两倍这个证明是E，F，M “ re在] 9胡年从置换。选择排序和扫雪机的类比中得出的
假设一台扫雪机在环形路十等速行进扫雪，又下雪的速度也是均匀的〈即每小时落到地面上的雪量相等），雪均匀地落在扫雪机的前、后路面上，边下雪边扫雪。显然，在某个时刻之后，整个系统达到平衡状态，路面上的积雪总量不变。且在任1可时刻，整个路面上的积雪都形成一个均匀的斜面．紧靠扫雪机前端的积雪最厚，其深度为/吓而在扫雪机刚扫过的路面上的积雪深度为零。若将环形路伸展丌来，路面积雪状态如图1L 7所示，假设此刻路面积雪的总体积为艹环形路一圈的长度为丛由于扫雪机在任何时刻扫走的雪的深度均为辰则扫雪机在环形路上走一圈扫掉的积雪体积为仂即2 “ 将置换、选择排序与此类比，工作区中的记录好比路面的积雪，输出的MINIMAX记好比扫走的雪，新输人的记录好比新下的雪，当关镟字为随机数时，新记录的关键字比 MIN丨MAX大或小的概率相等。若大，则属当前的归并段〔好比落在扫雪机前面的积雪，在这一圈中将被扫走若小，则属下一归并段（好比落在扫雪机后面的积雪，在下一圈中，刁能扫走）。由此，得到一个初始归并段好比扫雪机走一圈。假设工作区的容量为“则置换．选择所得初始归并段长度的期望值便为2 “
容易百出，若不计输人、输出的时间，则对“个记录的文件而訁，生成所有初始归并段所需时间为00 g。
l l. 5最佳归并树
这一节睾词论的问题是，由置换一选择生成所得的初始归并段，其各段长度不等对平衡归并府何影响？
假设山置换．选择得到9个初始归并段，其长度（即记数〕依次为：9，30，0，、3， ] 7，2，6，24。现作3一路平衡归并，其归并树（表示归并过程的图）如图1L 8所示，图中每个圆圈表示一个初始归并段．圆圈中数字表示归并段的长度。假设每个记录占一个物理
块．则两趟归并所需对外存进行的读泻次数为
〔9 + 30 + ] 2 + 18 + 3十旨+ 2 + 6 + 24）× 2 × 2一484
若将初始归并段的长度看成是归并树中叶子结点的权．则此二又树的带权路径长度的两倍恰为484。显然，归并方案不同，所得归并树亦不同，树的带权路径长度（或外存读/写次数）亦不同。回顾在第6章中曾讨论了有”个叶子结点的带权路径长度最短的二叉树称赫夫曼树，同理，存在有个叶子结点的带权路径长度最短的3叉、1叉、“又树，亦称为赫夫曼树。因此，若对长度不等的个初始归并段，构造一棵赫夫曼树作为归并树，便可使在进行外部归并时所需对外存进行的读/'写次数达最少；例如，对上述9个初始归并段可构造一棵如图让9所示的归并树，按此树进行归并，仅需对外存进行4次读下 图庄9 3一路平衡归并的佳归并树 图I l.沣8个归并段的最佳归并树
图] 1 . 9的赫夫曼树是一棵真正的3叉树，即树中只有度为3或0的结点。假若只有 8个初始归并段，例如，在前面例子中少了一个长度为30的归并段。如果在设计归并方案时，缺额的归并段留在最后．即除了最后一次作2．路归并外，其他各次归并仍都是3．路彐并，容易看出此归并方案的外存读/写次数为386。显然，这不是最佳方案。正确的做法是，当初始归并段的数目不足时，需附加长度为零的“虚段"，按照赫夫树构成的原则，权为零的明子应离树根最远，因此，这个只有8个初始归并段的归并树应如图1 0 所示。
那么，如甸判定附加虚段的数目？当3叉树中只有度为3和0的结点时，必有
一1）/ 2、其中满是度为3的结点数，是度为零的结点数。由于必为整数，则到）MOI) 2一0。这就是说，对3一路归并而自，只有当初始归并段的个数为偶数时，才需加1个虚段。
在一般情况下．对卜路归并而言，容易锥算得到，若（m一1) MOD一l )一0，则不需要加虚段．否则需附加差一恸一l) MOD縑一l )一1个虚段。换句话说，第一次归并为 On — I ) MC〕D一1)十1路归并。
若按最佳归并树的归并方案进行磁盘归并排序．需在内存建立一张载有归并段的长度和它在磁盘上的物理位置的索引表。
第] 2章文件
和表类似，文件是大量记录的集合。习惯上称存储在主存储器（内存储器）中的记录集合为表，称存储在二级有储器（外存储器）中的记录集合为文件。本章讨论文件在外存储器中的表示方法及其各种运算的实现方法。
12，1有关文件的基本概念
·文件及其类别
文件山@是由人量性质相同的记录组成的集合。可按其记录的类型不同而分成两类：操作系统的文件和数据库文件
操作系统中的文件仅是一维的连续的字符序列，无结构、无解释。它也是记录的集合，这个记录仅是一个字符组，用户为了存取、加工方便，把文件中的信息划分成若十组，每一组信息称为一个逻辑记录，．且可按顺序编号。
数据库中的文件是带有结构的记录的集合；这类记录是由一个或多个数据项组成的集合，它也是文件中可存取的数据的基本单位。数据项是最基本的不可分的数据单位，也是文件中使用的数据的最小单位。例如，图能1所小为一个数据库文件，每个学生的情况是一个记录，它山蜘个数据项组成“图12．]高考成绩文件
文件还可按记录的另一特性分成定长记录文件和不定长记录文。若文件中每个记录含有的信息长度相同，则称这类记录为定长记录，由这类记录组成的文件称做定长记录文件；若文件中含有信息长度不等的不定长记录，则称不定长记录文件
数据库文件还可按记录中关键字的多少分成咩关键字文件和多关键字文件。若文件中的记录只有一个惟标识记录的主关键字，则称单关键字文件；若文件中的记录除了含 306
有一个主关键字外，还含有若T个次关键字，则称为多关键字文件，记录中所有背关键字的数据项称为记录的属性。
．记录的辑结构和物岬结构
记录的逻辑结构是指记录在用户或应用程序员面前呈现的方式，是用户对数据的表示和存取力式。
记录的物理结构是数据在物理存储器]存储的方式，是数据的物理表示和组织。
通常，i己录的逻辑结构着眼在用户使用方便，而记录的物理结构则应考虑提高有储空间的利用率和减少存取记录的时间，它根据不同的需要及设备本身的特性可以有多种方式。从1 1 . 1节的讨论中已得知：一、物理i己录指的是计算机用一条L的命令进行读写的基本数据单位，对于固定的设各和操作系统，它的大小基本上是固定不变的，而逻辑记录的大小是由使用要求定的。在物理记录和逻辑记录之间可能有在下列3种关系：山个物理记录存放一个逻辑记录。
（2） 一个物理记录包含多个逻辑记录。
（3） 多个物理记录表示一个逻辑记录。
总之，用户读/写一个记录是指逻辑记录，查找对应的物理记录则是操作系统的职责，图地2箭单表示了这种关系。图中的辑记录和物理记录满足上述第一种关系，物理记录之间用指针相铸接
记录E
记录L)
记的逻辑结构
记录的物理构
图比2记录的逻辑结构与物理结构差别示例
·文件的操作（运算）
文件的操作有两类：检索和修改。
文件的检索有下列3种方式：
( l )顺序存取：存取下一个逻辑记录。
（2） 直接存取：存取第i个逻辑记录。
以上两种存取力式都是根记录序号（即记录有人文件时的顺序编号）或记录的相对位置进行存取的。
（3） 按关键字存取给定一个值，查询一个或一批关键字与给定值相关的记录。对数据库文件可以有如下1种查询方式：
o 简单询问 ： 查询关键字等于给定值的记录。 例如 ， 在图 12 ． 1的文件中 ， 给定一个准考证号码或学生爵名，杳甸相关记录。
唧区域询问：查询关键字属某个区域内的记录。例如．在图120的文件中查询某某中学的学生成绩，则给定准考证号的某个数值范围。
o 〕函数询问；给定关字的某个函数疒例如查询总分在全体学生的平均分以上的记录或处于中值的记录。
@布尔询问：以上3种调问用布尔运算组合起来的询问；例如，查询、分在6分以上且数学在100分以上，或者总分在平均分以下的外语在98分以上的全部记录。
文件的修改包括插人一个记录、删除一个记录和更新一个记录3种操作。
文件的操作可以确实时和批量两种不同方式。通常实时处理对应答时间要求严格，应在接收询问之后JL秒钟内完成检索和修改，而批量处理则不然。不同的文件系统其使用有不同的要求。例如，一个民航自动服务系统，其检索和修改都应实时处理；而银行的账户系统需实时检索，但可进行紕量修改，即可以将一天的存款和提款记录在一个事务文件上，在一天的营业之后再进行批量处理。
，文件的物理结构
文件在存储介质（磁盘或磁带冫上的组织方式称为文件的物理结构。文件可以有各种各样的组织方式，其基本方式有3种：顺序组织、随机组织和组织。一个特定的文件应采用何种物理结构府综合考虑各种因素，如：存储介质的类型、记录的类型、人小和关字的数目以及对文件作何种操作等。本章将介绍几种常用的文件的物理结构
以2顺序文件
顺序文件(Seq “ nti引Fi@是记录按其在文件中的逻辑顺序依次进人存儲介质而建立的，即顺序文件中物理记录的顺序和逻辑记录的顺序是一致的“若次序相继的两个物理记录在存储介质上的存储位置是相邻的，则又称连续文件；若物理记录之间的次序山指针相憐表示，则称联文件
顺序文件是根据记录的序号或记录的相对位置来进行存取的文付组织方式。它的特点是：
( 1 )存取第，个记录，必须先搜索在它之前的t一1个记录。
（2） 插人新的记录时只能加在文件的末尾。
（3） 若要更新文件中的某个记录，则必须将整个文件进行复制。
由于顺序文件的优点是连续存取的谏度快，因此主要用于只进行顺序存取、批量修改的清况若对应答时间要求不严时亦可进行直接存取
磁带是一种典型的融序存取设备，因此存储在磁带上的文們只能是顺序文件。磁带文件适合于文件的数据量甚大、平时记录变化少、只作批量修改的情况在对磁带文件作修改时，一般需用另一条复制带栲原带上不变的记录复制一遍，同时在复制的过程中人新的记录和用更改后的新记录代替原记录写人。为了修改方便起见，要求待复制的顺序文件按关键字有序（若非数据库文件，则可将逻辑记录号作为关键字）。
磁带文件的紕处理过程可如下进行：
待修改的原始文件称做主文件．存放在一条磁带上·所有的修改清求集中构成一个文 308
求
终端
字；记录按关键字从小到人序排列。一天的存人和支出集中在一个事务文件中，事务文件也按账号排序，
图120 磁带文件处理示意图
件，称做事务文件，存放在另一台磁带1，尚需第三台磁带作为瓤的主文件的存储介质主文件按关键字自小至大（或自大至小》顺序序，事务文件必须和主文件有相同的序关系。因此，首先对事务文件进行排序，然后将主文件 修改请和事务文件归并成．个新的l-文件图] 2，3为这个过程的示意图。在归并的过程中，顺序读出主文件与事务文件中的记录，比较它们的关字分别进行处理；对于关腱字不匹配的主文们中的记录，则直接将其写丿、新主文件中。“更改，'和“删去”记录时，要求其关键字相匹配。“删去”不用写人，曲“更改”则要将更改后的新i己录写人新主文件。“插人”时不求键字相匹配，叫直接将事务文件[要插人的记录写到新主文件的适当位置。
例如有一个银行的账目文件；其主文件保存着各储户的存款余额；每个储户仵为．个记录，储户账号为关
成批地更改主文件并得到一个新的主文件．其过程如图
1 2．4所示。
主文件
新主文件
0
帥复制
巪5
金额78
账号5
余额78
账号0 余额
账号8
余额100
余颞95
余75
余额360
账弓14 余133
账号吓
余额200
余额360
账号20 余额510
账号20 余510
人
账弓2《余额60
存取取
25
存取存
38
账号18 存取取
200
存取俘
事务件
图] 2、4锒行账自文件成批修改示意图
批处理的示意算法如算法120所示。算法中用到的各符号的含义说明如下：
主文件；g一．一事务文件；h一一一新主文件。上述二者都按关腱字递增排列：事务文件的每个记录中，还增设一个代码以示修改要求，其中：“ 1 "表示插人；“ D "表示删去“ U ”表示史改。
void MerqeF1〕0 i FILE “ F . i门《卫q. FILE．）{ 由按关字递增有序的空顺序文件f和g归并得到新文件h．三个文件均已打
／／叶，其屮和g为只读文件，文件中各附加一个最大关键字记录，且g文件中对该记录的臊作为插丿、。h为只写文件。
fread（&fr, f（RcdType)，]，f）； tread（&gr. $土eof（RcdType>．1，刂）， while〔！后到00卩！f00枞中j
case ft. key<gr.key; 复制“旧”主文件中记录 fwrite（&?fr. sizeof( RcdType)，]，h if（匯eof（0）fread（bfr. sizeof(RcdType)，〕，f）；e “
，code ' 0 key;= gr.key; 删除“旧”主文件中记录，即不复制辽( !feof(f)) [r（&，sizeof(ftcdType)t 1，f）；计（！f00 g的Eread（&qr , sizeof( Rcd'l'ype)，]，刂break; case gr. e “生I' & fr, key>gr.keyg 插人，数p把丆加工为h的结构
〔框e（以(r)，gizeof(@cdtype)，1，h后
0 f00f（巾）freod（&qr，gizeof(Recffype)，吓g月沅eak；江&&- fr.keyr= gr.key： //史改“旧”主文件中记录
《00i山0，0f0 CIT囀，0，h）；
o数Q将fr和豇归成一个结构的记 if ( !feof(f) ) fread《&fr, sizeof(RcdType)、]，f后 if ( !feo g fread（&刂r、0 RedType)，丛刂月bre； default ERROR( //其他均为出错情况 } while 是／MergeFiVe
箅法12．1
分析批处理算法的时间。假设主文件包含烈个记录，事务文件包m个记录。一般情况下，事务文件较小，可以进行内部排序，则时间复杂度为0（m ] m）。内部归的时间复杂度为00斗诩，则总的内都处理的时间为00№ gm +的。假设所有的输人，输出都是通过缓冲区进行的，并假设缓冲区大小为s（个记录），则整个批处理过程中读，写外存的次数为2 ·「]
磁盘E的顺序文件的批处理和磁带文件类似，只是当修改项中没有插人．且更新时不增加记录的长度时，可以不建立新的主文件，而直接修改原来的文件即可。显然，磁盘山此数为考虑全部修改项为插八时的上界。
文件的批处理用以在一台磁盘组下进行。
对顺序文伢进行顺序查找类似十第9章讨论的顺序查找，只平均查找长度为 0白以2，其中为文件所含物理记录的数目（相对外存读写而言，内存查找的时间可以忽略不计丿。对磁盘文件可以进有分块查找或折半查找（对不定长文件不能进行折斗查找)a但是，若文们很大，在磁盘上占多个柱面时．折半查找将引起磁头来回移动．增加寻查时间。
假若某个顺序文件，其记录修改的频率较低，则用批处理并不适官，此时可另建立一个附加文件，以存储新插人和虫新后的记录，待附加文件增大到一定程度时冉进行挝理。在检索时可以先查主文件，若不成功再查附加文付，或反之。显然这将增加检索的时间，但可以采取其他措施补之，详细情况可参阅参考书目03 ]。
12．3索引文件
除了文件本身（称做数据区）之外，另建立一张指示逻辑记录和物理记录之间一一刈应关系的表一一索引表。这类包括文件数据区和索引表两大部分的文件称做索引文件。
图1 2．5所示为两个索引表的例子。索引表中的每一项称做索引项。不论主文件是否按关键字有序，索引表中的索引项总是按关键字〈或逻辑记录号）顺序排列。若数据区中的记录也按关键字顺序排列，则称索引顺序文件。反之，若数据区中记录不按关键字顺序排列，则称索引非顺序文件。辑记录号
标物理记录号
0
3
4
10
关讨字《
物理记录号
1国
1 ] 9
12 3
] 25
04
图12．3索引表示例
索引表是由系统程序自动生成的。在记录输人建立数据区的同时建立一个索引表，表中的索引项按记录输人的先后次序排列，待全部记录输人完毕后再对索引表进行排序。例如，对应于图12．6（a）的数据文件．其索引表如图12．60）所示，而图12．6佞）为文件记录输人过程中建立的索引表。
索引文件的检索方式为直接存取或按关键字（进行简单询问）存取，检索过程和第9 章时论的分块查找相类似，应分两步进行：先，查找索引表，若索引表上存在该记录，则根据索引项的指示读取外存丨该记录；否则说明外存[不存在该记录，也就不需要访回外存。由于索引项的长度比记录小得多·则懣常可将索引表一次读人内存，由此在索引文件中进行检索只访问外存两次．即一次读索引，一次读记录。并且由于索引表是有序的，则查找索引表时可用折半查找法o标烦指示该逻辑记录是存在，着存在，则际识符为鬥"，否劁为“ n "
．羊键字物理记录号
关字
物理记录号
] U 8 1忙
] 04
109
图1 2．6索引非顺序文件示例
《的文件数据区；（b冫引表；@怖人过程中建立的索引表
索引文件的修改也容易进行。胤除一个记录时，仅需删去相应的索引项叾插人一个记录时，应将记录置于数据区的末尾，同时在索引表中插人索引项；更新记录时．应将更新后的记录置十数据区的末尾同时修改索引表中相应的索引的10
当记录数目很大时，索引表也很大，以致一个物理块容纳不下。在这种情况下查阅索引仍要多次访问外存。为此，可以对索引表建立一个索引，称为查找表，假设图12．6（的的索引表需占用3个物理块的外存，每．个物理块容纳3个索引，则建立的查找表如图12．7所示。检索记录时．先查找查找表，冉查索引表，然后读取记录。3次访问外存即可、若查找表中项目还多，则可建立屮高一级的索引。通常最高可有四级索引：数掘文件一索引表一香找表艹第二查找表．～第过查找表。而检索过程从最高一级索引即第。查找表开始．仅需5次访问外存。
上述的多级索引是种静态索引，各级索引均为顺序表结构。其结构简单，但修改很不方便，每次修改都要重组索引。因此，当数据文件在使用过程中记录变动较多时，应采用动态索引。如二又排序树（或．二叉平衡树）、佐树以及树，这些都是树表绿构，插人，删除都很丿丿便。又山丁它本身是层次结构，则无需建立多级索引．而且建立索引表的过程即排序的过程。通常，当数据文件的记录数不很多，内存容量足以容纳整个索引表时可采用二叉排序树（或平衡树）作索引，其查找性能已在第9章中进行了详细讨论。反之．当文件很大时，素引表（树表）本身也在外存、则查找索引时尚需多次访问外存，并且．访问外存的次数靥为查找路径上的结点数。显然，为减少访问外看的次数，就应尽量缩减索引表的深度，因此，此围宜采用m叉的B一树作索引表。m的选择取决十索引项的多少和缓冲区的人小。又．从 “ 9．2．笮键树"的讨论可见，腱树适用于作某些特殊类型的关键字的索引表。和匕述对排序树的i寸论类似，当索引表不大小吓可采用双镒表作存储结构（此时索引表在内存〕；反之，则采用T rie树。总之，山图] 2过图．餼的中索引的索引 丁访问外疗的时间比内存查找的日刂回大得多，所以
对外存中索引表的查找效能主取决于苟问外存的次数．即索引表的深度。
显然，索引文件只能是磁盘文件、
综上所述、山于数据文件中记录不按关踺字顺序罚列，则必须对每个记录建冫一个索引项，如此律立的索引表称之为稠密索引．已的特巛是可以在索引表中进行“预杳找六即从索引表便可确定待查记录是否存在或作某些逻辑运算。如果数据文件中的记录按关键字顺序有序，则可对，组记录建立．个索引项，这种索引表称之为非稠密索引，它不能进行 “查找"，但索引表占用的存储空间少，管理要求低。下一节将介绍两种有用的索引顺序文@
12，4 ISAM文件和VSAM文件
12，4．ISAM文件
索引顺序存取方法ISAM为Indexed $四戕司Access Methed的缩写，它是一种专为磁盘存取设计的文件组织方式。山于磁盘是以盘组、柱面和磁道0级地址存取的设备，则可对磁盘上的数据文件建立盘组、柱面和磁道《了三级索弓吓文件的记录在同一盘绀上存放时，应先集屮放在一个柱面L，然后再顺序存放在相邻的柱面上，对同一柱面，则应按盘面的次序顺序存放。例如图[ 2，8为存放在一个磁盘组上的ISAM文，每个柱面建立个磁道索引，每个磁道索引项由两部分组成：基本索引项和溢出索引项．如图] 2．9所示，每一部分都包括关键字和指钊两项，前者表示该磁道中最末一个记录的关键字（在此为最大关字不后者指示该磁道中第一个记录的位置，且确索引的每一个索引项也山关 i建字和指针两部分组成，前名表示该柱面中最末一个记录的关字（最人关字只后者指示该柱面上的磁道索引位置。面索引存放在某个柱山上．若柱面索引较大，占多个磁道时，则可建立柱面索引的索引主索引。
在ISAM文件上检索记录时，先从主索引出发找到相应的柱面索引，再从拄面索引找到记录所在柱面的磁道索引．最后从磁道索引找到记录所在磁道的第．个记录的位置．山此出发在该磁道上进行顺序查找直至找到为止；反之，若找该磁道血不存在此记录，则表明该文件中无此记录。例如，查找关键字为21的记录时的查找路径如图12．8中的粗实线所示。
从图12．8中读名可看到，每个拄确还开辟有一个溢出区；并且，磁道索引项中有溢出索引项，这是为插人记录所设置的。由于] SAM文件中记录是按关字顺序存放的，则在插人记录时需移动记星、并将同一磁道上最末一个记录移至溢出区，同时修改磁道索引项。通常溢出区卩」有3种设置方法；0）集中存放一．一整个文件设一个大的单一的溢出区；（2）分散存放一一每个柱面没，个溢出区；（3〕集中与分散相结合．一溢出时记录先移至每个柱面各自的溢出区，待满之后再使用公共溢出区，图12．8是第二种设置法。
每个面的基本区是顺序存储结构，而溢出区是链表结构。同一磁道溢出的记录由为运里的磁道引，实际盘面索引．为循习惯仍称磁道索引
柱面
柱面Cn
匚巫0]二》
基本索引项 溢出索引项
图0．9磁道索引项结构
指针相链．该磁道索引的溢出索引项中的关键字指示该磁道溢出的记录的最大关键字；而指计则指示在溢出区中的第一个记录图12．@所示为插人记录和溢出处理的具体例子。其中（的为插人前的某一柱而上的状态；〔b）为插人R “时．将第二道中关键字大丁65 的记录顺冰后移使謚出至溢出区的清况沤0为插人RU之后的状态、此时2道的基车索引项的关键字改为80，且溢出索引项的关键字改为90，其指针指向第，1道第一个记录即&。（的是相继插人R和R地后的状态，R湖山人在第3道的第一个记录的位置面使& “溢出。而由于80乊83 < 90．则R被直接插人到溢出区，作为第2道在溢出区的第 “个记录，并将它的指针指向R,?的位置，同时修改第2道索引的溢出索引项的指针指向& 3凵
基索引项 溢出索引种 基本索引项 滸出索引项
市索引
，基革区
'4出区
插人记录 基本区溢出区
；基本区瑶溢出区
90
] 4 5
Ti
基本区以溢出区
图胃．ISAM文件的插人和溢出处理
(a)插人前；（b）插人R葫时记录移动的情形；(e)插人R后以山先插人R ”再插人R后
ISAM文件中删除记录的操作要比插人简单得多，只需找到待删除的记录，在其存储位置十作删除标记即可，而不需要移动记录或改度指针，但在经过多次的增删后，文件的结构可能变得很不合理。此时，大量的记录进人溢出区，而基本区中又浪费很多空间。因此，通常需要周期地整理ISAM文件。把记录读人内存，重新排列，复制成一个新的
] SAM文件，填满基本区而空出溢出区。
最后，我们简单讨论 下] SAM文件中柱曲索引的位置
通常，磁道索引放在每个柱面的第一道匕，那么，柱面索引是否也放在文件的第一个
柱确呢？山上每一次检索都需先查找性面索引，则磁头需在各柱面间来回移动、我们希望磁头种动胩离的平均俏最小，的设文件占有个村面．甘而索引在第0主曲．0则磁头移动距离的平均值为
一D扩@一才）
勖十 1)
亠0上十
2
令訂(d、)一0，得到彐 、这就是说，拄面索引应放在数据文件的中间位置的柱曲0
12，4 · 2 VSAM文件
虚拟存储存取方法VSAM是Virtual Storage Access Method的缩写。这种存取法利用了操作糸统的虚拟存储器的功能，给用户提供力便。对用户来说，文件只确控制区间和控制区域等逻辑存储单位，与外存储器中拄面、磁道等具体存储单位没有必然的联系。用户在存取文件中的记录时，不需要考虑这个记录的当前位置是否在内存，也不需要考虑甸时执行对外存进行“读下写”的指令、
VSAM文件的结构如] 2，凵所示。它由3部分组成：索引集、顺序集和数据集。图] 2．Il VSAM文件的结构示意图
文件的记录均存放在数集中，数据集中的一个结点称为控制区间（Contr田Interval ) ?它是一个，0操作的基本单位，它由一组连续的存储单元组成。控制区间的大小可硨文件不同而不同，但同一文件上控制区间的大小相同。每个控制区间含有一个或多个按关键字递增，台序排列的记录。顺序集和索引集一起构成一棵B．树．为文件的索引部分。顺序集中存放每个控制区间的索引項。每个控制区间的索引项由两部分信息组成，即该控制区间中的最大关键字和指向控制区间的指针。若干相邻控制区间的索引项形成顺序集中的一个结点，结点之间用指针相链结，而每个结点又在其上一层的结点中建有索引，且逐层向上建立索引。所有的索引项都由最大关鍵字和指针两部分信息组成，这些高层的索引项形成B一树的非终端结点。因此? VSAM文件趼可在顺序集中进行顺序存取，又可从最高层的索引（B '树的根结）出发进行按关键字存取。顺序集中一个结巛连同其对应的所有制区间形成一个整，称做控制区域（Control Range)e每个控制区间可视为个逻辑磁道，而每个控制区域可视为一个逻辑柱面。
在V,SAM文件中，记可是不定长的，则在控制区问中除了存放记录本身外．还
有每个记录的控制信息（如记录的长度等）和整个区间的控制信息（如区间中存有的记录数等），控制区间的结构如图之12所示。在控制区间上存取一个记录时需从控制区间的两端出发同时向中间扫描。
记录
未利用的
空闱空间
id录的
控信息
记录1 的
，控制信息
控制区间
控制信息
图1杰口控制区间的结构示意图
VSAM文件中没有溢出区．解决插人的办法是在初建文件时留有空间。一是每个控制区间内不填满记录．在最末一个记录和控制信息之间留有空隙；二是在每个控制区域中有一些完全空的控制区间，并在顺序集的索引中指明这些空区间。当插入新记录时，大多数的新记录能插人到相应的控制区间内，但要注意为了保扌寺区间内记录的关键字自小至大有序，则需将区间内关键字大十插人记录关键字的记录向控制信息的方向移动。若在若干记录插人之后控制区间已满，则在一卜一个记录插人时要进行控制区间的分裂，即将近乎一半的记录移到同一控制区域中全空的控制区间中，并修改顺序集中相应索引。亻尚若控制吓域中已经没有全空的控制区间，则要进行控制区域的分，此时顺序集中的结点亦要分裂岫此尚需修改索引集中的结点信息。但由于控制区域较大，很少发生分裂的情况。
在VSAM文件中删除记录时．需将同一控制区间中较删除i己录关踺字大的记录向前移动，把空间留给以后插人的记录。若整个控制区间变空，则需修改顺序集中相应的索
山此可见，VSAM文件占有较多的有储空问，一般只能保持约7 5 ‰的存储空间利用率。但它的优点是：动态地分配和释放存储空间，不需要对文件进行重组，并能较快地对插人的记录进行查找，查找一个后插人记录的时间与查找一个原有记录的时间是相同的。
为了作性能上的优化，VSAM用了一些其他的技术，如指针和关踺字的压缩、索引的存放处理等。其详情读者可参阅参考书目0到。
12．5直接存取文件（散列文件）
直接存取文件指的是利用杂凑（H D法进行组织的文件。它类似于哈希表，即根据文件中关键字的特点设计一种哈希函数和处理冲突的方法将记录散列到存设备上．故又称散列文件。
与哈希表不同的是，对于文件来说，磁盘上的文件记录通常是成组存放的。若f个记录组成一个存储单位，在散列文件中，这个存储单位叫做（B “ket）。假若一个桶能存放忉个记录，这就是说，忉个同义词的记录可以存放在同一地址的桶中，而当第+ 1个司义词出现时才发生“溢出”。处理溢出也可采用哈希表中处理冲突的各种方法，但对散列文件，主要采用链地衄法。
当发生“溢出”时．需要将第一1过个同义词存放到另一个桶中，通常称此桶为“溢出桶”：相对地，称前个同义同存放的桶为“基桶”。溢出桶和基桶大小相同，相互之间用指针相链接。当在基桶中没找到待查记录时，顺指针所指到溢出桶中进行查找。因此，希望同一散列地的溢出桶和基桶在磁盘上的物理位置不要相距太远，最好在同一柱面以例如，某一文件有1 8个记录，其关键字分别为2 78，109，0 6 3，9 3 0， 5 8 9，1 8邃，5 05，25 9，008，08 3，] 6．1，2巧．3 3 0，8 1 (〕，6图，后0，384，3 5 5。桶的容量一3，桶数／冖7。用除留余数法作哈希函数H(key)=key MOf) 70由此得到的直接存取文件如图] 2，0所示。
在直接文件中进行查找时，首先根据给定值求得哈希地址（即基桶号），将基桶的记录读人内存进行@序查找，若找到关腱字等于给定值的记录，则检索成功；否则，若基桶内没有填满记录或其指针域为空，则文件内不含有待查记录；否则根据指针域的值的指示将溢出桶的记录读人内继续进行顺序查找，直至检索成功或不成功、因此，总的查找时间为：
T亠云在+／0
其中为存取桶数的期望值（相当于哈希表中的平均杳找长度），对镀地址处理溢出来说= 0卜流为存取一个桶所需的时间为在内存中顺序查找一个记录所需时间。
仅为装载因子，在散列文件中
其中为文件的记录数泌为桶数on为桶的容吊。显然，增加m可减少吓也就使减小，此时虽则使增大，但山于五，0 > 0，则总的时间T仍可减少。图12．凵展示了和a 的关系。
在直接存取文件中删除记录时，和哈希表一样，仅需对被删记录作一标记即可。
桶编号
溢出柚
0
063
184
5
505
開8
330
26g
164
1Q9
620
278
2巧
810
110
3
93C
083
384
A
2
4
5
图]：03直接存取文件示例 图柚的容量和查找次数的关系
总之，直接存取文件的优点是：文件随机存放，记录不需进行排序》插人、删除方便．存取速度快，不需要索引区．节省存储空间：其缺是：不能进行顺序存取，只能按关键字随机存取，且询问方式限于简单询间．并且在经过多次的插人、删除之后，也可能造成文件结构不合理，即溢出桶满而基桶内多数为被删除的记录、此时亦需重组文件。
3吓·
之6多关键字文件
多关键字文件的持点是在刈文件进行检索操作时，不仅对主关键字进行徜单询问，还经常需要对次关了进行其他类型的i旬问俭索。
例如，图以]的高考成绩文件中，准考证号码为主关键字，“总分”和各单科成绩为次关键字。允许对此文得作如下询问：总分在600分以《的记录；数学的平均分数，等等。如果文亻1'组织中只有主关键字索引，则为回答这些对次关键字的询问，只能顺序存取文件中的每一个记录进行比较，从而效率很低。为此，对多关键字文件，除了按以上几节讨论的方法组织文件之外，尚需建立一系列的次关键字索引。次关键字索引可以是稠密的，也可以是非稠密的；索引表可以是顺序表、也可以是树表。和主关键字索引表不同，每个索引项应包含次关键字、具有同．次关键字的多个记录的主关键字或物理记录号。下面讨论两种多关键字文件的组织力法。
1 2、6．]多重表文件
多表文件（M凵“ F'的的特点是：记录按主关键字的顺序构成一个串联文件，并建立主关键字的索引（称为主索弓0对每一个次关键字项建立次关键字索引（称为次索引），所有具有同一次关踺字的记录构成一个馇表。主索引为非稠密索引，次索引为稠密索引。每个索引倾包括次关键字、头指针和链表长度。
例如，图12，后所示为、个多重镀表文件“其中，学弓为主关键字，记录按学号顺序甾接，为了查找方便，分成3个0车表，其索引如图0 15（b）所示，索引项中的主关键字为各子表中的最大值。专业、已修学分和选修课目为3个次关鍵字项，它们的索引如图 ] 2．0的、（e）所示，具有相同次关虱字的记录皚接在同一憐表中。有了这些次关键字索引，便容易处理各种次关键字的询间。例如，若要查询已修学分在0分以上的学生，只要在索引表上查找400、449这一项，然后从它的链表头指针出发，列出该链表中所有记录即可。又如，若要查询是否有同时选修甲和乙课程的学生，则或从索引表上“甲”的头指钊出发，或从“乙”的头指钊出发，读出每个记录、察看是否同时选修这两门课程。此时可先比较两个憐表的长度，显然应读出长度较短的链表中的记录。
多重链表文件易于构造．也于修改。如果不要求保持链表的某种次序，则插人个新记录是容易的，此时可将记录插在链表的头指针之后。但是，要删去一个记录却很繁琐，需在每个次关键字的表中删去该记录。
] 2，6，2倒排文件
倒排文件和多重表文件的区别在十次关键字索引的结构不同。通常，称倒排文件中的次关键字索引为倒排表，具有同次关．踺字的记录之间不设指针相链，而在倒排表中该次关字的一项中存放这些记录的物理记录号。例如，上例文件的倒排表如图1 2．[ 6 所示
倒排表作索引的好处在丁检索i己录较快。特别是对某些词问，不用读取记录．就可得
3 ] 9
物理
一一
姓名
学号 业
已修学分]
土雯马小燕阢森苏明明田永杨青薛平平崔子健土洪
] 350，
1 3 5 1
1 3 5 2
1 3 5 3
] 3 5 4
02
0 7
05
06
09
08
10
们2
398
耥6
02
384
3 5 6
3 9 8
08
3 7 0
蜘
国
05
甲甲甲甲
04
丙内丙
乙
丁
记录号旧
02
03 04 05
07 卟
09主关字
头指到
1353
01
135 7
] 3 5 9
0 9
次关字
头指针
长度
01
4
03
次关镶字
头指针
长度
350～399
0 6
飞00亠49
的
4
次关键字
头指针
长度
图12．] 5多重丧文件示例
（a）数据文件；（的主关键字索引；（“专业”索引《（山“已修学分”索引： （e尸选课目”索引
到解答．如询问“软件”专业的学生中有否选课程“乙”的．则只要将“软件”索引中的记录号和“乙”索引中的记录号作求“交”的集合运算即可。
在插人和删除记录时，倒排表也要作相应的修改，值得注意的是倒排表中貝有同一次关键字的记录号是有序排列的，则修改时要作相应移动。
若数据文件非串链文件，而是索引顺序文件（如] SAM文件），则倒排表中应存放记录的主关键字而不是物理记录号
倒排文件的缺点是维护困难。在同一索引表中，不同的关键字其记录数不同，各倒排表的长度不等，同一倒排表中各项长度也不等。
320
软
件
01，02，07，08
计
机
03，05
应
用
04，0，10
专业倒排我
350～399
02，05，06，07，09，] 0
400～449
01，03，04，08
（已修学分倜排表
02，04，06，07，08，09，10
03，05，，
01，02，03，04，08
01 . 03，05，09
@选修课目倒排表
图12. 16倒排文件索引示例
。3 2 ] -Z k?(binary Tree) 121
tree)
257
103,164
238
249
( list of
(l?ists) (generalized lists)
107
(breadth-fit?st search)
(descendant)
169
-f?M (subtree)
(subgraph)
(substring)
118
(Activity On Vertex network)
181
AOE (Activity On Edge network)
(element)
(queue)
183
( front)
59
( rear)
(doubly linked fist)
59
(deque) (double ended queue)
60
(parents)
120
248
139
120 tree) 120
(undirected graph) (undlgraph) 157
(garbage collection) 206225
263
306 fixed size records) 306 (have variable records) 306
(have only one key) 306
(with more then onc key) 306
(open addressing) 257
(head pointer)
27
(head node)
28
(edge)
157
(boundary tag method)
198
159,170
(spanning tree)
(minimum) 173
(spanning forest) 160 (available space list) 194 ASL (Average Search Length) 217 (balanced binary tree) 233
(balance factor) 233
(balance rotation) 234
254
(mid-square method)
(balanced merge) 296
283
(merge sort)
(merge insertion sort) 292
(merging segments) 295
(external sorting) 263 , 293
78 compaction) 212 6
6
(sequential)
6
(linked)
58
First ()ut)
128,139 traversal)
138
(preorder)
44
In First Out)
128 traversal)
138
(postorder)
?
(postfix notation)
129
( backtracking)
149
(digraph) (directed graph)
157
(directed acycline graph)
179
(ordered tree)
120
(sorted segment)
296
(buddy system)
203
(network)
158
(articulation point)
176
(critwal paths)
183
(Key)
214
(primary key) 214
(second key) 21 4
(Dynatnic Searh Table) 214 ,226
252
258
(random probing)
(sorting by address) 264,289
(delay time) 294
dfi$jlid(seek time) f4%jEMlii) (transrnission lime)
295
(rnutii—wny Inerge)
(multilist file)
297
15 time complexity) 15
70
70
71
120
124
158
158
161
163
164
166
?
218
254
145,220
271
273
IRC; (Inter Record Gap) 293
IBG (Inter Block Gap) 293
8 data type) 8 data type) 9
18
132
27
156
120 .158
158
157
1 37
19
253
180
180
264,267
297
307 ,308
214120
32
4-1
i 1 8 152
138
251
251
1 44
129
1 46
196
214
216
295
308
278
293
(discrete event simulation)
(speclal matrices) 95
(reeljrsivc fllnciion)
118
(bubble sort) 272
(Indexed setloential search) 225
(indexed sequential file) 31 1
ISAM (Iftf) (Indexed Sequential Access Method)
3 13
VSAM ( (Virtual Storage Access Method)
316
(indexed file)
31 1
(inverted file)
,113 . 120
( depth)
E)FS (Depth First Search)
167
(random number method)
256
(sorting)
263
75 ,279
279
284.286
sort)
316
(control interval)
316
(control range)
317
30527
258
286
(linked radix sort)
35 linked list)
63 queue)
139 relations)
139
295
144
173 spanning tree)
186 path)
197
197
285
(Most Significant Digit first)
285
(I.east Significant Digit first)
304 merge tree)
221
(Fibonacci numbers)
221
(Fibonacci search)
90 matrix)
158
260
265
(insertiOn sort)
265
(straight)
266
(binary)
267 a-way)
267
(table)
317
(hashed file)
? (data) 4
( data eletnent)
90
1 44 . 1 59
(replacement selection sort) 299
124
i?i
13
(implementing linked lists using array)
(pattern matching)
(Static Search Table h 214,216
(stable sorting hod) 263
(ditninishing incretne'it sot t) 27 1
( Hoffman trcc)
(Huffman codes) 1 46
?Bubble- sort（a囗，n)
AddPoiyn（&，Pa，b?Pb)
Createl.ist- L（n) CreatPolyn（UP, m〕 difference（以a，&
Free- SL（&斗a，k)
GetEleru-上（丨、，0
InitList Sq〈&L)
ImtSpace.- SL（姊“的
Ligtl)elete- Sq（&巛 Listl)elete- L（& I、，
ListDelete- Dul.（i, &、e)
丨istlljsert— l?igtlngert L（L' i ' l?istlnsert— DuL（& 0
附录B 函数索引／将a中整数序列重新排列成自小至大确序的整数序列//多项式加法：= Pa+Pb
43
／7逆位序输人n个元素的值．建立带表头结点的单链线性表L
30
输人m项的系数和指数，建立表示．元多项式的有序链表P 学在，维数组ace中建立表示集合（A一B）U一A）
12
的静态表
在将下标为k的空闲结点回收到备用表
00
山。返回带头结点的单表上中第个数据元
。
-
构造一个空的顺序存储结构的线性表L
9@
是将“维数组ace的各个分量成一个备用表
0
//孔顺序线性表L中删除第；个元荪并由e返回其值丿在带头结点的单链线性表L中，删除第i个元素． 并山《，返回其值
，/删除带头结点双循环线性表L的第i个元素
乙
丿在顺序线忏表L的第i个元素之前插人新的元素@
24
汐在带头结点的单线性表L的第i个元素之前插入元素e 29，
在带头结点的双循环线性表匚的第i个元素之前插人元幸e 36LocateElem-Sq（L，e，吓com因r，纟孔顺序线性表L中查找第1个值与e满足关系函数
蜘（）的兀素的位序
LocateEletTI- SL（&的 在静态单线性表上中查找第1个值为的元素
Matloc- SL（8-spnce) 汐若备用空间表非空，则返回分配的结点下标．否则返回
Mergel ist（La. & 0） //归并有序线性表0和Lb得到新的有序线性表Lc Mergel,?st-（La? Lhs &上节 归并有序顺序表后和Lh得到新的有序顺序表0
MergeList- L（&La，8、Lb，8'Lc) ，歹归并有序单表La和Lb得到的有序单虢表0 union（&La, Lb) 将所有在线性表Lb中但不在0中的数据元橐插人到Bank-Sitnulatiot'l（CloseTit1，e) 裉行业务模拟、统计一天内客户在恨行逗留的平均时间Conversion（）
DeQueue（8、Q， DeQueue（&Q? DestroyQueue（
be)对于输人的任意一个非负卜讲制整数，打印输出与其等值的八讲制数
/删除非空队列Q的队头元索，并用e返回其值 删除非空循环队列Q的队头元素．并用e返回其值
'销毁链队列Q
EllQueue（&?Q，的 插人苁。为箔队列Q的新的队尾元素
EnQueue（0，0 岫八元素为循环队列0的新的队尾几点
EvaluateExpressionQ) ．按頁符优先算法对从终端读人的算术表达式求值GetTop（5， ／用亟回非空顺序栈S的栈顶元素
Hanoi〈n，X' Y'幻 左塔座×上编号为]至n的n个圆盘按规则搬到塔座z l.
InitQueue（b'Q) 丿构造个空的队列
InitQucue（F*Q)构造个空的循环队列0
InitStack（& 5）构造一个空的顺序栈$ LineEdit()个尚单的行编辑程序
MazePath（maze. Start， end丿求迷宫ma跽中从人口rt到出口end的，条通道
Push（8巧，9插人元素e为颠序栈$新的栈顶元素
Pop（&S, be)非空咿序找S的找顶元素，用e返回其值
页
QueueLength（0） 汐'返回循环队列Q中的元素个数，即队列的长度
将堆存储结构申s清为空串
Concat（&T，引，S2) 用T返回由顺序存储结构串引和S2联接而成的新串 Concat（T，，S2) ／7用T返回由堆存储结构的串引和S?联接面成的新串 t一以*t ( T，bnextLJ)求模式串T的
get nextval（「，求模式串T的next函数正值 index（$，T刂0回空子刂0「在主1吓中的位
Index KMV（&。0p0） ，7利川心数值求非空了串T在主串S中的位置
StrAssign（T，丑《山“动把串常量chars赋为堆存结构的串T的值
StrCompare（S' T)返回堆存储结构的申S和T的比较结果
Insldxiast(&idxlist'bno)将书号为boo的关键词插人索引表黾i以
77
] 1 6 4
102Strlnsert（$，po$，T) //在堆存储结构的串s中第四s个字符之前入申T
StrLength（引返回堆存赭结构的申$的长度
SubString（&Sub，& POS' len) 用s返回顺序存储结构的刂巧中第p啩个字符长度为
汐len的了申
s s布（s? POS' le的用sub返回堆存储结构的串S中篤四8个字符起长度CopyGList（&T，L) CreateGl ?si（距。
CreateSMatrix OL（为len的了巾
//采用头尾表存储结构，由广义表L复制得到广义表T
FastTransposeSMatrix（M，(T)//求龐二元组顺序表表不的稀疏矩阵M转置矩阵T
，7采用头尾链表存储结构，由广义表的书写形式串S创建广义表上创建用《字縫表存储表示的稀琉矩阵MGl-istDepth（
MultSMatr.x（M. N, 8"Q)
采用头尾链表存储结构，求广义表的深度
求采用行逻辑链接存储表示的矩陈乘积Q- -MX -NSever〈&str, &hstr)
"I'ransposeSMatrix（M' T〕
，C reateBil'ree（&．0 按先序次序输人结点值，构造二又链表表示的0叉树f
find mfset（S, i) 7找集合S中i所在子集的根
fix mfset〈& $，0 ／/确定所在子集，并将从至根路径上所有结点都变成根的孩了结点
GetPowerSet（i t.A，&B) 用线性表表示集合时求A的幂集A）
14 1] 50
In()rderTraverse Thr（'l' .（V这的） //中序遍历0叉线索表表示的一叉树T In()rderThreading（&"l'hrt，T)／/ 中序历二叉树T，生成中序线索表Th “
lnThreading〈p) 对以P为根的二又树进行中序线索化 merge mfset（& S' i，j) ，纟求s中两个互不相交的子集Si和Sj的并集SUS
0（S' i，J) //求两个互不相交的子集S,和的并集SUS
] 3遘
135
141
142
Huffmancoding（&H'I', &HC,，w, n)构造赫夫曼树HT，并求得字符的赫夫曼编码HC lnOrderTraverse（T, 0 VISIO ) 7中序遍历二叉树T的非递归算法 ] 30刁31
PreOrderTraverse（T，（Visit))//先序晌历二叉树T的递归箅法
PowerSet（i，的 ／/求含个元素的集合A的幂集A）
Trial（讼的 歹求n皇后问题棋盘的合法布局，并输出之
129 巧0
BFSTraverse（G, (暑Visit)) 按0度优先历图G，访问（V 0图中所有顶点 170 CreatcGrapl)（&'G） /构造图G的数组（邻接矩阵）表示存储结构 ] 62
CreateUDN（&G) 构造无向网G的数组（邻接矩阵）表示存储结构 ] 6 2 Create10G《） 它构造有向图G的]字表存储结构 165 (%iticalPath（G) 享输出有向网G的各项关键活动 185 DFS（G , 亻0人第个顶点出发递归地深度优先历图G
DFSArticul（G , v0) 饣从第个顶点出发深度优先历图G，查找并输出关节点 1 7 8
DFSForest ( G，&'f') 建立尢向图G的深度优先生成森林的（最左）孩子〈右）兄弟表T 17 1
I)FSTraverse（G,（徊Visit)) /对图G作深度优先遍历 169 OFSTrec（/，&T) 学从第v个顶点出发深度优先遍历图G，建立以T为根的生成树172
Fliid'\rticul（G) 查找万输出阵图G下个部关节点 片8
MimSpan「ree PRIM《G ，u〕 用普里姆算法从第个顶点出发构造网G的最小生成树T 175
Shortestl'ath- DIJ（G， 用Dijks “算法求有向网G中从顶点 到其余顶点v的最短路径p [到及其带权长度
Shortestpath- FLOYD（G*，> ／7用F而d算法求有向网G中各对顶点v 和w之问的最短路径v w ]及其带权长度
'ISOPQlogicalOrder（G ' &的 ／/求有向网G中各顶点件的最早发生时间以
、 卜0门《G) ，／若G无回路，则输出G的顶点的一个拓扑序列 ] 8 2
1op国0小
以第个0为分界符，将非空串str分割成两部分：hsub和“ 117 ，求采用二元组顺序表表示的稀琉矩阵M的转置矩阵T AllocBound'l?ag（P“，n)
AllocBuddy（&avail' n)
MarkList（G].
边界标识法的存储分配算法 200 丿伙伴系统的行储分配箅法 2《
／遍历非空广表．刈表中所有未加标志的结点加标志
331Cte?teS()Sl"ree《8..'1'，ST) DelcteBS'l'（&．0 key）
InsenAVL（距T，《、，& t引0
InsertBST〈bTt《〕
InsertBTree（T，K.小0
InsertHash（&,H, e)
LeitBaIance（b.T〕 L Rotate（&p〕
Ro愾@（和[0
Search? Bin〈ST. key）
SearchBS'l'（Tt key.，&的
SearchBTree（T. K)
Searehl)J,Tree（'f. K)
SearchHash（H. K. p，
Search．Seq（ST. ey)
SearchTne（0 K)，由有序表ST构一棵次优查找树T 225 若二又排序树T中存在关键字等于key的数据元素时，则删除以数据元素结点p并返回TRUE；否则返回FALSE 230 在平衡的二又排序树T中插入原树中不存在有相同关讓字的
：，结点，若因插人血使二又排序树失去平衡，则作平衡旋转处理237 当二叉排序树T中不存在关键字等于e，key，的数据元素时，
/7插人e并返回TRUE 228
//在阶B树T E结点? q的keyCi-1与key「i4 1 ]之间插人
//关字K 244
//查找不成功时插入数据元素e到开放定址哈希表H中，并返回
／/ OK;若冲突次数过大，则重建哈希表 259
／／对以指针]所指结点为根的二叉树作左平衡旋转处理 237 》'对以时为根的二叉排序树作左旋处理，处理之后p指向新的 树根结点 235 对以1冒为眼的0叉排序树作右旋处理，外理之后p指向新
? 的树根结点
/ /在有序表ST中折半查找其关键字等于key的 数据元素
//在]、所指二叉排序树中递归查找其关憷字等于key的
；数据元韋
? 在m阶B树T上查找关字返回结果@0山0
//在非空双树丁中查找关键字等于K的记录
／7在爿放定址哈希表H中查找关键码为K的元素
／／在顺序表ST中顺序查找其关键字等于key的数据元素 在树T中查找关键字等于K的记录
236
220
228
0
248
2 5 9
216
250
Seeond()ptirnal（8'T?，《ow、high) //由有序表RCIow.．确到及其累计权值表sw为归构造次仇查找树'V 223
Arrange（LSI"）
，丿根据静态表SL中各结点的指针值调整记录位置，使得引、
／2中记录按关键字非睇减有序顺序排列
269
BInsertSort（&L)
／对顺序表L作折半插人排序
267
第10章
Co脹0（& i. f. e)
本算法按雇y ]自小至大地将ft-o.、RADIX一1〕所指各子表
依次链接成· 'i、表“@．．RADIX一为各子表的尾指针288
Distribute（b-r,
&
在静态表L的r域中记录已按〈key的， ，keysCi刁〕）序．学本算法按第i个关键字key」建立RADIX个子表，使同一子
以表屮记的keys「相同 288
IleapAdJust（8，A? s?
已知H “[ s一m」中记录的关键字除H.卜1k盯之外均满足
唯的定车数调整H，r [ s]的关键字，使H. rCs. m《成为
一个人顶堆（对其屮记录的关字而言）H eapSort《& Il）
InsettSort（8.1,)
Merge（SR匚，
MergeSort（EL)
Msort（SR.--，&TRI「」《 ，5，t冫
Partition（low. g卜〕
Qsort（L，IOW. high)
(ü)ckSort《
RadtxSort（B,L)
对顺序表日进行堆排序
对I顸序表L作直接插人排序
将有序的SRTi一m181吓RIm E l，，并为有序的 TR i. .到
对顺序表L作归并排序
将SR一t ]归并排序为TRIts. . tJ
交换顺序表L中子序列L．的。w一high ]的记录，使枢轴记录到位．并回其所在位置
/／对顺序表I.中的了序列L，r「w，，卜igh ]进行决速排序
， /鸡帅序表进行快排序
/ L是采用静态链表表示的顺序表，对L作基数排序，使得匚
成为按关键字自小到大的有序静态链表，L謡明为头点 255Rearrange（&'L，adrr 0
ad [给出顺序表L的有序次序，即L，r [司r [ 1的是第i小的记录，
0算法按巛重排L，。使其有序
& le《00以（00 对顺序表L作简单选样排序
Shelllnsert（8?L. dk） /对顺序表丨作一希尔人排序，为增量
Shen.Sort（0山氐按景序列dh00 0刁〕对顺序表L作希尔排序Adjust《在，的
过沿从唄羊结点跹到到根结点艮明的路径调整收者树
四9
I nn对ruct L05 “（& 5，）
输丿、个记录到内存工作区-，建得敵者树选出关字
最小的记录
3的
Createl,oserTree（&尽）
．已加硨的到k一0为完全二叉树的叶子结点存有l'
个关键字，沿从叶羊到根的k条路径将Is调整成为败者树
299
get- run（&小，
求得一个初始归段
K. Merge（8，．&励
在利用畋者树卜将破号从0到k一1的k个输人归段中
298
Replace- Selection（“汛 亻0） 在败者树这和内存工作区wa上用置换．选择
排序求初始归并段，为渝人文件为输出文件
301
Select MiniMax（“必巾 从“ [ q ]起到败者树的根比较选择MINIMAX记录，并由
/刂指示它所在的归并段
第12章
MergeFile（ g. h) //山按关字递增有序的非空序文件f和g归并得到文件h
333
[UE, Sahni S. of Data Structures. Pitmen Publishnng 1 .9if_5
Knuth l) E. The Art of Computer Programming. volume I 'Fundatnen(al volurne3.? Sorting and Searching. Addison— Wesley Publisbillg Conlpany. Inc. , 1973 Gotlieb C C, Gotlleb L R. Types and Structures. Elall Inc. ?
?l'enenbaum A M, Augensetein M J. l)ata Structures Using PASCAI.. Prentice Hall, Inc. ,
1981
Baron R J t Shapiro l, G. Data Structures and their Implc.mentation, Van Nostrand Reinhold Company, 1980
[6] Aho A V, Hoperoft J E, Ullman J Data Structures and Algorithms. Addlsoll — Wesley Publishing Company, Inc, ,1989
[8.1 S P!Wr .
Wirth N. Algorithms-i- Dada Structures= Programs. Prentice— Hall. Inc, 19/6
Lewis T G, Smith M 'L Applying Data Structures. Houghton Millhn Company.
J J, Operating System, McGraw— Mill, Inc_ , 1 071
Tremblay J P. Sorenson P G. An introduction to bala Structure with Applications. Second Edition. McGraw— I-lill, live. 1984
Stubbs L) F. Wibre N W. Datu Structures with Abstract Data 'l'ypes and Pascal. Brooks Cole Publishing Company. 1985
? 334 ?
1 ，5
唟6
2 〕“ 0"的形式定义为；若不羽是正整数的个函数，则耘；；《山D）表示存在一个正的常数M，使得当；；一时都满足巨Ml tot)
3 )若将Lb中元素插人L为保持La中元素递增有序，必须移动元素（除非瓤人的元素值大于LH中所有的元珧
·
4 〕虍于第，层上的结点数至多为2 一，以它们为根的二叉鲥的深度为h一i + 1，则调用」次HeapAdjnst过程时总共进行的关键字比较次数不超过下式之值：
．2一的一的一乥（2）
------------------------------------------------------------------------------------------------------------------------------------------------------抽象数 类型抽象数 类型抽象数 类型线性表· 22 线性表· 22 · 22 · 32 ·· 22 58 58 102102· 205203· 207 ·· 207 · · · · ·216 221221203203251251216 216 ? 324 ? 323 ? 323 216