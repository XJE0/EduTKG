自《啊哈C》出版以来，我与编程爱好者们便有了更多的交流机会。这些编程爱好者之中不乏大学生、中学生、老师、家长，更有小学二、三年级的学生。令我惊喜的是，二、三年级的小读者们与我探讨的并不是浅显的语法或BUG调试问题，更多的是他们通过独立思考发的书中的错误，他们向我阐述自己的思想，与我交流游戏开发中遇到的逻辑、算法等。还有一些读者留言说：“这本书不仅仅是小学生坐在马桶上都能看懂的书，是连我妈妈或是我姥姥都能看懂的编程书！”这些读者实在是太捧场了，有幸让我体验了一次漫卷诗书喜欲狂的感觉。也有好多读者看完后直呼不过瘾，常常询问何时能有第二部。一晃已是三年，借此《啊哈C语言！逻辑的挑战》修订之际，第二部《啊哈C语言！游戏实验室》也如期而至，它景致依旧，故事常新，希望你能喜欢！让我们再次共同探索编程与梦想的一切可能。
　　啊哈磊 2016年12月第一版序　　我经常被问到一个问题：当初为什么会去学编程？我的回答是，因为我很喜欢玩游戏。每一个喜欢玩游戏的人，都梦想着可以通过修改游戏的程序使游戏中的自己变得非常强大，而这需要学习编程。其实每一个喜欢玩游戏的人都曾有过创造游戏的梦想，那我们为什么不把这种梦想变成学习的动力呢？我就是这样踏上编程之路的。
　　牛人肯·汤普逊（Kenneth Lane Thompson）自己编写了一个叫作“星际旅行（Star Travel）”的游戏。而汤普逊为了能更顺畅地玩这个游戏，竟然自己动手用汇编写了UNIX操作系统。后来他觉得用汇编写UNIX操作系统非常麻烦和辛苦，于是和另一个牛人丹尼斯·里奇一起创造了C语言。没想到吧，C语言竟然是一个牛人为了玩自己写的游戏而创造的。其实这在计算机界很正常，程序员们往往就是因为某个游戏或者软件的现有功能不能满足自己的需求，才开发出了更加优秀的游戏和软件。本书中超萌、超简洁的“啊哈C语言”编程软件也是这样来的。
　　我经常被问到的第二个问题：为什么普通人需要关心编程呢？我的答案是，因为当下程序员几乎主宰了整个世界，控制着生活的方方面面。我们住的房子、穿的衣服、吃的东西、用的各种电子产品，以及我们去ATM取钱、坐电梯、开汽车、坐飞机、坐火车等，都离不开编
程。你坐火车时有没有想过，一条铁轨上同时运行的那么多列火车是如何调度才没有导致它们相撞的。这个时代很难想象还有什么不是通过计算机程序控制的。如果想理解这个时代，就必须理解计算机编程。编程会让我们以一种全新的方式来看世界。当然，在学习编程的过程中还可以提高我们的逻辑推理能力、批判性思维和动手解决问题的能力。与计算机展开的逻辑较量一定会让你觉得很有意思。
　　我还经常被问到第三个问题：什么样的人可以自学编程，学习编程需要什么基础？答案是，你只需具有小学四年级以上文化程度，并且熟练运用鼠标和键盘就可以。你若不信，那就从这本书开始吧。
　　编程很容易让我们实现梦想。如果我们觉得某个游戏玩得不爽想提升体验，或者觉得某个软件不够好用想自己做一个，没问题，现在就可以！而唯一的投入就是一台计算机。实现梦想从未变得如此简单。编程世界里每天都上演着传奇，一大批热爱编程并且满怀梦想的人正在充满激情地奋斗着。
　　编程将会改变我们的思维，教给我们如何思考，会编程的人总想改变点什么。正如乔布斯所说“I think everybody in this country should learn how to program a computer, should learn a computer language, because it teaches you how to think.”
   啊哈磊 2013年9月注：文中出现的“□”同原版纸书目 录修订版序第一版序
第1章　编程改变思维第1节　为什么要学习编程
　　第2节　本书是讲什么的，写给谁看的第2章　梦想启航第1节　编程的魔力
第2节　让计算机开口说话第3节　多彩一点
第4节　让计算机做加法第5节　数字的家——变量
第6节　数据输出——我说咋地就咋地第7节　数据输入——我说算啥就算啥第8节　究竟有多少种小房子第9节　拨开云雾见月明
　　第10节　逻辑挑战1：交换小房子中的数第11节　天啊！这怎么能看懂第3章　较量才刚刚开始第1节　大于、小于还是相等第2节　判断正数第3节　偶数判断第4节　神器else
第5节　请告诉我谁大
第6节　逻辑挑战2:3个数怎么办
第7节　逻辑挑战3：我要排序第8节　运算符总结
第9节　1＞2究竟对不对
第10节　讨厌的嵌套
　　第11节　if-else语法总结第4章　重量级选手登场第1节　永不停止的哭声第2节　我说几遍就几遍
第3节　if对while说：我对你很重要第4节　求和！求和！！求和！！！第5节　逻辑挑战4:60秒倒计时开始第6节　这个有点晕——循环嵌套来了第7节　逻辑挑战5：奔跑的字母第8节　究竟循环了多少次
　　第9节　逻辑挑战6：奔跑的小人第10节　for隆重登场第5章　好戏在后面第1节　程序的3种结构第2节　啰嗦一下
第3节　逻辑挑战7：判读质数很简单第4节　更快一点：break
第5节　continue
第6节　逻辑挑战8：验证哥德巴赫猜想第7节　逻辑挑战9：水仙花数
第8节　逻辑挑战10：解决奥数难题第9节　逻辑挑战11：猜数游戏
第10节　逻辑挑战12：你好坏，关机啦第6章　天啊！一大串数正在接近第1节　逆序输出
第2节　申请100个小房子怎么办第3节　100个数的逆序
第4节　逻辑挑战13：陶陶摘苹果
第5节　逻辑挑战14：一个萝卜一个坑第6节　逻辑挑战15：选择排序第7节　二维数组
第8节　剩下的一些东西
第7章　有了它你能做更多的事第1节　字符的妙用第2节　多余的回车键第3节　字符的本质
第4节　人名怎么存储呢
第5节　逻辑挑战16：字母的排序第6节　逻辑挑战17：字典序第7节　多行字符
　　第8节　存储一个迷宫第8章　游戏时间到了第1节　走迷宫第2节　推箱子附录A　标识符命名规则
附录B　运算符的优先级和结合性第1章编程改变思维第1节　为什么要学习编程
　　你是否还在将计算机（电脑）当作上网、聊天和玩游戏的工具？没错，大部分人是这样的。当你拿起本书阅读到这里的时候，太好了，你又多了一个更好的选择，一个独特的机会！　　在我们生活的这个时代，你会发现有这样一群人，他们对世界的影响越来越大，电视、报纸和网络到处都充斥着他们的身影。比尔·盖茨
创立了微软，让计算机更容易被我们平常人所使用 [1] ；乔布斯创立了苹果，iPhone、iPad和iPod每一样产品都在改变着我们的日常生活；谢尔盖·布林和拉里·佩奇两个年轻的小伙创立了Google，使得获取知识变得前所未有的容易；马克·扎克伯格创立了Facebook，正在改变人与人
之间的关系……甚至12岁的小软件工程师托马斯·苏亚雷斯 [2] 都在改变我们的世界。他们是怎样的一群人？他们为什么会创造奇迹？巧的是他们都有一个共同的特点：在少年时都酷爱计算机编程。计算机编程究竟具有怎样的非凡魔力？计算机编程是否给他们带来与常人不同的思维或思考方式？是否是计算机编程为他们开启了不一样的人生道路？
　　为什么他们从小就开始接触计算机，不但没有沉迷于游戏，反而改变了世界呢？12岁的托马斯说：“现在的孩子们不再只是爱玩游戏，他们还想自己制作好玩的游戏，不过孩子们大多不知道去哪里学习计算机编程，而懂得计算机编程的家长又很少。”　　其实每个人在童年时期都曾经有创造游戏的梦想，我们为什么不把这种梦想变成学习的动力呢？大部分孩子在面对计算机的时候都缺乏引导，因为他们不知道计算机除了上网、聊天和玩游戏外还能做什么。即使有人想深入地学习计算机，也不知道去哪里学，没有方向，更没有一本简单易懂并且有趣的入门书。计算机从被发明的那一天起，其使命就是帮助我们提高学习和工作的效率并且改变世界。利用计算机编程，你可以轻松解决数学难题。例如，□3×6528=3□×8256，在两个□内填入相同的数字使得等式成立。你觉得这样的题目太简单了？那么来个稍微复杂点的：□□□+□□□=□□□，请将1～9这9个阿拉伯数字分别填入9个□中使等式成立，每个数字只能使用一次。计算机可以轻轻松松地解决。如果再复杂一点，我想知道上面这个式子的所有解，通过笔算就很困难了，但如果使用计算机编程去解决，就易如反掌，这正是计算机所擅长的。有时你甚至可以利用计算机编程去验证世界性的数学难题，例如，在10 000以内去验证哥德巴赫猜想，也都不成问题。当解决大质数、图论等问题时，计算机编程也是最好的帮手。
那么学计算机究竟是学什么呢？答案是逻辑思维和编程思维。
　　早在20世纪50年代，美国教育界就开始重视计算机编程教学。20世纪80年代后，计算机编程教学逐渐进入中小学校，以教程序设计语言为主，目的是提高学生的逻辑推理、批判性思维和动手解决问题的能力。实践证明，学习了计算机编程的中小学生，思考问题的方式变得非常逻辑化，学会了严密的逻辑推理方法，并无形中把它应用到其他学科的学习中。学习计算机编程本质上是在学习一种思维方式——编程思维，它是一种思维体操。青少年本身对计算机有着浓厚的兴趣并且有超强的记忆力，计算机编程将有助于开发其学习潜力，提高逻辑推理能力和解决问题的能力。
　　学习计算机编程的过程充满乐趣。如果你有一个想法，马上就可以通过编程来实现，并且可以立即看到效果。这种即时的反馈，会让你的学习兴趣变得越来越浓厚，也会让你越来越有信心。这种超强的信心，是你在其他学科中难以感受到的。我还记得我的第一个程序运行成功时的那种兴奋，真是太棒了，你一定要去感受一下，这是你一辈子都不会忘记的感觉。
　　最后，用笔者一个武汉二中的学生吕凯风 [3] 学习编程时的感受来结束本小节。
　　“记得我那时学编程全凭兴趣，兴趣引导我前进。以前做完了作业打游戏，如今写完了作业就编程。我觉得学会编程后最让自己激动的是，我能用编程来解决几乎所有遇到的数学问题。学数学最强调技巧
性，比如7的2000次方除以3的余数是多少？21 212 157是不是质数？你也许可以用一些小技巧把这两个问题解决掉，但是当我们遇到更难的问题时，往往无能为力。比如214 125 315的123 719 857次方除以12 125 987的余数是多少？2 147 483 647是不是质数？很多实际问题并不像数学中那么理想和美好，许多数学结论，尽管被证明得很巧妙，式子简洁，但是归根结底，如果它只解决了一个特殊问题，则不具有什么实用价值。所以我更喜欢信息学，它告诉我如何去解决一个一般化的问题而不是一个特殊的有技巧性的问题。编程最让我感慨的是它无与伦比的唯一性与严谨性。”
说到这里你是不是有点心动了？
第2节　本书是讲什么的，写给谁看的
　　在写本书之前，我反复问了自己几个问题：这本书是讲什么的？这本书是写给谁看的？这本书和一般的编程入门书有什么区别？为什么要写这本书？选用哪一门编程语言入门呢？
第一个问题：这本书是讲什么的？
　　这是一本编程入门书。但是本书的重点并不是编程入门，而是向你展示逻辑思维和编程思维的魅力，让你像程序员一样思考。
第二个问题：这本书是写给谁看的？
　　编程类图书给大众的印象一直是枯燥并且难懂的。究竟什么样的人才能学习编程呢？大学生？高中生？初中生？……不会连小学生都可以吧？！没错，只要有小学四年级的水平，我想你一定可以学习编程，并且轻松读懂本书的全部内容。
　　如果你的情况恰好符合以下一点或几点，那么本书正是为你所写的。
　　（1） 如果你想自己制作好玩的游戏，而不是沉迷于别人的游戏中。
　　（2） 如果你曾对数学感兴趣，我想你一定会喜欢这本书。其实学习编程并不需要精通数学，本书不会出现很复杂的数学公式。即使数学不太好，甚至很糟糕，也完全可以阅读。（3）如果你对逻辑感兴趣，你一定更会喜欢这本书。与计算机展开的逻辑较量一定会让你觉得非常有意思。因为计算机有时会显得不那么听话，你让它向东可它却偏偏向西，这时候就一定是你编写的程序出现了逻辑问题。而将你的思维清晰有条理地变成计算机程序，就如同一场你与计算机之间的逻辑对决。学习计算机编程能够很好地锻炼你的逻辑思维能力。
　　（4） 如果你从小喜欢拆装玩具、改装小电器或是喜欢变废为宝，我想计算机编程会给你带来更多的创造机会。
　　（5） 如果你正在读《高中数学必修三》的“算法”一章，那么你一定要阅读本书，去了解计算机编程和算法的本质。
　　（6） 正在学习C语言的理工科或者文科的大学生们。
　　（7） 准备学习编程的爱好者，或者准备以此为工作的人。
　　（8） 哦，对了，还有就是看了很多编程书籍但是一直没有看懂的人，我想你一定可以轻松读懂本书。
　　（9） 没有那么多原因，就是喜欢计算机。
第三个问题：为什么要写这本书呢？
　　正如前面所说，计算机是一门科学，如果你只是把它当成上网、聊天和玩游戏的工具，那就太可惜了，你将可能失去一个发现自己才能的机会。即使在计算机编程上有一些天赋，你也有可能失去这一机会。和其他人一样，你必须去主动发现自己的天赋和兴趣，就好比你从来没有吃过冰淇淋，就不可能知道自己喜欢吃冰淇淋。然而，如果学习了计算机编程，你就会发现计算机编程就如同玩游戏一样有趣，充满活力的思考过程就如同一场比赛令人兴奋。在感受到了计算机编程给你带来的乐趣后，你就再也不会沉迷于计算机游戏，计算机编程将成为你生活中不可缺少的一部分，成为你的一种爱好，成为你的一种学习动力。我想有更多人期待去了解计算机编程。
最后一个问题：选用哪一门编程语言入门呢？
学习编程的重点在于学习编程的逻辑和思维。本书选用较为简单的
C语言。你可能要问为什么不选C++、C#、Java或者Python之类。因为我觉得相比之下C语言最为单纯，没有那么多乱七八糟的东西，非常简洁。即使以C语言为载体，我也尽量做到重点去讲解最有用的内容，而不是C语言的高深语法或者我至今都没有用过的“奇怪”语句。这样就有更多的时间去思考如何解决问题，去关注编程的逻辑和思维。
　　当然，说到底C语言仅仅是我们与计算机沟通的一门语言而已，相信你在阅读完本书之后，可以很轻松地上手任何一门语言，因为其本质都是一样的。根据TIOBE 	index的程序语言年度排名，2012年最流行的编程语言正是有着40年历史的C语言，它战胜了Java语言位居TIOBE
index榜首，这或许也能说明C语言的重要性吧。以C语言为根本，将帮助你更好地去理解编程的思想，而不仅仅是学会编程。
　　另外我想告诉你，编程真的是一件非常有趣的事。你就像是一个指挥官，让计算机毫无怨言地为你工作。通过编程，你将体会到战胜困难和挑战后的快乐与满足。编程的世界充满无限的可能，只有想不到，没有做不到。当然在编程的时候也会遇到很多问题，我在书中也为你设置了绊脚石，希望你能够顺利地把它找出来。尽信书，不如无书。学习不但要细致，还要有思辨的能力，这样才会有创新，才能总结并创造出自己的东西。现在开始自己动手编程，不要放弃曾经的梦想，大胆地创造你的作品。
　　艾伦·凯曾经这样说道：“在自然科学中，是大自然给出一个世界，而我们去探索其中的法则。对于计算机来说，却是我们自己来构建法则，创造一个世界。”
　　当下，我们的学习不应该再忙碌于重复的计算、记忆等技能。阅读、逻辑推理和主动思考等技能将成为学习的重点。我们应该使用计算机来增强自己的智能，同时发挥人类独有的创造天赋，让我们的思维插上计算机的翅膀。
　　最后，我保证本书一定不是那种枯燥无味的编程入门书，并且在此之前你一定没有读过如此生动好玩的编程入门书。你可以在茶余饭后阅读本书，或许蹲在马桶上时也可以看得津津有味。现在就让我们一起走进计算机编程的神奇世界，探索和发现计算机编程的魔力吧！[1] 1985年如果乔布斯没有被迫离开苹果，那这一功劳可能将归于苹果的麦金塔计算机。
[2] 被誉为“小乔布斯”的12岁少年托马斯是美国加利福尼亚州洛杉矶市南湾地区一所学校的6年级学生。当大多数孩子还处在玩计算机或手机游戏的时候，托马斯就已经是个能开发游戏程序的“软件工程师”了。托马斯不但为苹果公司的手机操作系统编写了两个游戏程序，还创办了一家软件开发公司。
[3] 吕凯风（VFK）在14岁时以初中生身份获得NOIP（提高组）一等奖，初三时以全省第一名的成绩入选湖北NOIP省队，高一时获得亚洲太平洋地区信息学奥林匹克竞赛（APIO2013）国际金牌，高二时获得NOIP全国第二名，现被保送到清华大学“姚班”。此外，他还独立创作了“对对棋”和“啊哈图”软
件。“对对棋”的启发来源于他的班级同学在课间玩的一个游戏，“啊哈图”则是他在学习计算几何和图论知识时，为了方便解题和调试做的一个类似于“几何画板”的软件。
第2章梦想启航第1节　编程的魔力
从一个神奇的数字说起——2 147 483 647。
　　2 147 483 647是一个质数（也称为素数，即只能被1和其本身整除的数）。发现这个质数的人是伟大的数学家欧拉。1722年，他在双目失明的情况下，以惊人的毅力靠心算证明了2 147 483 647是一个质数，堪称当时已知的世界上最大的质数，他也因此获得了“数学英雄”的美名。
现在你通过计算机只需要1秒就可以证明2 147 483 647是一个质数。再来看一个经典的问题——八皇后问题。
　　如何能够在8×8的国际象棋棋盘上放置8个“皇后”，使得任何一个“皇后”都无法直接吃掉其他“皇后”？为了达到这个目的，任意两个“皇后”都不能处于同一条横行、纵行或斜线上。下面就是一种解决方案。没错，你可以自己拿出笔和纸画一画，看看还有没有其他方案。但是，如果我想知道所有的方案该怎么办？　　又轮到计算机出马了，一共有92种不同的解决方案，很棒吧！计算机只需要1秒，就可以算出所有的解。
再来看一个很流行的益智游戏——数独。
　　在一个9×9格的大九宫格中有9个3×3的小九宫格，默认在其中填写了一些数字，现在请在其他空格上填入数字1～9。每个数字在每个小九宫格内只能出现一次，每个数字在每行每列也只能出现一次。请看下面这个例子。我想，你一定很快就找到了一种可行解，可是你知道上面这个数独
一共有多少种不同解吗？答案是99 410种！很难想象吧，计算机找到这些解仍然只需1秒！怎么样，计算机编程是不是很神奇，你甚至可以轻而易举地在一定范围内去验证“哥德巴赫猜想”。
　　在接下来的内容里，你将学会如何与计算机对话，如何让计算机进行数学计算和判断，如何让计算机永不停止地工作，以及如何让计算机做一些很有意思的程序和游戏。一场有趣的逻辑思维大战即将开始，不要走开，赶快进入第2节——让计算机开口说话！第2节　让计算机开口说话
　　为什么会有计算机的出现呢？伟大的人类发明的每一样东西都是为了帮助我们改善生活。计算机同样是用来帮助我们的工具。想一想，假如你现在希望让计算机帮助你做一件事情，你首先需要做什么？是不是要先与计算机进行沟通？那么沟通就需要依赖于一门语言。人与人的沟通，可以用肢体语言、汉语、英语、法语和德语等。你若要与计算机沟通，就需要使用计算机能够听懂的语言。我们学习的“C语言”便是计算机语言的一种，计算机语言除了C语言外，还有C++、Java、C#等。C语言是一门比较简单的计算机语言，更加适合初学者。所有的计算机语言都是相通的，如果你能够熟练掌握C语言，那么再学习其他语言就会变得易如反掌。
　　既然计算机是人类制造出来的帮助人类的工具，显然让它开口说话并把它所知道的东西告诉我们是非常重要的。
下面我们就来解决第一个问题：如何让计算机开口说话？
　　回想当年，我们刚刚来到这个世界的时候，说的第一句话是什么？应该不会是“你好！”、“吃了没？”……这样会把你爸爸妈妈吓坏的！
　　伴随着“wa wa wa”的一阵哭声，我们来到了这个精彩的世界，现在我们也让计算机来“哭一次”。这个地方特别说一下，计算机若要
把“它”想说的告诉我们，有两种方法：一种是显示在显示器屏幕上；另一种是通过喇叭发出声音。就如同我们有话想说时，一种是写在纸上，另一种是用嘴巴说出来。目前让计算机用音箱输出声音还比较麻烦，因此采用另外一种方法，即用屏幕输出“wa wa wa”。    printf("wa wa wa");
　　这里有一个生疏单词叫作printf，不要被它吓坏了，目前不用搞清楚它的本质意义是什么，只要记住它和中文里面的“说”，以及英文里面的“say”是一个意思即可，它就是控制计算机说话的一个单词而已。在 printf后面紧跟的（ ），是不是很像一个嘴巴，把要说的内容“放在”这个“嘴巴”里。这里还有一处需要注意，在"wa wa wa"的两边还有""，里面就是计算机需要“说”的内容，这一点是不是很像我们的汉语？最后，一句话结束时要有一个结束的符号。汉语中用句号表示一句话的结束；英语中用点号表示一句话的结束；计算机语言中用分号表示一个语句的结束。
注：计算机的每一句话，就是一个语句。
	那么，现在如果让你写一个语句，让计算机说“ni 	hao”，该怎么
办？
    printf("ni hao");　　现在我们让计算机来运行这个语句。这里需要说明一下，仅仅输入 printf（"ni hao"）;，计算机是识别不了的，需要加一个框架。完整的程
序如下：
    #include <stdio.h>     #include <stdlib.h>     int main()     {           printf("ni hao");           return 0;
    }
这里的
    #include <stdio.h>     #include <stdlib.h>     int main()
    {           return 0;
    }
是所有C语言都必须要有的框架，现在你暂时不需要理解它，知道要有这个即可，以后再来详细地讲它的用途。但是有一点，我们今后写的所有类似printf的语句都要写在{ }里才有效。
接下来需要让计算机运行我们刚才写的程序。
　　如果让计算机运行我们写的东西（其实我们写的就是一个C语言程序），需要一个特殊的软件，它叫作“C语言编译器” [1] , “C语言编译器”有很多种，这里介绍一种比较简单的软件，叫作“啊哈C” [2] 。　　首先你需要到www.ahalei.com页面中下载“啊哈C”。下面就要进入安装步骤啦，安装很简单，一共分7步（见图2-1～图2-7），每一步我都截取了图片，你只需一口气将这7幅图片全部看完应该就可以。图2-1　安装“啊哈C”图2-2　开始安装“啊哈C”图2-3　设置“啊哈C”安装目录图2-4　创建桌面图标和启动栏图标图2-5　确认安装信息图2-6　安装正在进行图2-7　“啊哈C”安装成功
　　“啊哈C”安装完毕后，便可以看到如图2-8所示的“啊哈C”的界面，同时在你的桌面上也会多一个“啊哈C”图标。图2-8　“啊哈C”的界面
“啊哈C”是一个很人性化的软件，你将会发现“啊哈C”已经帮你将C
语言代码框架的部分写好了。只需要将
    printf("ni hao");
这条语句在“啊哈C”中输入就好，如图2-9所示。图2-9　输入printf（"ni hao"）
细心的同学可能会发现，“啊哈C”默认的C语言框架，比之前说的C
语言框架多了一句话：
    system("pause");
　　这句话是什么意思呢？稍后我们再揭晓。先将这句话删除，删除后的界面如图2-10所示。图2-10　删除system（"pause"）
　　好了，同学们请注意，到了最后一步，需要让代码运行起来。现在只需单击“啊哈C”上的“运行”按钮 。
　　接下来需要为所写的程序起一个名字，我为这个程序起的名字是“nihao”，当然你可以随便起名，中英文都可以。比如你可以称之
为“abc”或“我的第一个程序”，或者叫“1”都行，但是你最好别写火星文或者特殊字符，也不能有英文的点号。将程序的名字输入在如图2-11所示的文本框中之后再单击“保存”按钮，接下来就是见证奇迹的时刻。图2-11　给程序起个名字
文输入法，这里所有的符号都是英文的，一般也都是小写。
图2-12　编译成功的提示
　　如果代码没有写错，那你的“啊哈C”将会弹出一个对话框，提示“恭喜你编译成功”，如图2-12所示。
请同学们注意，在输入代码的时候，一定不要用中
　　下面当然就单击“确定”按钮。接下来，请注意：注视你的计算机屏幕，一秒也不要走开，数秒之后，你将会发现计算机的屏幕上有一
个“黑影”闪过，如果你没有发现这个“黑影”，请重新单击“运行”按钮，并再次注视你的计算机屏幕。
　　此时，你可能想问，为什么屏幕上会出现这个“黑影”？我们是要在屏幕上显示“ni hao”才对啊。其实刚才那个“黑影”就是“ni hao”，只不过
计算机的运行速度太快了，在屏幕上显示之后，就立即消失了。那应该怎么办呢？这需要让计算机暂停一下。
    system("pause");
上面这句话就是之前所删除的，其实它的作用就是让计算机“暂停
一下”。将这句话放在printf（"ni hao"）；后面，完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()     {           printf("ni hao");           system("pause");           return 0;
    }
　　好了，再次单击“运行”按钮吧。如果代码没有错误，你将看到如图 2-13所示的界面。图2-13　运行成功的结果
　　“请按任意键继续…”是system（"pause"）；输出的一个提示，此时只需按键盘上的任意一个键，这个小黑窗口就会关闭。
　　如果想让“ni hao”分两行显示，则只需要将printf（"ni hao"）；改为 printf（"ni \n hao"）;这里的“\n”表示让光标“换行”。注意，这里的“\”向右下角斜，它在键盘上的位置，通常是在回车键的上方。好，赶快尝试一下吧。运行结果如图2-14所示。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {           printf("ni\nhao");           system("pause");           return 0;
    }

图2-14　分行后的运行结果
当然也可以让“请按任意键继续．..”在下一行显示，只需将 printf（"ni\nhao"）；改为printf（"ni \n hao\n"）；即可，去试一试吧。
 　一起来找茬
下面这段代码是让计算机在屏幕上输出hi。其中有3个错误，快来
改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )     {           print(hi)           system("pause");           return 0;
    }
 　更进一步，动手试一试
1．尝试让计算机显示下面这些图形。
    ＊
    ＊＊
    ＊＊＊
    　＊
     ＊ ＊
    ＊   ＊
     ＊ ＊
    　＊
  　        ＊
    　     ＊
      　  ＊
    ＊   ＊
    ＊ ＊
　    ＊
　　2．如何让计算机说中文呢？让计算机像下面一样说“早上好”，应该怎么办？3．尝试让计算机显示下面这个图形。
    A
    BC
    DEF
    GHIJ
    KLMNO
    PQRSTU
    V
    W
    X
    Y
    Z
 　这一节，你学到了什么如何让计算机开口说话，以及让计算机开口说话的语句是什么？第3节　多彩一点　　在本章第2节中，我们学习了让计算机开口说话应使用printf语句。可以发现，计算机“说”出的话都是黑底白字，其实计算机的输出可以是彩色的，我们一起来看看吧。
　　注意，此处代码只能在Windows操作系统下编译运行。如果你使用的是本书推荐的C语言的软件“啊哈C”，那么你的代码肯定可以运行成功。下面来看看如何让颜色出现。
请尝试输入以下代码并运行，看看会发生什么。
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {       system("color 5");       printf("wa wa wa");       system("pause");       return 0 ;
    }
运行之后你发现了什么？底色仍然是黑色。但是，文字的颜色已经
变为“紫色”了，奥秘就在下面这行代码中。
    system("color 5");
　　在这句话中，“5”代表“紫色”，你可以尝试一下其他数字，看看分别是什么颜色。
既然字的颜色可以变，那么背景色是否可以变呢？尝试下面这段代
码：
    #include <stdio.h>     #include <stdlib.h>     int main()     {         system("color f5");         printf("wa wa wa");         system("pause");         return 0;
    }
运行成功后的界面如图2-15所示。图2-15　运行成功后的界面（此时背景应该为白色，文字颜色应该为紫色）
　　上面这段代码在原来的5前面加了一个f，这里的f代表背景色是白色。
　　那么设置背景色和文字颜色的方法是，在color后面加上两个一位数字，第一个数字表示背景色，第二个数字表示文字颜色。如果在color后面只加了一个一位数字，则表示只设置文字颜色，背景色仍然使用默认的颜色。
需要说明的是这里的一位数字其实是16进制的，它只能是0、1、
2、3、4、5、6、7、8、9、a、b、c、d、e、f中的某一个。
[题外话]“不看，也无伤大雅”
这里学习一个新知识——进制。
在现代数学中，我们通常使用十进制，即使用数字0、1、2、3、
4、5、6、7、8、9。9之后的数字便无法表示了，我们的解决方法是：使用“进位”来表示。例如，由于阿拉伯数字只到9，于是我们便进一位，当前这位用0表示，便产生了用10来表示“十”。因为是“逢十进一”，所以称为十进制。
而十六进制是“逢十六进一”，即使用0、1、2、3、4、5、6、7、
8、9、A、B、C、D、E、F来表示。0～9与在十进制时相同，但
是“十”在十六进制时用大写字母A表示，以此类推，“十五”在十六进制中用大写字母F来表示。F是“十六进制”中的最后一个，因此数字“十六”就表示不了。于是我们又采用刚才在十进制中表示不了就进一位的老办法，当前应该用0表示。“十六”在十六进制中表示为10。同理，“二十七”在十六进制中表示为1B。
　　在中国古代，很多朝代都是用十六进制作为日常计数的，例如，成语“半斤八两”的典故来源于十六进制；还有中国古代的算法是上面2颗珠子，下面5颗珠子。若上面每颗珠子代表数字5，下面每颗珠子代表数字1，那么每位的最大计数值是15, 15正是十六进制的最大基数。当使用算盘计数遇到大于15的时候，我们就需要在算盘上“进位”了。
其实在我们现代的日常生活中，也不都是“十进制”，例如，60秒为
1分钟，60分钟为1小时，就是用的六十进制。
 　一起来找茬
下面这段代码是让计算机在屏幕上输出绿底白字的hi。其中有4个
错误，快来改正吧！
    #include <stdio.h>
    #include <stdlib.h>     int main( )
    {
          system(color f2)           print("hi");           system("pause");           return 0;
    }
 　更进一步，动手试一试
1．尝试让计算机打印这个小飞机图案（绿底白字）。
           ＊
           ＊＊
    ＊     ＊＊＊
    ＊＊   ＊＊＊＊
    ＊＊＊＊＊＊＊＊＊＊＊＊＊＊
    ＊＊   ＊＊＊＊
    ＊     ＊＊＊
           ＊＊
           ＊
2．尝试让计算机打印这个小队旗图案（白底红字）。
    A
    I＊
    I＊＊
    I＊＊＊
    I＊＊＊＊
    I＊＊＊＊＊
    I
    I
    I
    I
 　这一节，你学到了什么
让计算机打印出来的字符有不同颜色的语句是什么？第4节　让计算机做加法
　　通过之前的学习，我们了解到让计算机说话是用“printf”，运用“printf”就可以让计算机想说什么就说什么了。在学会了“说话”之后，我们来看如何让计算机做数学运算，首先我们先让计算机做“加法”，就先算1+2吧。
回想一下小时候爸爸妈妈是如何教我们算1+2的呢？
　　妈妈说：“左手给你一个苹果，右手给你两个苹果，现在一共有几个苹果？”我们迅速地思考了一下，脱口而出：“3个苹果”。没错！我们首先用大脑记住左手有几个苹果，再用大脑记住右手有几个苹果，妈妈问一共有几个时，我们的大脑进行了非常快速的计算，将刚才记住的两个数进行相加，得到结果，最后将计算出的结果说出来。仔细分析一下，大致分为以下5个步骤。
（1） 用大脑记住左手的苹果数量；
（2） 用大脑记住右手的苹果数量；
（3） 我们的大脑将两个数字进行相加；
（4） 得到结果；
（5） 将结果输出。
在这期间，我们大脑一共进行了以下4个动作。
（1）两次输入：分别是记录左手和右手中苹果的数量；（2）存储了3个值：分别是记录左手和右手中苹果的数量和相加的结果；
（3） 进行了一次计算：相加；
（4） 进行了一次输出：把相加的结果输出。
如何让计算机做加法呢？同样也需要以上几个步骤。
首先来解决如何让计算机像我们的大脑一样记住一个数字。
　　其实计算机的大脑就像一个“摩天大厦”，有很多一间一间的“小房子”，计算机就把需要记住的数放在“小房子”里面，一个“小房子”里只能放一个数，这样计算机就可以记住很多数。好，我们来看一看，具体怎样操作。“=”赋值符号的作用就相当于一只手，把数字放到小房子中。
    int a, b, c;　　这句话就代表在计算机的“摩天大厦”中申请三间分别叫作a、b和c 的小房子（注意：int和a之间有一个空格，a、b与c之间分别用逗号隔开，末尾有一个分号表示结束）。
接下来，我们让小房子a和小房子b分别去记录两个数字1和2，具体
如下：
    a=1;     b=2;
　　说明：此处有一个“=”，这可不是等于号，它叫作给予号（也称为赋值号），类似于一个箭头“←”，意思是把“=”右边的内容赋给“=”左边。例如，把1这个数给小房子a，这样一来计算机就知道小房子a里面存储的是数字1了。
　　然后，把小房子a和小房子b里面的数相加，再将其结果放到小房子 c中。
    c=a+b;
　　计算机会将这个式子分两步执行：第一步先将a+b算出来，第二步再将a+b的值赋给“=”右边的c。至此，就差不多完成了，我们总结一下：
    int a, b, c;     a=1;     b=2;     c=a+b;
　　很多同学是不是以为，现在已经全部完成了？你忘记了最重要的一步，先别急着往下看，想一想忘记了什么？
啊！你忘记了把答案输出。
　　想一想如果妈妈问你一加二等于多少时，你说：“我算出来了，但是不想告诉你！”的话，估计少不了挨一顿揍了，不要啊！
让我们回忆一下，如何让计算机把结果输出。
　　对，使用printf语句。那怎么把小房子c里面存储的数输出呢？根据本章第2节学到的知识，只要把要输出的内容放在双引号里面就可以了，代码如下：
    printf("c");
猜一猜此时计算机会输出什么？
对，无情地输出了一个c。那怎样输出c里面的值呢？
这时我们要让另外一个角色出场了。
    %d
“%d”其实是一个“讨债的”，或者也可以说是“要饭的”。它的专职工
作就是向别人“要钱”！那我们应该怎么使用它呢？
    printf("%d", c);将“%d”放在双引号之间，把小房子c放在双引号后面，并且用逗号
隔开。
这时printf发现双引号里面是个“讨债的”，就知道此时需要输出一个
具体的数值，而不是符号，就会向双引号后面的小房子c索取具体的数值了。
好了，最后加上C语言的代码框架，计算机进行加法运算的完整代
码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()     {           int a, b, c;           a=1;           b=2;           c=a+b;           printf("%d", c);           system("pause");           return 0;
    }
现在赶紧去试一试吧。
 　一起来找茬下面这段代码是让计算机计算321-123的结果。其中有7个错误，快
来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int mian( )     {           int a, b, c;           a=321           b=123           c=b-a           print("%d", c)           system("pause");           return 0;
    }
 　更进一步，动手试一试
1．如果要进行3个数相加的运算，该怎样做呢？例如：5+3+1=?
我们可以把上面的程序进行简单地改变，申请4个小房子分别叫作
a、b、c和d。用a、b、c分别存放3个加数，用d存放它们的和。代码如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()     {           int a, b, c, d;           a=5;           b=3;           c=1;           d=a+b+c;           printf("%d", d);
          system("pause");           return 0;
    }
如果要10个数相加岂不是得定义11个小房子？那也太麻烦了！对，
目前我们只能这样，但是在后面的学习中，会有更为简单的方法。
2．用计算机算出下面3个算式。
    123456789+43214321
    7078＊8712
    321＊(123456+54321)
 　这一节，你学到了什么
1．如何申请一个小房子来存储数值？
2．如何用printf输出小房子中的数值？第5节　数字的家——变量
从本章第4节中，我们了解到计算机使用一个个的小房子来记住数
字。计算机有很多不同种类的小房子。
    int a;
代表向计算机申请一个小房子，用来存放数值，小房子的名字叫作a。
int和a之间有一个空格，a的末尾有一个分号，表示这句话结束。
如果要申请多个小房子，则要在a后面继续加上b和c，用逗号分
开。例如：
    int a, b, c;
　　这里有一个小问题，就是给申请的“小房子”起名字。原则上可以随便起：可以是单独的字母，如a、b或x；可以是多个字母的组合，如
aaa、abc或book；也可以是字母和数字的组合，如a1或abc123。当然也有一些限制，如果你想知道，请看附录A。到这里，可能还有很多同学想问，int究竟是什么意思呢？
　　其实，int控制小房子用来存放的数的类型，表示你目前申请的小房子只能存放整数。
int是英文单词integer（整数）的缩写。
如果要放小数该怎么办？我们用float来申请一个小房子，用来存放小数，形式如下：
    float a;
这样，小房子a就可以用来存放小数了，例如：
    float a;     a=1.5;
    printf("%f", a);
就表示申请一个用来存放小数的小房子a，里面存放了小数1.5。
注意：在C语言中，小数称作浮点数，用float表示。
　　之前在用printf语句输出整数时，使用的是“%d”。此时需要输出小数，要用“%f”。
　　好了，我们来总结一下，这里的“小房子”在我们C语言的专业术语中称为变量。int和float说明小房子是用来存放何种类型的数，我们这里将其称为“变量类型”或者“数据类型”。
　　类似int a；或者float a；的形式，我们称作“定义变量”，它们的语法格式如下：
  【口语】 小房子的类型　小房子的名称 , 小房子的名称 ；
  【术语】  变量的类型   变量的名称  ,  变量的名称  ；
  【代码】      int          a       ,      b     ;
　　现在我们知道，int a；表示申请一个用来存放一个整数的小房子a，即定义一个整型变量a来存放整数；而float a；则表示申请一个用来存放一个小数的小房子a，即定义一个浮点型（实型）变量a来存放浮点数（小数）。再来看另外一个有趣的问题，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()     {           int a;           a=1;           a=2;           printf("%d", a);
          system("pause");           return 0;
    }
请问计算机执行完上面的代码后，将会输出1还是2？　　尝试过后你会发现，计算机显示的是2，也就是说小房子a中的值最终为2。通过观察代码可以发现，我们首先将1放入小房子a中，紧接着又将2放入小房子a中，那么请问原来小房子中的1去哪里了呢？答案
是，被新来的2给覆盖了并且已经消失了。也就是说，小房子a中有且仅能存放一个值，如果多次给小房子a赋值，小房子a中存放的将始终是最后一次赋的值。例如：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {           int a;           a=1;           a=2;           a=3;
          a=4;           a=5;           a=6;           printf("%d", a);
          system("pause");           return 0;
    }
计算机运行完上面这段代码后最终将输出6。也就是说小房子a中的
值最终为6，前5次的赋值全部被覆盖了。一个更有意思的问题来了，请继续看下面的代码：
    #include <stdio.h>     #include <stdlib.h>     int main()     {           int a;           a=7;           a=a+1;           printf("%d", a);
          system("pause");           return 0;
    }
　　计算机运行完上面这段代码后最终将输出8。也就是说小房子a中的值最终为8。计算机在执行完a=7这句话后，小房子a中存储的值为7，之后计算机又紧接着运行了a=a+1。运行完a=a+1后，小房子a中的值就变为8了。也就是说a=a+1的作用是把小房子a中的值在原来的基础上增加
1，我们来分析一下这句话。
　　对于a=a+1计算机分两步执行，这句话中有两个操作符，第一个是“+”，另一个是“=”（赋值号），因为“+”的优先级要比“=”高，因此计算机先执行a+1，此时小房子a中的值仍然为7，所以a+1的值为8。紧接着计算机就会执行赋值语句，将计算出来的值8再赋值给a，此时a的值就更新为8。好啦，猜猜下面的程序，计算机最终会输出多少？
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {
        int a;         a=10;         a=a＊a;         printf("%d", a);
        system("pause");         return 0;
    }
尝试过了吗？想一想为什么a最终的值为100。
注：所有运算符的优先级详见附录B。
 　一起来找茬
　　下面这段代码是让计算机计算1.2×1.5的值。其中有5个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, b, c         a=1.2;         b=1.5;         c=a＊b;
        print("%d", c)         system("pause");         return 0;
    }
 　更进一步，动手试一试
1．进行两个小数的加法运算，例如：5.2+3.1=？代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()     {         float a, b, c;         a=5.2;         b=3.1;         c=a+b;         printf("%f", c);
        system("pause");         return 0;
    }
　　请注意，之前在printf语句中输出整型变量的值时，使用的是“%d”，此时需要输出的是实型变量的值，因此要用“%f”。 2．通过计算机把下面3个式子算出来吧！
    1.2+2.3+3.4+4.5
    1.1＊100
    10.1＊(10＊10)
 　这一节，你学到了什么
1．如何定义一个用来存放小数的变量？
2．如何让一个小房子a（变量a）中的值增加1？第6节　数据输出——我说咋地就咋地
　　在本章第4节中，我们已经学会了如何让计算机做加法运算，但是计算机在输出的时候，只显示了一个结果，这样不够人性化。如果能将整个算术等式输出就好了，例如：1+2=3。那应该怎么写呢？
新的代码：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         a=1;         b=2;         c=a+b;         printf("%d+%d=%d", a, b, c);
        system("pause");         return 0;
    }
原来的代码：
    #include <stdio.h>     #include <stdlib.h>     int main()     {         int a, b, c;         a=1;         b=2;         c=a+b;         printf("%d", c);         system("pause");         return 0;
    }
仔细阅读这些代码你会发现，新的代码和原来的代码只有一个
printf语句不一样。好，我们现在来仔细分析一下printf（"%d+%d=%d", a, b, c）;。
printf语句只会输出双引号里面的部分，双引号之外的部分只是对
双引号内的部分起到补充说明的作用。
例如，printf（"%d+%d=%d", a, b, c）；这行语句，双引号里面的部
分是%d+%d=%d，那么计算机在输出的时候就严格按照%d+%d=%d来执行，输出的形式必然是%d+%d=%d。
　　当计算机遇到第1个“%d”时，知道“讨债的”来了，于是它便向双引号后面的变量讨债，排在第1个的是a，那么就向a讨债。a的值是1，于是第1个“%d”得到的便是1。
第2个是“+”，那么照样输出。
　　第3个又是“%d”，同样到双引号的后面去讨债，因为排在第1个的a 已经被讨过债了，因此向排在第2个的b讨债。b的值是2，于是这个“%d”得到的便是2。
第4个是“=”，照样输出。
　　第5个还是“%d”，同样到双引号的后面去讨债，因为排在第1个的a 和排在第2个的b已经被讨过债了，因此向排在第3个的c讨债。c的值是
3，于是最后这个“%d”得到的便是3。
最后输出的内容是1+2=3。
　　请注意，通常双引号内部“%d”的个数，和后面变量的个数是相等的，它们是一一对应的。如果没有一一对应，从C语言的语法角度来讲是没有错误的，但这不合常理，最好避免这样的情况出现。
 　一起来找茬
下面这段代码是让计算机分别计算10-5与10+5的值，并分两行显
示，第一行显示差，第二行显示和。其中有3个错误，快来改正吧！
    #inlcude <stdio.h>
    #include <stdlib.h>     int mian( )
    {
        int a, b, c;         a=10;         b=5;         c=a-b;         printf("%d/n", c);         c=a+b;         printf("%d", c);         system("pause");         return 0;
    }
 　更进一步，动手试一试
指定两个数，输出这两个数的和、差、积与商。例如，指定两个数
9和3，输出9+3=12、9-3=6、9×3=27、9/3=3。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         a=9;         b=3;         c=a+b;         printf("%d+%d=%d\n", a, b, c);

        c=a-b;         printf("%d-%d=%d\n", a, b, c);         c=a＊b;         printf("%d＊%d=%d\n", a, b, c);         c=a/b;         printf("%d/%d=%d\n", a, b, c);         system("pause");         return 0;
    }
第7节　数据输入——我说算啥就算啥
　　我们已经学会了如何做一个加法计算器，但是目前的加法计算器还不够人性化，每次计算两个数的和时，都需要修改C语言代码，然后重新编译运行才能得到结果，很显然这样的加法计算器是不会有人喜欢用的，那如何让使用者自己任意输入两个数就可以直接得到结果呢？
　　我们知道，让计算机说话用printf，那么让计算机学会听用什么呢？scanf将会把听到的内容告诉你的程序。
　　计算机“说话”的过程，我们称为“输出”，计算机“听”的过程，我们则称为“读入”。好，下面来看看，计算机是如何读入的。
scanf的语法与printf语法类似，例如，我们要从键盘读入一个数，
放在小房子a中，代码如下：
    scanf("%d", &a);
　　你瞧，与输出小房子a的语句printf（"%d", a）；是差不多的，只有以下两处不同。
第一处是：读入是使用scanf这个词，而输出是使用printf这个词。
第二处是：读入比输出在a前面多了一个“&”符号。
“&”符号我们称为“取地址符”，简称“取址符”。它的作用是得到小房子a的地址。
　　scanf（"%d", &a）；这句话可以理解为：我们要从外界向计算机的内部传送一个数值，并需要将这个值存放到指定的“编号为a”的盒子中。这样我们就需要知道小盒子a在计算机内部的地址。就像邮递员送信一样，要传送的数据就是信件，小盒子a就是信箱编号。　　那你可能要问，为什么在读入的时候要得到小房子a的地址，而输出的时候却不需要呢？在读入数据的时候，计算机需要把读入的值存放在小房子a（也就是变量a）中，此时需要知道你指定的这个小房子a的地址，才能把值准确地放进其中；但是在输出的时候，值已经在小房子 a中了，因此可以直接输出到屏幕上。
　　打一个比方：假如你要去一个教室上课，那么在上课之前你需要知道这个教室的地址，这样你才能去；但是如果下课了，你需要走出这个教室，因为此时你已经在教室中，所以就不再需要这个教室的地址。
　　如果要从键盘读入两个数，分别给小房子a和小房子b呢？这里有以下两种写法。
第一种：
    scanf("%d", &a);     scanf("%d", &b);
第二种：
    scanf("%d%d", &a, &b);
第二种的写法较为简便，两个“%d”之间不需要空
格，“&a”和“&b”之间用逗号隔开。
从键盘读入两个数，输出这两个数的和的完整代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         scanf("%d%d", &a, &b);         c=a+b;         printf("%d+%d=%d", a, b, c);
        system("pause");         return 0;
    }
　　好了，总结一下，在C语言中printf是计算机“说出去的”，也就是计算机需要告诉你的；而scanf是计算机“听进来的”，也就是你需要告诉计算机的。
　　接下来，我们要让“加法计算器”更加人性化——带有提示的读入和输出。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;
        printf("这是一个加法计算器，欢迎您使用\n");
        printf("--------------------------------\n");
        printf("请输入第一个数（输入完毕后请按回车）\n");
        scanf("%d", &a);
        printf("请输入第二个数（输入完毕后请按回车）\n");
        scanf("%d", &b);         c=a+b;         printf("它们的和是%d", c);
        system("pause");         return 0;
    }
 　一起来找茬
下面这段代码是从键盘读入两个整数，并输出它们的和。其中有6
个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )     {         int a, b, c;         scanf("%d", a, b)         c=a+b         printf("%d/n", c);         system("pause");         return 0;
    }
 　更进一步，动手试一试从键盘读入两个数，并输出这个两个数的和、差、积与商。    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         scanf("%d%d", &a, &b);         c=a+b;         printf("%d+%d=%d\n", a, b, c);         c=a-b;         printf("%d-%d=%d\n", a, b, c);         c=a＊b;         printf("%d＊%d=%d\n", a, b, c);         c=a/b;         printf("%d/%d=%d\n", a, b, c);         system("pause");         return 0;
    }
　　请注意除法运算。在C语言中，当除号“/”左右两边都是整数时，商也只有整数部分。例如，5/3的商是1,2/3的商是0。
 　这一节，你学到了什么
如何从键盘读入一个数到小房子中？
第8节　究竟有多少种小房子
在之前的几节中，我们已经知道计算机如果想“记住”某个值，就必
须在它的大脑“摩天大厦”中，申请一种小房子。例如：
    int  a, b, c ;
即申请3种小房子分别叫作a、b和c。这3种小房子只能用来存放整数
（整型数据）。
再例如：
    float  a, b, c ;
即申请3种小房子a、b和c。这三种小房子只能用来存放小数（浮点型数据）。
　　也就是说在计算机中，不同类型的数据需要相应类型的小房子来存储。　　那么计算机一共有多少种类型的小房子呢？我们来列举几种最常用的，如表2-1所示。
表2-1　C语言常用的数据类型数据类型名称
int
float
double
char


用来存放哪种数据
用来存放整数
用来存放浮点数
用来存放极大和极小的浮点数
用来存放字符


数据范围
?2147483648～
2147483647
±1.18×10?38 ～
±3.4×1038
±2.23×10?308 ～
±1.80×10308
256种字符

double也是用来存放小数的，那float和double有什么区别呢？请观察下面两段代码。
代码1：
    #include <stdio.h>
    #include <stdlib.h>
    int main()     {         float a;         a=3.1415926535897932;         printf("%.15f", a);
        system("pause");         return 0;
    }
代码2：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         double a;         a=3.1415926535897932;         printf("%.15f", a);
        system("pause");         return 0;
    }
　　通过观察，我们发现代码1和代码2的不同之处只有一点。代码1中是用float来申请小房子a，代码2中却是用double来申请小房子a。在输出
时，两段代码中printf里面所用的占位符都是“%f”。代码中“%”和“f”之
间的“.15”表示保留小数点后15位（四舍五入）。这里特别说明一下，在用scanf读入double类型数据时所用的占位符是“%lf”（注意此处不是数字
1而是字母l）而不是“%f”。
它们的运行结果分别如图2-16和图2-17所示。图2-16　代码1运行的结果图2-17　代码2运行的结果
怎么样，发现问题了吧？！代码1运行后输出的是
3.141592741012573，显然从小数点后第7位开始就不对了，而代码2运行后输出的是3.141592653589793，完全正确。因此我们可以发现double
可以比float表示得更精确。另外float和double表示的数的大小范围也不同，请大家自己去尝试。
　　在表2-1中我们发现有一个新的数据类型char，用char申请的小房子是用来存放字符的。    #include <stdio.h>     #include <stdlib.h>     int main()
    {         char a;         scanf("%c", &a);         printf("你刚才输入的字符是%c", a);
        system("pause");         return 0;
    }
　　我们输入一个字符x后按回车键，结果如图2-18所示，当然你也可以尝试一下别的字符。图2-18　输入一个字符并输出
想一想，对于上面这段代码，如果此时你输入的不是一个字母，而是一串字母，计算机会输出什么呢？很抱歉！计算机只会输出你输入的第一个字母。
　　有的同学可能要问，如果想存储一大串字符该怎么办呢？不要着急，我们将在后续章节中介绍如何存储一个字符串。
 　一起来找茬
下面这段代码是让计算机读入一个字符并把这个字符原样输出。其
中有3个错误，快来改正吧！
    #include <stdio.h>
    #include <stdlib.h>     int main( )
    {         char a;         scanf("%c", c);         printf("%d", c);         system("pause");         return 0;
    }
 　更进一步，动手试一试
　　从键盘读入一个字符，输出这个字符后面的一个字符。例如，输入字符a，输出字符b。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         char a;         scanf("%c", &a);         printf("后面的一个字符是%c", a+1);
        system("pause");         return 0;
    }
思考一下，为什么一个字符后面的字符就是该字符加1呢？
 　这一节，你学到了什么
1．double是什么类型？
2．如何存储一个字符？
第9节　拨开云雾见月明
　　通过前面的学习，我们已经知道计算机如果想“记住”某个值，就必须在计算机的大脑“摩天大厦”中，申请一个小房子。例如，之前我们需要计算任意两个数的和，程序是这样写的：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         scanf("%d%d", &a, &b) ;         c=a+b;         printf("%d+%d=%d", a, b, c);
        system("pause");         return 0;
    }
其实这个小房子c是多余的，可以直接写成：
    printf("%d+%d=%d", a, b, a+b);
代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b;         scanf("%d%d", &a, &b);         printf("%d+%d=%d", a, b, a+b);
        system("pause");         return 0;
    }
当然，如果你只想计算4+5的值，可以更简单：
    #include <stdio.h>     #include <stdlib.h>     int main()     {         printf("%d",4+5);         system("pause");         return 0;
    }
如果希望计算4+（6-3）×7的值，可以直接这样写：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         printf("%d",4+(6-3)＊7);         system("pause");         return 0;
    }
第10节　逻辑挑战1：交换小房子中的数
　　假如在计算机中我们已经有两个小房子（变量）分别叫作a和b，并且它们都已经有了一个初始值，但是现在希望将变量a和变量b中的值交换，该怎么办呢？
先来看一段代码：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b;         scanf("%d%d", &a, &b);         printf("%d %d", a, b);
        system("pause");         return 0;
    }
　　上面这段代码是从键盘读入两个数，然后将这两个数输出。例如，如果你输入的是5和6，那么输出的也是5和6。可是，我们现在的需求是将变量a和b中的数交换后输出，也就是说如果读入的是5和6，那么输出的应该是6和5才对。应该怎么办呢？来看一段代码：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b;         scanf("%d%d", &a, &b);         a=b;         b=a;         printf("%d %d", a, b);
        system("pause");         return 0;
    }
　　上面的代码企图通过a=b; b=a；语句将变量a和变量b中的值交换，如果你已经运行过上面的代码，就会发现交换并没有成功，变量b的值没有变化，反而是变量a的值变成了变量b的值，这是为什么呢？
我们来模拟一下计算机运行的过程。
int a, b；指计算机会申请两个小房子（变量），分别叫作a和b。
　　scanf（"%d%d", &a, &b）；指从键盘读入两个数，分别赋值给变量 a和变量b。假如我们从键盘读入的两个数分别是5和6，那么变量a中的值就是5，变量b中的值就是6。 a=b；指计算机会将变量b中的值给变量a，变量a中的值也变成了
6。变量a中原来的5被新来的6给覆盖了，也就是说原来变量a中的5丢失了。
　　b=a；指计算机会将此时变量a中的值给变量b，此时变量a中的已经是6了，所以变量b的值其实还是6。　　最终，变量a和变量b中的值都为6。那我们要怎么改呢？通过上面我们对计算执行过程的模拟，我们发现，主要问题是：计算机在执行完 a=b；这个语句后，原先变量a中的值被弄丢失了。那我们只要在执行 a=b；这个语句之前，先将变量a的值保存在另外一个临时变量中就可以了，例如，保存在变量t中。代码如下：
    t=a;     a=b;     b=t;
先将变量a中的值给变量t，变量t中的值就变为5（假如原来变量a中是5，变量b中是6），然后再将变量b中的值给变量a，变量a中的值就变为6，最后将变量t中的值给变量b，此时变量b中的值就变为5。成功！通过一个变量t作为中转站，我们已经成功地将变量a和变量b中的值进行了交换。完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, t;         scanf("%d%d", &a, &b);
        t=a;         a=b;         b=t;         printf("%d %d", a, b);
        system("pause");         return 0;
    }
 　一起来找茬
　　下面这段代码是让计算机读入两个整数，分别放到变量a和变量b 中，并将变量a和变量b中的数交换。其中有两个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, b;         scanf("%d%d", &a, &b);         t=a;         b=a;         b=t;         printf("%d %d", a, b);         system("pause");
        return 0;
    }
 　更进一步，动手试一试
　　在本节我们介绍了如何将两个变量的值进行交换，方法是增加一个临时变量来作为中转。你有没有想过，在不增加任何新变量的情况下是否也可以完成呢？来看看下面的代码吧。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b;         scanf("%d%d", &a, &b);         a=b-a;         b=b-a;         a=b+a;         printf("%d %d", a, b);
        system("pause");         return 0;
    }
请思考一下，为什么通过a=b-a; b=b-a; a=b+a；也可以将变量a与变量b中的值交换呢？第11节　天啊！这怎么能看懂
先来看一段代码：
    #include<stdio.h>   #include<stdlib.h>   int   main(){   i nt   a, b, c; scanf("%d%d", &a, &b); c=a+b; printf("%d", c); system("pause")
; return 0; }
　　怎么样，你看懂了吗？这段代码的意思其实就是从键盘读入两个整数并且输出它们的和。不错，上面的这段代码从语法角度来讲没有任何错误，编译器也可以对其编译运行，也就是说计算机可以准确无误
地“认识”这段代码，但是我们会看得比较吃力。一段优秀的代码，不仅仅要让计算机“看懂”，也要让我们可以看懂。再来看看下面这段代码是不是更容易让人们理解呢。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         scanf("%d%d", &a, &b);         c=a+b;
        printf("%d", c);
        system("pause");         return 0;
    }
　　这里需要指出的是，这里的int a, b, c；前面与上一行相比，多了4个空格。其实我在输入代码的时候，并不是输入4个空格，而是输入了一
个Tab [3] 。使用Tab来调整你的代码格式，是一名优秀的程序员必须要养成的习惯。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;
        a=1; //将变量a赋初始值         printf("%d", a);         system("pause");         return 0;
    }
　　在上面的代码中，“//”表示注释，它将告诉编译器从“//”开始一直到本行末尾的内容都是没有用的。注释的主要作用是给程序员看的，通常用来对一行代码进行解释说明或备注。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=1; //将变量a赋初始值
        //printf("%d", a);         system("pause");         return 0;
    }
　　上面的代码有两处注释，第1处注释我们讲过，主要是用来解释说明本行代码的作用。第2处的注释是将本来有用的代码printf（"%d",
a）；给注释掉，可以理解为“临时性删除”，就是告诉编译器
printf（"%d", 	a）；没有用。你可能要问为什么不直接删除呢？因为有时我们并不希望真正删除，只是暂时不需要，以后说不定还要再用，如果删除了就找不回来了，如果我们合理地利用“//”进行注释，那么计算机就不会运行这句话，而是理解这句话是给程序员看的。如果我们以后又要使用这句话，只需将这句话前面的“//”去掉就可以了，这样是不是很方便呢。
有效地在代码中添加注释，可以让你的程序更具可读性。
“//”只能注释到本行末尾，如果要注释多行，就要在每行上写“//”。其实注释还有另外一种，以“/*”开始一直到“*/”结束，中间的内容编译器都不会理睬。使用“/* */”的好处就是它可以跨行。
例如，下面两段代码的效果是相同的：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=1;
        //a=2;
        //a=3;
        //a=4;         //a=5;         printf("%d", a);         system("pause");         return 0;
    }
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;
        a=1;         /＊         a=2;         a=3;         a=4;         a=5;         ＊/         printf("%d", a);         system("pause");         return 0;
    }
上面两段代码中变量a的值最后还是1。再来看一段代码：
    int a;     a=1;
上面这段代码是定义一个整型变量（小房子）a，并且给变量a赋一
个初始值1。我们以后会经常遇到在定义一个变量（小房子）之后，给其赋初始值的情况，可以简写如下：
    int a=1;多个变量也类似：
    int a=1, b=2, c=3;
浮点型和字符型也类似：
    float a=1.1;     char c='x';
　　需要注意的是，在给浮点型变量赋初始值的时候必须是一个小数，也就是说必须有小数点。在给字符型变量赋初始值的时候，字符两边需要加单引号，记住是单引号，不是双引号。在上面的代码中我们希望把字符x赋值给字符变量c，所以我们在字符x的左右两边加上了单引号。
编程也是一门艺术，需要追求简洁、高效而且优美的代码，一名优
秀的程序员往往也是一名艺术家。[1] “C语言编译器”的作用是把我们写的程序“变”成一个“exe”，即可以让计算机直接运行的程序。这个“变”的专业术语称为“编译”。当你的程序“变”成一
个“exe”后，你就可以脱离“C语言编译器”直接运行你的程序。此时你就可以把你写的“exe”发给你的朋友和同学，让他们一起来使用你编写的程序。这里的程序从某种意义上来讲也可以称为“软件”。
[2] “啊哈C”是一款非常容易上手的C语言编程软件，使用的是GCC内核。界面简洁可爱，支持语法高亮、代码折叠、编译错误提示等。操作方便，上手快，特别适合C语言入门的初学者使用。
[3] Tab表示一个制表符，在编程中用Tab来代替空格是一个很好的习惯，可以让你的代码看起来更美。Tab键在字母Q键的左边，赶快试一试吧。
第3章较量才刚刚开始第1节　大于、小于还是相等　　和我们一样，计算机也可以判断大小。假如你告诉计算机有a和b两个数，计算机除了可以告诉你这两个数的和、差、积和商，还可以告诉你谁大、谁小。现在我们就来瞧瞧计算机是如何判断谁大谁小的。
在此之前，我们需要先说明一下在计算机中用来判断两个数的关系
的符号，即关系运算符，一共有如下6个：
    ==  相等     >   大于     <   小于     >=  大于等于
    <=  小于等于
    !=  不等于
　　需要特别注意的是，在计算机中，一个等于号“=”表示赋值，两个等于号“==”表示判断是否相等，同学们在编写代码的时候千万不要写错。一个感叹号加一个等于号“!=”表示“不等于”。此外计算机只有大于等于号“>=”和小于等于号“<=”，没有等于大于号和等于小于号，即不存在“=>”和“=<”，这一点请一定要注意。
例如，以下写法是正确的：
    5>=4
    7! =8     a<b     c==d
以下写法是错误的：
    4=<7
    8=>3
第2节　判断正数
　　假如你现在想让计算机判断一个整数是否为正数，如果是则显示 yes，不是则什么都不显示，应该怎么办呢？
　　下面方框中的内容，就是让计算机判断一个数是否为正数的“算法”。
首先，计算机需要有一个小房子（即变量）来存储这个数。
然后，你需要告诉计算机这个数是什么？接下来，计算机需要判断这个数是否为正数。
最后输出计算机的判断结果。
　　算法其实就是解决问题的方法（千万要被这个专业名词给吓住了）。
　　我们每遇到一个问题，首先需要思考的是解决这个问题的算法，也就是解决这个问题的方法和步骤。像上面一样一步一步地列出来，然后再将算法的每一步通过C语言来实现。
下面，我们就用C语言来实现上面的算法。
首先，计算机需要有一个小房子（即变量）来存储这个数。
　　可以用int 	a；来申请一个名字叫作a的小房子（即变量），来存储需要判断的数。
然后，需要告诉计算机这个数是什么？
　　可以用scanf（"%d", &a）；来读入一个数并将这个数存储在小房子a中。
接下来，计算机需要判断这个数是否为正数。
这可怎么办？不要紧，待会儿再来分析。
最后输出计算机的判断结果。
如果是正数则显示yes，使用printf（"yes"）;。
　　好，现在我们集中精力来解决刚才的第3步——判断存放在小房子a 中的数是否为正数。
想一想，我们是如何判断一个数是否为正数的？要从正数的定义出发，如果一个数大于0，就是正数。好，计算机也是这么想的，哈哈。
如果a大于0，则显示yes。
接下来，尝试用C语言来实现。
其中“如果”在C语言中用if来表示。代码如下：
    if (a>0) { printf("yes"); }
因为当a>0成立时候，这里只需要执行一条语句，此时{ }也可以省
略不写，如下：
    if (a>0)  printf("yes");
要注意的是，当且仅当条件成立时 只需要执行一条语句 才能省略{
}。 为什么这么说？不要着急，等你看完本(?)章(?)的(?)第(?)七(?)节(?)就(?)知(?)道(?)了。
当然，如果你觉得写在同一行很不爽，写成两行也是可以的：
    if (a>0)     printf("yes");　　更好的写法应该是在printf（"yes"）；前面空4个空格或者空1个 Tab，表示printf（"yes"）；是if （a>0）的一部分，当a>0条件成立时才执行printf（"yes"）；这条语句。
    if (a>0)         printf("yes");完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )     {         int  a;         scanf("%d", &a);         if (a>0)  printf("yes");         system("pause");         return 0;
    }
好了，赶快试一试吧。
假如我希望输入正数时显示yes，输入负数或0时显示no，应该怎么
办呢？若要实现上述要求，第3部分应改为：
如果（a大于0）显示yes 如果（a小于等于0）显示no
对应的C语言代码是：
    if (a>0)    printf("yes");     if (a<=0)   printf("no");
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int  a;         scanf("%d", &a) ;         if (a>0)    printf("yes");         if (a<=0)   printf("no");         system("pause");         return 0;
    }
此外，
    if (a>0)  printf("yes");
这句话更加完美的写法是：
    if (a>0)     {         printf("yes");
    }
所以判断正数的代码更好的写法是：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int  a;         scanf("%d", &a) ;         if (a>0)         {             printf("yes");
        }         if (a<=0)
        {             printf("no");
        }         system("pause");         return 0;
    }
最后，需要注意的是if （ ）后面是没有分号的，像下面这些写法都
是不对的！
    if (a>0) ;  printf("yes");
    if (a>0);         printf("yes");
    if (a>0);     {         printf("yes");
    }
至于为什么呢？这句话的意思是“如果什么成立，就做什么”，很明
显“如果什么成立”这句话只说了一半，所以if （ ）后面不能加分号，需要特别注意！ if语句的语法格式为：
    if (条件)
    {         语句1;         语句2;         语句 ……
    }
　　if后面一对圆括号中的内容是一个关系表达式，当表达式成立时执行后面花括号中的语句。
好了，赶快试一试吧。
 　一起来找茬
　　下面这段代码用来判断一个数是否小于或等于100，如果是则输出 yes。其中有3个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int  a;         scanf("%d", a) ;         if (a<100) ; printf("yes");         system("pause");         return 0;
    }
 　更进一步，动手试一试
假如我希望输入正数时显示yes，输入负数时显示no，输入0时显示
0，应该怎么办呢？
 　这一节，你学到了什么
if语句的基本格式是什么？
第3节　偶数判断
　　通过对本章第2节内容的学习，我们知道计算机是通过if语句来进行判断的。现在来尝试一下判断一个数是否为偶数。首先，先写出算法。
（1） 计算机需要有一个小房子（即变量）来存储这个数。
（2） 你需要告诉计算机这个数是什么？
（3） 计算机需要判断这个数是否为偶数。
（4） 计算机输出判断结果。
　　其中，在第3步你可能遇到一点小麻烦。我们想一下，什么是偶数呢？偶数就是能够被2整除的数，也就是说如果一个数除以2的余数为
0，那么这个数就是偶数。
那么我们现在只需要判断这个数除以2的余数是不是0，即：
如果a除以2的余数与0相等，则输出yes；如果a除以2的余数与0不相等，则输出no。
　　C语言中求余数的运算符号是“%”，所以判断一个数是否为偶数的C 语言代码就是：完整的C语言代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int  a;         scanf("%d", &a) ;         if (a%2==0)
        {           printf("yes");
        }         if (a%2! =0)
        {             printf("no");
        }         system("pause");         return 0;
    }
好了，应该尝试一下了。  　一起来找茬
　　下面这段代码用来判断一个数是否是7的倍数。其中有4个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int  a;         scanf("%d%d", &a) ;         if a%7=0         {             printf(yes);
        }         system("pause");         return 0;
    }
 　更进一步，动手试一试
如何判断一个数的末尾是不是0呢？如果是则输出yes（例如
120），不是则输出no（例如1 234）。
第4节　神器else
　　在本章第3节中，我们使用了两个if语句让计算机判断一个数是否为偶数，不出意外的话，我想你已经成功了。本节我们将学习另外一个语句来简化之前的代码，那就是神奇的else。
else表示否则，只能和if配合使用。
　　现在回到如何让计算机判断一个数是否为偶数这个问题上，回顾一下本章第3节的算法：
如果a除以2的余数与0相等，则输出yes；
如果a除以2的余数与0不相等，则输出no。
　　其实上面第2个“如果”中的条件“a除以2的余数和0不相等”正好就是第1个“如果”中的条件，即“a除以2的余数和0相等”的相反情况，因此我们用“否则”来代替，从而简化我们的代码。
如果a除以2的余数与0相等，则输出yes；否则，输出no。这里的“如果”在C语言中仍然用if来表示，这里的“否则”就用else来
表示。好，转换为如下代码：
    if (a % 2==0)   printf("yes");     else    printf("no");
其实，更漂亮的写法是下面这样的：
    if (a % 2==0)
    {         printf("yes");
    }     else     {         printf("no");
    }
从键盘读入一个整数判断它是否为偶数的完整代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()     {         int a;         scanf("%d", &a);         if(a%2==0)         {           printf("yes");
        }         else         {           printf("no");
        }         system("pause");         return 0;
    }
if-else语句的语法格式为：
    if (条件)
    {
        语句1;         语句2;         语句 ……;
    }     else     {         语句1;         语句2;         语句 ……;
    }
当条件为真的时候执行if后面的语句；当条件为假的时候执行else后
面的语句。
 　一起来找茬
下面这段代码用来判断一个数的末尾是否为7，例如：7、17、
127……如果是则打印yes，不是则打印no。其中有6个错误，快来改正吧。
    #include <stdio.h>     #include <stdlib.h>     int main()     {         int  a;         scanf("%d", &a);
        if (a%10=7);
        {           printf("yes")
        }         else;         {           prinf("no")
        }         system("pause");         return 0;
    }
 　更进一步，动手试一试
从键盘输入一个正整数，让计算机判断这个数是否为一位数（1～
9）。如果是则输出yes，否则输出no。
 　这一节，你学到了什么
if-else语句的基本格式是什么？
第5节　请告诉我谁大
　　在本章第4节中，我们学习了使用if-else语句来判断一个整数是否为偶数的方法。本节我们将学习如何从键盘输入两个整数，让计算机来判断哪一个整数较大，并把较大的那个整数输出来。例如，如果我们输入的是5和8，那么计算机输出8。
　　在学习“如何让计算机判断两个数中，谁更大”这个问题之前，先回顾一下第2章中如何从键盘读入两个整数并且算出它们的和的问题。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int  a, b, c;         scanf("%d%d", &a, &b);         c=a+b;         printf("%d+%d=%d", a, b, c);
    }
　　在上面这段代码中，我们输出的是“和”。那如何让计算机输出较大的一个数呢？我们仍然使用“如果”的方法。
　　首先还是定义3个变量：a和b用来存放输入的两个数，c用来存放a 和b中较大的那个。
    int a, b, c;
然后读入从键盘输入的两个数，分别存放到变量a和b中。
    scanf("%d%d", &a, &b);
接下来要注意了，我们将通过之前学过的“如果”和“否则”的方法，
来分情况讨论并判断谁更大。
    如果(a>b)   c=a;　　上面这两行代码是说明在a>b条件成立的情况下，我们将a的值赋给 c。但是a>b条件并不一定成立，所以我们还要告诉计算机在条件不成立的情况下，应该怎么办。
所以还要写：
    否则 c=b;
那么完整的代码如下：
    如果(a>b)    c=a;     否则         c=b;
　　总结一下，如果a>b成立，就将a的值赋给c，执行c=a。如果不成立，就执行“否则”部分，将b的值赋给c，执行c=b。
　　计算机通过“如果”和“否则”方法来分情况讨论。当a>b成立时，给出一种解决方案即执行某一个语句，这里是c=a;。当假设不成立的时候，给出另外一种解决方案即执行另外一个语句，这里是c=b;。
完整代码如下，赶快尝试一下吧。
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {
        int a, b, c;         scanf("%d%d", &a, &b);         if(a>b)         {             c=a;         }         else         {             c=b;         }         printf("%d", c);         system("pause");         return 0;
    }
 　一起来找茬
　　下面程序的功能是从键盘读入两个整数，判断它们是否相等，如果相等则输出yes，不相等则输出no。其中有6个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int  a;
        scanf("%d", &a, &b) ;         if (a=b) ;
        {             printf("yes") ;
        }         else ;         {             prinf("no") ;
        }         system("pause");         return 0;
    }
 　更进一步，动手试一试
　　从键盘输入两个正整数，让计算机判断第2个数是不是第1个数的约数。如果是则输出yes，不是则输出no。
第6节　逻辑挑战2:3个数怎么办
　　在本章第5节中，我们学习了如何从两个数中找出较大的一个数，那么3个数该怎么办呢？
　　在解决这个问题之前，先回忆一下，我们是如何在任意3个数中找出最大一个数的呢？例如，1322、4534、1201这3个数中哪个数最大？
　　怎么样，想出来了没有？千万不要告诉我，你是“一眼”就看出来的，如果是这样的话，请你在下列各数中“一眼”找出最大的那个来并告诉我。
怎么样，你“一眼”就看出来了吗？最大的数是多少？如果你可以在
1秒内看出来，那你一定不是地球人，最大的数是1232。
　　现在回归正题，我们从一个数列中寻找最大的一个数的时候，大致是从左到右、从上到下快速地扫描（当然，古代的中国人可能是从上到下、从右到左），在快速扫描的过程中，我们首先会记住第1个数，然后继续往下看，一直看到一个数比之前记住的最大的数还要大时，就转为记住这个更大的数，然后一直快速扫描完毕，找出最大的一个。下面来模拟这个过程。　　同理（我上学的时候最怕看到这个词语，没有办法，这里我也借用一下，因为我一时半会儿也想不到更好的词语了），我们来找出3个数中最大的数也是相同的原理。
　　计算机要想找出3个数中最大的数，其实就是模仿我们的思维过程。
首先，用3个变量a、b、c分别存放从键盘读入的3个数。
然后，先比较变量a和b的值，将较大的值赋给变量d。
　　再比较变量d和c的值，如果变量c的值大于变量d的值，则把变量 c的值赋给变量d。
最后输出变量d的值。
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {       int a, b, c, d;       scanf("%d %d %d", &a, &b, &c);
      if(a>b)       {           d=a;       }       else       {           d=b;       }
      if(d<c)       {           d=c;       }
      printf("%d", d);
      system("pause");       return 0;
    }
　　当然还有另外一种方法，就是分别比较变量a和b，以及变量a和c的关系……思路如下：
如果a>=b并且a>=c，则输出a；
如果b>a并且b>=c，则输出b；
如果c>a并且c>b，则输出c。
　　其中“并且”在C语言中用“&&”来表示，顺便说一下在C语言中“或”用“||”表示。“||”这个符号可能在键盘上不太好找，它通常
在“Enter”键的上面。在英文输入法状态下，按住“Shift”键不要松手，再按下“Enter”键上方的那个键，就会出现1个“|”，重复两次就可以啦。
“&&”表示逻辑“并且”
“||”表示逻辑“或”
　　想一想为什么不能像下面这样写？这样写会有什么问题？自己去探索吧！ [1]
如果a>=b并且a>=c，输出a；如果b>=a并且b>=c，输出b；
如果c>=a并且c>=b，输出c。
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {       int a, b, c;       scanf("%d %d %d", &a, &b, &c);       if (a>=b && a>=c)  printf("%d", a);       if (b>a && b>=c)  printf("%d", b);       if (c>a && c>b)  printf("%d", c);
      system("pause");       return 0;
    }
　　使用这种方法虽然代码比较简洁，但是在10个数中找出最大的数就很麻烦了。而从介绍的第1种方法则可以很容易地扩展出在10个数中找出最大的数的方法。
 　一起来找茬
　　下面这个程序的功能是从键盘读入一个整数，判断这个数是否为7 的倍数或者为末尾含7的数，例如：7、14、17、21、27、28……如果是则输出yes，不是则输出no。其中有5个错误，快来改正吧。
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {         int  a;         scanf("%d", &a) ;         if (a%7=0 | a%10=7) ;           printf("yes") ;         else           printf("no")         system("pause");         return 0;
    }
 　更进一步，动手试一试
1．从键盘任意读入3个整数，如何从中找出最小的一个？
2．从键盘任意读入4个整数，如何从中找出最大的一个？
　　3．从键盘输入一个年份（整数），判断这个年份是否为闰年，是则输出yes，不是则输出no。
第7节　逻辑挑战3：我要排序
　　在本章第6节中，我们学习了如何从3个数中找出最大的一个，现在有一个新的问题：如何从键盘输入任意3个数，并将这3个数从大到小排序呢？例如，无论你输入2 1 3、3 2 1、1 2 3还是3 1 2，计算机都能够输出3 2 1，这该怎么办呢？此时你先不要急着往下看，思考一下，通过我们之前学习的内容，你应该可以独立完成，赶快打开“啊哈C”去尝试一下吧！
　　怎么样？我想你应该已经做出来了，即使不是完全正确也应该有了大概的思路。如果你还没有尝试过，请赶快再去尝试一下吧，这样会让你更容易理解下面的内容，同时也可以比较一下你想的和我所讲的是否一样。顺便说一下，要想学好编程，最重要的就是要多尝试。
　　要想把3个数从大到小排序，其实有很多种方法，这里我们主要讲解两种方法。
下面来讲第1种方法，这是一种最直接的方法。
如果a>=b并且b>=c，打印a b c；如果a>=c并且c>b，打印a c b；如果b>a并且a>=c，打印b a c；如果b>=c并且c>a，打印b c a；如果c>a并且a>=b，打印c a b；
如果c>b并且b>a，打印c b a。
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, b, c;         scanf("%d %d %d", &a, &b, &c);         if (a>=b && b>=c)  printf("%d %d %d", a, b, c);         if (a>=c && c>b)  printf("%d %d %d", a, c, b);         if (b>a && a>=c)  printf("%d %d %d", b, a, c);         if (b>=c && c>a)  printf("%d %d %d", b, c, a);         if (c>a && a>=b)  printf("%d %d %d", c, a, b);         if (c>b && b>a)  printf("%d %d %d", c, b, a);         system("pause");         return 0;
    }
第2种方法，我称之为“换位法”。一共有3个变量，也就是说分别有
3个小房子a、b和c。我们的目标是在小房子a中存储最大的变量，在小房子b中存储次大的变量，在小房子c中存储最小的变量。
　　首先，我们先将小房子a中的数与小房子b中的数做比较，如果小房子a中的数小于小房子b中的数，则将小房子a和小房子b中的数交换。这样我们就可以确定，在小房子a和小房子b中，一定是小房子a中存的是比较大的数。关于如何交换两个变量的值，我们在第2章的第10节已经讨论过了，需要借助另外一个小房子t作为中转，代码如下：
    if (a<b)  {t=a; a=b; b=t; }
此时上面的这行语句不能简写为：
    if (a<b)  t=a; a=b; b=t;
　　因为，当a<b这个条件成立时我们需要连续执行3条语句，此时需要将这3条语句放在一对{ }括号中形成一个语句块，这样当条件a<b成立时，计算机才会依次执行t=a; a=b; b=t；这3条语句。如果不加{ }，当条
件a<b成立时计算机会执行t=a;，而a=b；和b=t；这2条语句计算机无论如何都会执行。因为if语句后面只能跟随一条语句或者一个语句块，使得a=b；和b=t；与if（a<b）这个条件没有任何关系。或许如下写法更容易让你理解：
    if (a<b)  t=a;
    a=b;     b=t;
　　所以当需要在if语句后面执行多条语句的时候，就必须要用{ }把所有需要执行的语句括起来，形成一个语句块，这样，计算机就知道它们是一起的了，要执行就一起执行，要么就都不执行。
　　接下来，需要再次比较小房子a和小房子c中的数。如果小房子a中的数小于小房子c中的数，则将小房子a和小房子c中的数交换。这样就可以确定，在小房子a和小房子c中，一定是小房子a中存的数的值比较大。
    if (a<c)  {t=a; a=c; c=t; }
　　经过将小房子a中的数分别与小房子b、小房子c中的数进行比较和交换，我们可以确定小房子a中存储的数一定是3个数中最大的。至于目前小房子b和小房子c中存的是什么值不重要，因为我们待会儿还要继续比较小房子b和小房子c中的值。重要的是已经确定小房子a中存储的已经是最大的数了。下面继续比较小房子b和小房子c中的值，将较大的值放在小房子b
中。
    if (b<c)  {t=b; b=c; c=t; }　　经过3轮比较，我们终于排序完毕，并将最大的数放在小房子a中，次大的数放在小房子b中，最小的数放在小房子c中。
下面是完整的代码，赶快来试一试吧。
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, b, c, t;         scanf("%d %d %d", &a, &b, &c);         if (a<b)  {t=a; a=b; b=t; }         if (a<c)  {t=a; a=c; c=t; }         if (b<c)  {t=b; b=c; c=t; }         printf("%d %d %d", a, b, c);         system("pause");         return 0;
    }
在第6章，我们将会学习选择排序，它就是基于这种方法的扩展。
题外话：有时像这样的写法，显得过于紧凑。
    if (a<b)  {t=a; a=b; b=t; }
我们可以改为如下较为宽松的写法：
    if (a<b)     {           t=a;           a=b;           b=t;
    }
其完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, b, c, t;         scanf("%d %d %d", &a, &b, &c);         if (a<b)         {             t=a;             a=b;             b=t;         }         if (a<c)
        {             t=a;             a=c;             c=t;         }         if (b<c)         {             t=b;             b=c;             c=t;         }         printf("%d %d %d", a, b, c);         system("pause");         return 0;
    }
 　一起来找茬
下面程序的功能是从键盘读入1个整数，如果这个数是奇数就输出
这个数后面的3个数，如果这个数是偶数，就输出这个数前面的3个数。例如，如果输入的整数是5，就输出678；如果输入的整数是4，就输出 321。其中有两个错误，快来改正吧。
    #include <stdio.h>
    #include <stdlib.h>
    int main()     {         int  a;         scanf("%d", &a) ;         if (a%2==1)           printf("%d ", a+1) ;           printf("%d ", a+2) ;           printf("%d ", a+3) ;         else           printf("%d ", a-1) ;           printf("%d ", a-2) ;           printf("%d ", a-3) ;         system("pause");         return 0;
    }
 　更进一步，动手试一试从键盘读入任意4个整数，将其从小到大输出。
第8节　运算符总结
　　通过前面的学习，我们了解了C语言中的许多运算符，有算术运算符“+”、关系运算符“==”和逻辑运算符“&&”、“||”。下面我们来总结一下，如表3-1所示。
表3-1　运算符总结名称
+
?
*
/
>
<
==
>=
<=
!=
&&


作用
加
减
乘
除
大于
小于
等于
大于等于
小于等于
不等于
与

||	或
!


非

第9节　1＞2究竟对不对
　　幼儿园的小朋友大概都知道1>2这个关系表达式是不成立的。对C 语言来讲，1>2这个关系表达的写法并没有任何错误，只不过它是假的关系表达式。如果喜欢，你也可以写11<10，相信你还可以写出很多这样假的关系表达式。可是你千万不要以为类似于11<10这样的假的表达式没有任何意义，在第4章你会发现它大有用途。
　　此外，2>=2这个关系表达式是真的，因为它表示的是2大于2或者2 等于2，只需满足其中任意一个条件就是真的关系表达式。类似于1<=2 这样的表达式也是真的。
请看下面这段代码：
    if (1>2)
    {         printf("yes");
    }     else
    {         printf("no");
    }
　　上面这段代码表示，如果1>2成立，也就是说如果1>2这个关系表达式是真的，则输出yes，否则输出no。很显然1>2是假的，计算机会输出 no。这个应该很容易理解。但是看到下面这段代码你肯定会晕：
    if (1)     {         printf("yes");
    }     else     {         printf("no");
    }
你猜计算机会输出什么？去试一试！如果是下面这样呢？
    if (-5)     {         printf("yes");
    }     else     {         printf("no");
    }
你猜计算机输出了什么，去试一试吧。
如果是这样呢？代码如下：
    if (0)
    {         printf("yes");
    }     else
    {         printf("no");
    }
计算机又输出了什么呢？
　　如果上面的3段代码你都尝试过，你会发现前两段代码都是输出 yes，也就是说，计算机认为前两个代码中if后面圆括号内的关系表达式都是成立的，是真的。第3段代码输出的是no，即认为第3段if后面一对圆括号内的关系表达式不成立，是假的。
　　这时你可能会觉得奇怪了，关系表达式不应该是一个式子吗，至少也应该有一个“>”、“<”或“==”之类的运算符才对啊。为什么单独一个数字也有真假呢？
　　这个确实很奇怪，计算机就是认为1和-5是真的，0是假的。其实在 C语言中，对于某一个数讨论真假时，只有0是假的，其余都被认为是真的。很显然，如下3个程序都是打印yes：
    if (8)     {         printf("yes");     }     else     {         printf("no");     }
    if (1000)     {         printf("yes");     }     else     {         printf("no");     }
    if (-123)     {         printf("yes");
    }
    else     {         printf("no");
    }
只有下面这个程序才会打印no：
    if (0)     {         printf("yes");     }     else     {         printf("no");
    }
第10节　讨厌的嵌套
if-else语句的“嵌套”就是在一个if-else语句中再“嵌套”另外一个if-
else语句。在讲“嵌套”之前我们先回忆一下本章第6节中的一个例子：如何在三个数中找出最大的一个数。
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, b, c;         scanf("%d %d %d", &a, &b, &c);         if (a>=b && a>=c)  printf("%d", a);         if (b>a && b>=c)  printf("%d", b);         if (c>a && c>b)  printf("%d", c);
        system("pause");         return 0;
    }
　　在上面的代码中，我们使用了“&&”这个逻辑关系运算符号来解决两个条件同时“满足”的需求。其实还有另外一种方法来解决这个问题。
    if(a>=b && a>=c)         printf("%d", a);
例如，上面这段代码，可以用“嵌套”的方式写成：
    if(a>=b)     {       if(a>=c)       {           printf("%d", a);
      }
    }
其意思是：当a>=b条件满足时，再进一步讨论a与c的关系（如果
a>=c也成立的话，就打印a）。
接着往下想，如果此时a>=b已经成立，但是a>=c不成立的话，是不
是就意味着在a、b、c中，c是最大值呢？答案是肯定的。代码如下：
    if(a>=b)     {       if(a>=c)
      {
          printf("%d", a);
      }       else       {           printf("%d", c);
      }
    }
那如果第一个条件a>=b不成立呢？完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         scanf("%d %d %d", &a, &b, &c);         if(a>=b) //a>=b成立的情况
        {           if(a>=c) //进一步讨论a与c的关系
          {                 printf("%d", a);
          }           else           {                 printf("%d", c);
          }         }         else //a>=b不成立的情况
        {           if(b>=c) //进一步讨论b与c的关系
          {                 printf("%d", b);
          }           else           {                 printf("%d", c);
          }         }
        system("pause");         return 0;
    }
　　在上面的代码中所有的if-else语句都加了{ }，这样看起来很臃肿，我们之前说过如果if和else后面只有一条语句的话，是可以省略{ }的。
代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         scanf("%d %d %d", &a, &b, &c);         if(a>=b)         {           if(a>=c)                 printf("%d", a);           else                 printf("%d", c);
        }         else         {           if(b>=c)                 printf("%d", b);           else                 printf("%d", c);
        }
        system("pause");         return 0;
    }
上面的代码其实还可以更简洁，如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {         int a, b, c;         scanf("%d %d %d", &a, &b, &c);         if(a>=b)           if(a>=c)               printf("%d", a);           else               printf("%d", c);         else           if(b>=c)               printf("%d", b);           else               printf("%d", c);
        system("pause");         return 0;
    }
　　你发现没有，在上面的代码中，我们把最外层if-else语句的{ }也去掉了。有的同学可能就有问题要问了。　　我们先来解决问题2。问题2比较简单，else的匹配采用就近原则，离上方哪个if最近，就属于哪个if。所以问题2所指向的那个else是属于 if（b>=c）这个if。这样你就可以把if和else分别一一配对了吧，是不是有点连连看的感觉。
　　问题1说起来比较麻烦，但是原理很简单，请听我慢慢道来。其实上面虚线框中的代码是一个if-else语句，并且是一个很完整的if-else语句，因为它不但有if部分还有else部分。只不过很特别的是，if部分和
else部分都分别有自己的子语句printf部分，所以看起来就显得很多了。
其本质上就是一条if-else语句，一个“复合语句”。不过在外层的
if（a>=b）看来，它就是一条if-else语句，至于这条语句内部长什么样
子，if（a>=b）并不关心，其实就像大盒子里面套小盒子一样， if（a>=b）是搞不清楚if（a>=c）里面是什么样子的。
第11节　if-else语法总结
　　其实说起来很简单，当if（ ）括号内的关系表达式成立的时候，就执行if（ ）后面的{ }中的内容，不成立的时候则执行else后面{ }中的内容。当{ }内的语句只有一条的时候，{ }可以省略。
    if(关系表达式)
    {         语句；         语句；
        ……     }     else     {         语句；         语句；
        ……
    }
当{ }内的语句只有一条的时候，可以省略{ }。
    if(关系表达式)         语句；     else
        语句；[1] 在写本书草稿的时候，我也没有注意到这个问题，感谢@滚雪球snow的提醒。
第4章重量级选手登场第1节　永不停止的哭声
通过第2章的学习，我们知道如果让计算机开口说话要使用printf语
句。例如，让计算机说“wa”，则使用printf（"wa"）;。那如果让计算机说10遍“wa”呢？你可以尝试这样写：
    printf("wa wa wa wa wa wa wa wa wa wa");
或者你也可以这样写：
    printf("wa");     printf("wa");     printf("wa");     printf("wa");     printf("wa");     printf("wa");     printf("wa");     printf("wa");     printf("wa");     printf("wa");
　　如果让计算机说10000遍“wa”呢？该怎么办呢？我想你肯定要疯了吧。在本节我们就要学习如何让计算机做重复的事情。
好，首先我们学习如何让计算机“永无止境”地说“wa”。这很简单，
代码如下：
    while(1>0)
    {         printf("wa");
    }
赶快尝试一下，你是不是发现计算机开始无止境地说“wa”了呢。
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         while(1>0)
        {             printf("wa");
        }         system("pause");         return 0;
    }
一定要尝试啊，尝试后再往下看。
当然，你也可以让计算机无止境地说任何内容。例如：
    while(1>0)
    {           printf("bie wa");
    }
　　回到正题。上面的代码中由两部分组成，一部分是while（ ）中的内容，另一部分是{ }中的内容。它表示的意思是，当while后面（ ）中的关系表达式为真时，即关系表达式成立时才执行{ }中的内容。
　　那么很显然，1>0这个关系是永远成立的，所以计算机会一直执行{ }中的内容，而上面的例子{ }中只是输出wa，所以计算机就会不停地输出wa。这里顺便说一下，如果{ }中只有一条语句，那么{ }便可以省略。
也就是说可以简写成：
    while(1>0)           printf("wa");
这时你可能要问了：while后面（ ）中的1>0是否可以写成2>1或者
3>0等？
　　当然可以，如果想让计算机永不停止地如此执行，你可以写任何一个关系表达式为真的式子。甚至，你可以写while（1）。还记得吗，我们在第3章说过，如果对某个数字判断真假，只要这个数不为0就是真的。例如，下面这段代码也可以永不停止地在屏幕上打印wa：
    while(1)       printf("wa");
下面我来实现一个很炫的效果，“黑客帝国”来啦！    #include <stdio.h>     #include <stdlib.h>     int main()
    {           while(1>0)
          {                 printf("0 1");
          }           system("pause");           return 0;
    }
执行上面的代码后计算机就会不停地在屏幕上打印0和1。
　　当然，你可以改变一下打印的背景与字的颜色，例如，改为黑色的背景，绿色的字。
还记得吗？是使用system（"color 0a"）；这个语句。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {           system("color  0a");           while(1>0)
          {                 printf("0 1");
          }           system("pause");           return 0;
    }
是不是很像黑客帝国？猜一猜，运行下面这段代码，计算机会有什么反应？
    #include <stdio.h>     #include <stdlib.h>     int main()
    {           while(1<0)
          {                 printf("wa");
          }
          system("pause");           return 0;
    }
我想你应该猜到了，计算机一句“wa”都没有说，这是为什么呢？因
为1<0这个关系表达式不成立，所以计算机没有执行后面{ }中的内容。
此时你会发现计算机要么打印无数遍都不停止，要么就一次都不打
印。如果想打印指定的次数该怎么办？例如，我们之前遗留下来的问题：打印10000遍wa，一次也不多、一次也不少该怎么办？不要着急，让我们一起进入本章第2节。
 　一起来找茬
下面这段代码是让计算机“永无止境”地打印hello。其中有两个错
误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )     {           while(1>0);             print("hello");           system("pause");           return 0;
    } 　更进一步，动手试一试
让计算机“永无止境”地在屏幕上显示中文汉字“你好”。
 　这一节，你学到了什么
在C语言中我们用什么语句来实现循环的功能？第2节　我说几遍就几遍　　在本章第1节，我们学习了如何使用while循环来让计算机做重复的事情，本节将揭晓如何让计算机重复指定的次数。
　　我们知道如果while后面（ ）中的关系表达式成立，计算机就会运行{ }中的内容。如果（ ）中的关系表达式永远成立，那么计算机会“永无止境”地去重复执行{ }中的内容。
　　假如让计算机打印100次“wa”，我们需要解决的就是如何让while（）中的关系表达式在前100次是成立的，然后在第101次的时候就不成立了。想一想，根据我们之前学过的知识，你有没有什么方法？
　　很显然while后面的（ ）中的关系表达式，像2>1或者1<=100等都是不适合的，因为像这样用固定的数字组合的关系表达式，一旦被写出，那么这个式子是否成立就已经是板上钉钉啦，非真即假，而且永远不会改变。例如，1<=100这个关系表达式是永远成立的，这样并不符合我们的要求。我们需要创造怎样一个新的关系表达式，才能让这个式子有时成立，有时不成立？该怎么办呢？我猜你已经想到了！那就是——伟大的“变量”。
　　我们可以尝试一下带有变量的关系表达式，例如，a<=100。因为a 是一个变量，a这个小房子里面所装的数是可以变化的。当小房子a中的数是1的时候，a<=100是成立的；当小房子a中的数是101时，a<=100就不成立了，这正好满足了对于表达式a<=100有时成立有时不成立的要求。对于a<=100这个关系表达式是否成立的关键就在于a这个变量所装的数是多少，也就是变量a的值。
　　如果想让a<=100在前100次成立，在第101次不成立的话，只需将变量a的值从1变化到101就可以了。那么如何让变量a的值从1变化到101
呢？我们只需在最开始的时候将变量a的值赋为1，然后while循环每循环一次，就将变量a的值在原来的基础上再加1就可以了。当变量a的值加到101时，a<=100就不成立了，就会结束循环。代码如下：
    int a;     a=1;     while(a<=100)
    {         printf("wa");         a=a+1;
    }
　　再来分析一下上面的代码，a=a+1；这条语句的作用是把小房子a中的值在原本的基础上增加1（在第2章第5节有详细解释，如果还没有搞懂还是回去看看吧）。变量a最开始时值为1，每执行一次while循环，变量a的值就会在原来的基础上增加1，依次变成2、3、4、5、6、7、8、9,
…,100、101。直到变量a的值为101时，a<=100的条件不成立，退出循环。完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=1;         while(a<=100)
        {             printf("wa");             a=a+1;
        }
        system("pause");         return 0;
    }
　　赶快尝试一下吧。如果输出10000个wa该怎么办？或者输出10个 hello呢？赶快去尝试一下吧。
接下来一个问题：如果要打印1～100该怎么办？
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=1;         while(a<=100)
        {           printf("wa");           a=a+1;         }         system("pause");         return 0;
    }
在这段代码中，我们打印了100个wa，那么打印1～100也很简单，只需修改printf语句就可以了。该如何修改printf语句呢？之前printf语句的作用是输出wa，现在需要输出1～100，正巧变量a的值就是从1一点点
增加到100的。我们只需在每次循环时把a的值输出即可，即把 printf（"wa"）；改为printf（"%d ", a）;。完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {       int a;       a=1;       while(a<=100)
      {           printf("%d ", a);           a=a+1;
      }       system("pause");       return 0;
    }
赶快尝试一下吧。
　　如果我们想倒序输出呢，就是让计算机先输出100再输出99接着输出98、97、96、95、…、1，该怎么办？
我们刚刚学过的“让计算机输出1～100”，就是让变量a从1开始，通过while循环把变量a的值每次都输出来，并且每次循环的时候将变量a的值增加1，这样就会打印出1～100。而此时的要求是从100打印到1。很显然我们需要让变量a从100开始，通过while循环把变量a的值每次都输出来，不过每次需要递减1，一直递减到1为止。代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;
        a=100;      //初始值从100开始         while(a>=1) //请注意这里的循环条件变为a>=1
        {           printf("%d ", a);           a=a-1;    //每循环一次将a的值递减1
        }         system("pause");         return 0;
    }
　　问题又来啦，如果希望打印的是1～100中的偶数呢？自己想一想吧。
　　怎么样，有没有思路？其实要输出1～100中的偶数，有很多种方法。比如之前变量a是从1开始的，之后每次在原有的基础上增加1，那么a就会从1到2再到3再到4……一直到101，当变量a的值增加到101时，不满足条件a<=100，就会退出while循环。现在我们可以改变一下思
路，让变量a的值从2开始，每次增加2，这样变量a就会从2增加到4再增加到6……以此类推。代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=2;         while(a<=100)
        {             printf("%d ", a);             a=a+2;
        }         system("pause");         return 0;
    }
好了，又到了尝试的时候了。
　　如何让计算机打印1～100中能被3整除的数，你应该也会了，就是先将变量a的初始值赋为3，然后每次增加3。赶快再尝试一下吧。
上面的写法虽然好，却不是万能的，假如不是输出1～100中能被3 整除的数，而是输出1～100中所有不能被3整除的数呢？例如：1、2、
4、5、7、8、10, …, 97、98、100，又该怎么办呢？不要着急，我们将在本章第3节彻底解决这个问题。
 　一起来找茬
　　下面这段代码是让计算机从100打印到200。其中有3个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=100;         while(a<200) ;
        {             printf("%d ", a);
        }         system("pause");         return 0;
    }
 　更进一步，动手试一试
让计算机从1打印到100再打印到1，例如：1 2 3 …… 98 99 100 99
98 …… 3 2 1。第3节　if对while说：我对你很重要
　　在本章第2节中，我们学习了while循环的基本使用方法，但是遗留了一个问题，即如何让计算机输出1～100中所有不能被3整除的数，例如：1、2、4、5、7, …, 97、98、100。
通过本章第2节的学习，我们可以很容易地让计算机打印1、2、3,
…,100，只需让变量a从1开始每次增加1就可以了。如果想每次遇到3的倍数就不打印的话，我们只需在每次打印之前对变量a的值进行判断就好了，即当变量a的值是3的倍数时就不输出，否则就输出。那怎么判断变量a的值是否是为3的倍数呢？这就需要我们在第3章学习的if语句。我们只需要通过if语句来判断变量a的值除以3的余数是否为0就可以了。如果余数不为0，说明变量a中的值不是3的倍数，就将变量a中的值打印出来；否则就说明变量a中的值是3的倍数，不能打印。
　　那么怎么判断变量a中的值除以3的余数是否为0呢？需要使用“%”这个运算符。在第3章中我们介绍过，“%”读作mod，也可以称之为“取
模”，作用就是获取余数。另外说一下“%”这个运算符的左右两边必须为
整数。而“/”这个符号表示除号，作用是获取商，“/”运算符的左右两边既可以是整数也可以是小数。代码如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {
        int a;         a=1;         while(a<=100)
        {           if(a%3! =0)                 printf("%d ", a);           a=a+1;         }         system("pause");         return 0;
    }
赶快尝试一下吧。　　如果要输出1～100中能被3整除但是不能被5整除的所有数，又该怎么办？
　　这个数是3的倍数但不是5的倍数，也就是需要变量a除以3的余数为 0并且除以5的余数不为0。这里的逻辑关系“并且”在C语言中的表示方法我们在第3章已经学习过，用“&&”表示，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=1;         while(a<=100)
        {             if(a%3==0 && a%5! =0)                 printf("%d ", a);             a=a+1;
        }         system("pause");         return 0;
    }
更复杂的来啦！
你有没有和同学玩过一个游戏——大家围成一圈，从1开始报数，但是每逢遇到7的倍数或者末尾含7的数，例如7、14、17、21、27、28 等，就要拍手并且不能报出，谁出错了，谁就要受到惩罚。
　　现在我想知道1～100中有多少这样的数，请你写这样一个程序，输出1～100中所有7的倍数和末尾含7的数。
　　很简单，我们先参照以往的程序，利用while循环，让变量a从1递增到100，不过我们每次在输出变量a的值之前需要对变量a进行判断。根据题目的要求，如果变量a的值是7的倍数或者末尾含有7就打印出来。判断一个变量是否为7的倍数我们已经很熟悉了，只需要判断变量a除以
7的余数是否为0就可以，即如果a%7==0这个关系表达式成立就输出。那怎么判断变量a的值末尾是否含7呢？我们仔细想一想就会发现，末尾含7的数其实就是这个数的个位为7，也就是这个数除以10的余数为7。发现这个规律就好办了，即在a%10==7这个关系表达式成立时输出就可以啦。
　　好了，现在有两个关系表达式a%7==0和a%10==7，分别表示这个数是否为7的倍数以及末尾是否含7。这两个式子是“或者”的关系，即只要有一个成立，就将这个数输出。这里的逻辑关系“或者”在C语言中的表示方法我们在第3章也学习过，用“||”表示，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {       int a;       a=1;

      while(a<=100)
      {             if(a%7==0 || a%10==7)                 printf("%d ", a);             a=a+1;
      }       system("pause");       return 0;
    }
第4节　求和！求和！！求和！！！
在本章第2节中，我们已经学习了如何让计算机打印1～100，那如
何让计算机求1～100中所有数的和呢？
　　你可能会说，首项加尾项的和乘以项数然后再除以2，就可以了。没错，你可以这样做，但是如果求1～100中所有7的倍数或者末尾含7的数的总和，又该怎么办呢？在求1～100的和之前，我们先来解决如何求1+2+3的值。没错，你可以这样写：
    #include <stdio.h>     #include <stdlib.h>     int main()     {         int a;         a=1+2+3;         printf("%d", a);         system("pause");         return 0;
    }
但是如果计算1～100中所有数的和也这样写的话，是不是太麻烦了呢？我们可以尝试另一种写法，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;
        a=0; //想一想为什么a的初始值要为0呢？
        a=a+1;         a=a+2;         a=a+3;         printf("%d", a);         system("pause");         return 0;
    }
　　你可能会说这样写岂不是更麻烦……但是我们发现在上面的这段代码中，a=a+1;a=a+2; 	a=a+3；这三句话，基本思想是相同的，第一次加
1，第二次加2，第三次加3。我们可以把这三个语句用a=a+i；来表示。
然后让变量i从1到3循环就可以了。代码如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {         int a, i;         a=0;         i=1;         while(i<=3)
        {             a=a+i;             i=i+1;
        }         printf("%d", a);         system("pause");         return 0;
    }
　　如果需要计算1～100的和，我们只需将上面代码中i<=3修改为 i<=100就可以了，赶快去尝试一下吧。
　　如果求1～100中所有7的倍数或者末尾含7的数的总和，又该怎么办呢？先来回顾一下刚刚才学会的求1～100中所有数的和的方法，代码如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {
        int a, i;         a=0;         i=1;         while(i<=100)
        {             a=a+i;             i=i+1;
        }         printf("%d", a);         system("pause");         return 0;
    }
　　在上面的代码中，变量i会从1到100每次递增1，然后每次将变量i的值累加到变量a上。这个变量i就像是一个搬运苹果的工人，刚开始只拿
1个苹果，之后拿2个苹果，再之后又拿3个苹果……最后一次一下拿了
100个苹果。
　　变量a就像是一个很大很大的水果篮子，用来装这些苹果。每次拿来的苹果统统被装进篮子里面，第一次放1个苹果进去，第二次放2个苹果，第三次放3个苹果进去……最后一次放100个苹果进去。最后篮子a 中苹果的总数就是1～100的和。所以我们最后输出了变量a的值，这就是答案。　　那么求1～100中所有7的倍数或者末尾含7的数的总和，又该怎么办呢？
　　此时我们不再是每次都把苹果放进篮子里面。只有当苹果的个数是 7的倍数或者末尾含7的时候，这堆苹果才能被放进篮子里面，所以就不能每次都执行a=a+i。此时我们需要借助if语句来完成我们的目标。其中变量i就是每次拿的苹果的数量，代码如下：
    if(i%7==0 || i%10==7)
    {         a=a+i;
    }
    i=i+1;
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, i;         a=0;         i=1;         while(i<=100)
        {             if(i%7==0 || i%10==7)
            {                 a=a+i;
            }             i=i+1;
        }         printf("%d", a);         system("pause");         return 0;
    }
 　一起来找茬
　　下面这段代码是求1×2×3×4×5×6×7×8×9×10的值。其中有3个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {           int a, i;           a=0;           i=1;           while(i<10)
          {               a=a＊i;
          }           printf("%d", a);           system("pause");           return 0;
    }
 　更进一步，动手试一试
1．求1～100所有偶数的和。
2．输入一个整数n（1<=n<=9），求n的阶乘 [1] 。
第5节　逻辑挑战4:60秒倒计时开始　　你是否曾读过60秒倒计时，即从60开始倒数，59、58、57、56…… 然后一直到0。如果我们现在也能在计算机上显示出这种效果是不是很帅，不要走开，精彩马上开始。
　　在尝试做60秒倒计时之前，我们先学习如何实现3秒倒计时，就是让计算机输出3、2、1、0。这个很简单，使用4次printf语句就可以了。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         printf("3");         printf("2");         printf("1");         printf("0");
        system("pause");         return 0;
    }
　　但是计算机一下子就显示了3210，丝毫没有倒计时的感觉，我们希望计算机先打印3,1秒后打印2，再过1秒打印1，再过1秒打印0。如果要实现每过1秒打印一个数，我们就需要用到“等待”这个语句，这个语句
就是Sleep（ ），注意第一个字母S是大写，例如，Sleep（1000）就表示等待1秒。其实这里的Sleep就是“等待”的意思，圆括号内的数字就是表示需要“等待”的时间，单位是毫秒。还有很重要的一点，如果需要用
Sleep（ ），就必须在代码的开头加上#include <windows.h>才行 [2] 。
我们现在让计算机每打印一个数就等待1秒，也就是每执行printf（
）一次，就Sleep（1000）。修改之后的代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         printf("3");         Sleep(1000);         printf("2");         Sleep(1000);         printf("1");
        Sleep(1000);         printf("0");
        system("pause");         return 0;
    }
　　尝试过后，你是不是发现计算机开始每过1秒打印一个数了呢，但是计算机每次打印新的数之前，并没有把之前打印出来的数清除，离我们所希望的倒计时还差那么一点点。这里介绍一个“清屏”语句，就是把现在屏幕上所有的内容清除干净，这个语句是system（"cls"）;。好了，我们现在就把system（"cls"）；加在每一个printf（ ）语句的前面。这样就可以在每次打印新的内容之前先把屏幕清除干净。代码如下，赶快尝试一下吧。
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         system("cls");         printf("3");         Sleep(1000);
        system("cls");
        printf("2");         Sleep(1000);
        system("cls");         printf("1");         Sleep(1000);
        system("cls");         printf("0");         Sleep(1000);
        system("pause");         return 0;
    }
怎么样，是不是有点意思呢。通过这种方法我们就可以实现60～0
的倒计时，不过像上面这样写的话，10以内的倒计时还可以接受，60～ 0的倒计时写起来就太麻烦了。我们仔细分析一下上面这段代码，就会发现它由4个小部分组成（在代码中已经用空行隔开），这4个小部分，除了printf（ ）语句中的数字不一样之外，其余都是一样的，而且数字也是有规律的，即从3到0。我们很自然就想到利用之前学习的while循环来代替这4个printf（ ）语句。
我们之前学习过如何从100到1依次输出，即让变量a从100开始，通
过while循环每次把变量a的值输出来，同时每次循环时还需要将变量a的值减少1，这样就会打印出100～1。显然，让计算机从3打印到0也是一样的，只不过是让变量a从3开始，然后也是通过while循环每次把变量a 的值输出，同时每次递减1，一直递减到0为止。代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         int a;         a=3;         while(a>=0)
        {             printf("%d", a);             a=a-1;
        }         system("pause");         return 0;
    }
　　然后在这个代码的基础上，在printf（ ）语句前加上清屏语句 system（"cls"），在printf（ ）语句之后加上暂停语句Sleep（1000）就可以了。完整的代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         int a;         a=3;         while(a>=0)
        {             system("cls");             printf("%d", a);             Sleep(1000);             a=a-1;
        }         system("pause");         return 0;
    }
　　如果要从60秒开始倒计时，只需将变量a的初始值改为60就可以。另外，你可以让这个倒计时看起来更好看一些，我们可以修改一下输出屏幕的背景以及字的颜色，例如，将下面这段代码改成了黑底绿字，看起来是不是更酷呢。
    #include <stdio.h>
    #include <stdlib.h>
    #include <windows.h>
    int main()
    {         int a;         a=60;         system("color 0a");         while(a>=0)
        {             system("cls");             printf("%d", a);             Sleep(1000);             a=a-1;
        }         system("pause");         return 0;
    }
　　好了，现在你可以做100秒甚至1000秒的倒计时了，尝试将Sleep括号内的数值改小一点，例如，改为Sleep（50），你会发现不同的效果，赶快尝试一下吧。
 　更进一步，动手试一试
请尝试编写一个两分钟的倒计时。形如：2:00 1:59 1:58 …… 1:00
0:59 0:58 …… 0:02 0:01 0:00
 　这一节，你学到了什么
清屏的命令是什么？第6节　这个有点晕——循环嵌套来了
首先，我们尝试输出这样一个图形：
    ＊＊＊＊＊     ＊＊＊＊＊     ＊＊＊＊＊
　　上面这个图形由3行星号组成，每行5个，也就是说一共有3×5=15个星号。如果我们想打印这个图形，有很多种方法。最简单的方法如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         printf("＊＊＊＊＊\n");         printf("＊＊＊＊＊\n");         printf("＊＊＊＊＊\n");         system("pause");         return 0;
    }
　　上面的写法当然可以，但是如果要输出100行并且每行100个星号的话就太麻烦了。
利用我们学过的while循环，可以改进一下：
    a=1;     while(a<=15)
    {         printf("＊");         if(a%5==0)             printf("\n");         a=a+1;
    }
　　上面这段代码的思想是：一共要输出15个星号，所以只需要循环15 次（每循环一次就输出一个星号）。但是每行只能有5个星号，也就意味着，每打印5个星号就需要换一行，可以通过if语句来控制打印换行。
如何控制呢？我们知道每循环一次就会打印一个星号，变量a的值也会递增1，也就是说目前变量a的值其实就是已经打印的星号的个数。如果变量a的值恰好是5的倍数，就说明此时需要换行了，if（a%5==0） printf（"\n"）；正是起到了这个作用。完整的代码如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {         int a;         a=1;         while(a<=15)
        {             printf("＊");             if(a%5==0)                 printf("\n");             a=a+1;
        }         system("pause");         return 0;
    }
当然还有别的方法，就是使用循环嵌套。我们再来仔细观察一下这
个图。
    ＊＊＊＊＊     ＊＊＊＊＊     ＊＊＊＊＊
　　该图一共有3行，可以用3次while循环，每行只需要打印一个“\n”，就能解决打印行的问题，代码如下：    a=1;     while(a<=3)
    {           printf("\n");           a=a+1;
    }
　　然后，每行需要打印5个星号，我们在刚才写好的while循环中再嵌套一个while循环来打印5个星号，代码如下：
    a=1;     while(a<=3)  //while a循环用来控制换行
    {         b=1;         while(b<=5)  //while b循环用来控制输出每行5个星号
        {             printf("＊");             b=b+1;
        }         printf("\n");         a=a+1;
    }
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b;         a=1;         while(a<=3)
        {             b=1;             while(b<=5)
            {                 printf("＊");                 b=b+1;
            }             printf("\n");             a=a+1;
        }         system("pause");         return 0;
    }
　　在上面的代码中，有两个while循环，一个是外循环，另一个是内循环，内循环嵌套在外循环中。其实内循环是外循环的一部分，外循环每循环一次，内循环就会从头到尾循环一遍。其中用来控制外循环的循环次数的变量是a，我们称这个外循环为while 	a循环；用来控制内循环的循环次数的变量是b，我们称这个内循环为while b循环。
想一想，如果想要完成这样的图形该怎么办？
    ＊
    ＊＊
    ＊＊＊
    ＊＊＊＊
    ＊＊＊＊＊
　　经过分析，我们发现，这个图形有5行，仍然先用while 	a循环来解决5行的问题，代码如下：
    a=1;     while(a<=5)
    {           printf("\n");           a=a+1;
    }
　　但是如何使每行星号的个数不同呢？回想一下之前打印过3行且每行有5个星号的代码，其中while b循环的作用是在每一行上面打印5个星号，所以变量b是从1递增到5同时每次都打印5个星号。可是现在的要求变了，每行不都是5个星号，而是第一行1个星号，第二行2个星号…… 我们这里只需将while b循环的条件改一下，不再是b<=5，改为b<=a就可以了（b的初始值不变，仍然是1）。while 	a循环中的变量a是用来控制每一行的，变量a等于1时就是第一行，打印1个星号；变量a等于2时就是第二行，打印2个星号，所以变量a的值恰好就是这行所需要的星号数，代码如下：
    a=1;     while(a<=5)
    {         b=1;         while(b<=a)
        {             printf("＊");             b=b+1;
        }         printf("\n");         a=a+1;
    }
完整的代码如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {         int a, b;         a=1;         while(a<=5)
        {             b=1;             while(b<=a)
            {                 printf("＊");                 b=b+1;
            }             printf("\n");             a=a+1;
        }         system("pause");         return 0;
    }
 　更进一步，动手试一试
1．请尝试用while循环打印下面的图形。
    输入一个整数n(1<=n<=30)，当输入的n值为3时，打印结果是：
    1
2 2
3 3 3
    当输入的n值为6时，打印结果是：
    1
2 2
3 3 3
4 4 4 4
5 5 5 5 5
6 6 6 6 6 6
2．请尝试用while循环打印下面的图形。
    输入一个整数n(1<=n<=30)，当输入的n值为3时，打印结果是：
    1
    2 3
    4 5 6
    当输入的n值为5时，打印结果是：
    1
    2 3
    4 5 6
    7 8 9 10
    11 12 13 14 15
第7节　逻辑挑战5：奔跑的字母　　之前我们已经学习了如何通过while循环，并结合暂停命令Sleep和清屏幕命令system（"cls"）来实现“倒计时”，本节我们将通过这些命令编写一个“奔跑的字母”的程序。
　　首先我们想一下，如果希望一个字母（假设这个字母是H）从屏幕的左边往右边跑，即第一秒时字母H在屏幕的第一行的最左边（也就是第一行第一列），第二秒时字母H在屏幕第一行的第二列，第三秒时字母H在屏幕第一行的第三列，以此类推，该怎么实现呢？
　　我们知道，如果直接使用printf（"H"）;，字母H就会出现在屏幕的第一行第一列，即最靠近左上角的位置。那如何让字母H在屏幕的第一行第二列呢？我们可以用“空格”来占位。也就是说，在输出时先输出一个空格，再输出字母H，即printf（" H"）;（在H左边加一个空格来填充第一列，这样H就会出现在第二列）。同样，如果希望字母H在第一行
第三列的话，只需在输出时，在H左边多加两个空格就可以了，即 printf（" H"）;，好了，我们来尝试一下。
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         system("cls");         printf("H");         Sleep(1000);         system("cls");         printf(" H");         Sleep(1000);
        system("cls");         printf("  H");         system("pause");         return 0;
    }
　　怎么样？字母H是不是从左边向右边移动了3步。用这种方法，我们也可以让字母移动50步，但是如果像上面这样写，是不是太麻烦了，我们需要复制粘贴50次，然后每一次都要修改printf语句中字母H前面空格的个数，真是太麻烦了。
我们仔细分析一下上面这段代码，有3个部分基本上相同，只有
printf语句中字母H前面的“空格”的个数不同，在第1部分字母H前面有0 个空格，在第2部分字母H前面有1个空格，在第3部分字母H前面有2个空格。我们便想到了用while循环解决这个问题。
　　首先，仔细观察之前的代码你就会发现，其中有3段代码是差不多的。我们可以用while循环3次来解决重复的问题，代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         int a;         a=0;         while(a<=2)
        {             system("cls");             printf("H");             Sleep(1000);             a=a+1;
        }         return 0;
    }
　　运行一下你会发现，字母H并没有向右移动。这是为什么呢？因为在上面的while循环中，虽然循环了3遍，但是每次循环输出的都是 printf（"H"）;，字母H的左边并没有空格，所以字母H并没有向右边
跑。把printf（"H"）；改为printf（" H"）；也不行，那样每次输出的都是字母H在第一行第二列的位置，字母H会一直停留在第一行第二列，不会往右边跑。需要解决的是，在循环第1次时H在第一列，即H前面有 0个空格；循环第2次时H在第二列，即H前面有1个空格；循环第3次时H 在第三列，即H前面有2个空格。
　　我们发现每次循环空格的变换规律是0、1、2，这恰好和变量a的变化规律是一样的。第1次循环时变量a的值为0，第2次循环时变量a的值为1，第3次循环时变量a的值为2。也就是说每次循环时，在打印字母“H”前，打印a个空格就可以了。可是如何使每次循环输出a个空格呢？这里我们需要用到while循环的嵌套。代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         int a, b;         a=0;         while(a<=2)
        {             system("cls");             b=1;             while(b<=a)
            {
                printf(" ");                 b=b+1;
            }
            printf("H");             Sleep(1000);             a=a+1;
        }         system("pause");         return 0;
    }
　　在上面这段代码中，我们利用while a循环来控制字母H一共需要走多少步，利用while b循环来控制字母H每走一步需要在字母H前面打印多少个空格。
下面我们来仔细分析一下上面这段代码。
计算机自顶向下一步步执行：
    首先a的初始值为0
    a<=2成立，进入外循环           清屏
          b的初始值被赋为1
          b<=a不成立（此时a为0, b为1），不进入内循环，不会打印空格           打印字母H          暂停1秒           a=a+1（a从0变为1）
    外循环末尾，跳转到外循环的开始部分，重新判断a<=2是否成立     a<=2 成立（此时a为1），继续进入外循环
          清屏           b的初始值被赋为1           b<=a成立（此时a为1, b为1），进入内循环             打印空格             b=b+1（b从1变为2）
          内循环末尾，跳转到内循环的开始部分，重新判断b<=a是否成立           发现此时b<=a不成立，（此时a为1, b为2），退出内循环           打印字母H
          暂停1秒           a=a+1（a从1变为2）
    外循环末尾，跳转到外循环的开始部分，重新判断a<=2是否成立     a<=2 成立（此时a为2），继续进入外循环：
          清屏幕           b的初始值被赋为1

          b<=a成立（此时a为2, b为1），进入内循环             打印空格             b=b+1（b从1变为2）
          内循环末尾，跳转到内循环的开始部分，重新判断b<=a是否成立           此时b<=a成立，（此时a为2, b为2），再次进入内循环             打印空格             b=b+1（b从2变为3）
          内循环末尾，跳转到内循环的开始部分，重新判断b<=a是否成立           发现此时b<=a不成立，（此时a为2, b为3），退出内循环           打印字母H
          暂停1秒           a=a+1（a从2变为3）
    外循环末尾，跳转到外循环的开始部分，重新判断a<=2是否成立     此时a<=2 不成立（此时a为3），退出外循环
第8节　究竟循环了多少次
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b;         a=1;         while(a<=2)
        {             b=1;             while(b<=3)
            {                 printf("ok ");                 b=b+1;
            }             a=a+1;
        }         system("pause");         return 0;
    }
猜猜看，计算机执行上面这段代码后，会打印多少次“OK”？ 6次！为什么计算机会打印6次“OK”？
　　我们仔细分析一下上面的代码，会发现有两个while循环，即while a 循环和while b循环，并且while b循环嵌套在while a循环里面。
　　这里while a循环每循环一次，while b循环就会被完整地从头到尾执行一遍（循环3次，打印3个“OK”）。这里的while a循环会循环2次，所以while b循环就会被完整地执行两遍（每遍打印3个“OK”）。所以，一共会打印出6个“OK”，我们可以这样计算循环的次数：2×3=6。
我们再来看看下面这段代码循环了多少次：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b;         a=1;         while(a<=4)
        {             b=1;             while(b<=2)
            {                 printf("ok ");                 b=b+1;
            }             a=a+1;
        }         system("pause");         return 0;
    }
实验过后你会发现计算机一共打印出了8个“OK”，我们可以这样计
算循环次数4×2=8。
再来看看更复杂的，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a, b, c;         a=1;         while(a<=2)
        {             b=1;             while(b<=4)
            {                 c=1;                 while(c<=3)
                {                     printf("ok ");
                    c=c+1;
                }                 b=b+1;
            }             a=a+1;
        }         system("pause");         return 0;
    }
　　上面这段代码，有3层循环嵌套，while a循环中嵌套了while b循环，while b循环中又嵌套了while c循环。while a循环会循环2次，while b循环会循环4次，while c循环会循环3次。也就是说，while a循环每循环1次，while b循环就会循环4次，while b循环每循环1次，while c循环就会循环3次，所以一共循环了2×4×3=24次，打印了24个“OK”。
 　更进一步，动手试一试
请问下面这段代码会打印多少个“OK”？
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int i, j;         i=1;

        while(i<=10)
        {             j=1;             while(j<=i)
            {                 printf("OK ");                 j=j+1;
            }             i=i+1;
        }         system("pause");         return 0;
    }
第9节　逻辑挑战6：奔跑的小人　　在本章第7节中，我们学会了如何让字母奔跑起来，本节我们将在“奔跑的字母”基础上，让一个小人奔跑起来，而且还可以控制这个小人奔跑的速度。
首先我们来设计这个小人：
    O
   <H>
   I I
将这个小人身体的三部分分为3行来分别表示：
第1行用一个大写字母O表示小人的脑袋。
　　第2行用左尖括号<表示小人的左手，用大写字母H表示小人的身体，用右尖括号>表示小人的右手。第3行用两个大写字母I表示小人的两条腿，为了对称，两个大写字
母I之间用一个空格隔开。代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()     {         printf(" O\n");         printf("<H>\n");         printf("I  I\n");         system("pause");         return 0;
    }
现在我们让小人动起来。首先回顾一下让字母奔跑起来的代码：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         int a, b;
        a=0;         while(a<=2)
        {             system("cls");
            b=1;             while(b<=a)
            {                 printf(" ");                 b=b+1;
            }             printf("H");             Sleep(1000);             a=a+1;
        }         system("pause");         return 0;
    }
我们把上面代码中的
    printf("H");
改为：
    printf(" O\n");     printf("<H>\n");     printf("I  I\n");
完整的代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         int a, b;         a=0;         while(a<=2)
        {         system("cls");
        b=1;         while(b<=a)
        {             printf(" ");             b=b+1;
        }
        printf(" O\n");         printf("<H>\n");         printf("I I\n");
        Sleep(1000);         a=a+1;         }         return 0;
    }
　　运行后你会发现，只有小人的脑袋往右边移动，身体和腿呆在原地，这是为什么？
　　分析后我们发现，让小人往右移动主要通过在小人的左边不停地打印空格来实现。但是我们只在第1行的左边打印了空格，在第2行和第3 行都没有打印空格的语句。因此我们要将打印空格的while循环再复制
一遍分别放在printf（"<H>\n"）；和printf（"I I\n"）；前面，完整的代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>     int main()
    {         int a, b;

        a=0;         while(a<=2)
        {             system("cls");
            b=1;             while(b<=a)
            {                 printf(" ");                 b=b+1;
            }             printf(" O\n");
            b=1;             while(b<=a)
            {                 printf(" ");                 b=b+1;
            }             printf("<H>\n");
            b=1;             while(b<=a)
            {                 printf(" ");                 b=b+1;
            }
            printf("I I\n");
            Sleep(1000);             a=a+1;
        }         system("pause");         return 0;
    }
怎么样，小人是不是奔跑起来啦！
　　如果希望小人跑得更远，我们只需把while（a<=2）改为 while（a<=80）。如果让小人跑得更快一点，我们之前已经学习过，只需把Sleep（1000）；改为较小的值就可以了，越小越快，例如，改为
Sleep（100）;。赶快试一试吧。
 　更进一步，动手试一试
你可以设计一个“小人”并让它从右边向左边奔跑吗？
第10节　for隆重登场
　　通过之前的学习，我们知道，如果要让计算机做重复的事情，可以使用while循环。本节介绍另一种循环——for循环。有时它要比while循环使用起来更加方便。
　　首先我们来回顾一下，如果让计算机从1循环到10，并且把1～10都打印出来，用while循环的写法是这样的：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         a=1;         while(a<=10)
        {             printf("%d ", a);             a=a+1;
        }         system("pause");         return 0;
    }
上面代码中的while循环，分为3部分，控制while循环从1到10执行
10次。
第1部分：设置a的初始值为1，即a=1。
第2部分：设置循环条件，即a<=10。
第3部分：a每次增加1，即a=a+1。
　　上面3部分的共同作用使得让while循环从1到10循环了10次。如果忘记写上面3部分中的任一部分（根据我的经验，很多同学都会忘记写
a=1；或a=a+1;）, while循环就不能正常运行了。这3部分在3个不同的地方，确实容易让人漏写。不过不要紧，粗心的我们可以使用for循环来解决这个问题。我们来看一看，用for循环如何解决让计算机从1循环到
10，并且把1到10都打印出来的问题。代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;         for(a=1; a<=10; a=a+1)
        {             printf("%d ", a);
        }         system("pause");         return 0;
    }
　　你发现了没有，for循环后面的括号，把while循环的3部分统统写了进去，并且用分号隔开，请注意只有两个分号，最后的a=a+1后面没有分号，它表达的意思仍然是从1循环到10。这样写起来是不是方便很
多。现在只需看for后面括号内的3个式子就可以知道，这个循环是从几开始，到几结束，每次增加几。
另外说一下，a=a+1可以简写为a++。其他简写方法将在第5章进一
步说明。因此上面的for循环：
    for(a=1; a<=10; a=a+1)
可以简写为：
    for(a=1; a<=10; a++)
同样，也可以利用for循环来实现1～100中所有数的求和，代码如
下：
    #include <stdio.h>
    #include <stdlib.h>
    int main()
    {         int a, sum;         sum=0;         for(a=1; a<=100; a++)
        {             sum=sum+a;
        }         printf("%d", sum);         system("pause");         return 0;
    }
打印1～100中所有偶数的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;
        for(a=2; a<=100; a=a+2)
        {             printf("%d ", a);
        }
        system("pause");         return 0;
    }
用for循环输出1～100中所有7的倍数或者末尾含7的数，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a;
        for(a=1; a<=100; a++)
        {             if(a%7==0 || a%10==7)                 printf("%d ", a);
        }         system("pause");         return 0;
    }
　　怎么样，for循环是不是比while循环要简洁很多。很多同学可能要问，既然for循环要比while循环好，为什么还要学习while循环呢？其实，在控制已知循环次数时，例如，需要循环10次或者1000次，for循环确实要比while循环方便。但是，并不是在任何情况下for循环都要优于 while循环，还要看我们对循环的需求。随着编程学习的慢慢深入，你会了解什么时候该用for循环，什么时候该用while循环。其实还有一种
do-while循环，这里不再做介绍，有兴趣的同学可以“百度”或者“谷歌”一下，去获得更多的知识。这里插一句，随着搜索引擎的广泛使
用，现在获取新知识和解决问题变得越来越便捷了。我们遇到问题时，要学会多多使用搜索引擎来解决问题，养成良好的学习习惯和学习方法才是学习的本质！
 　一起来找茬
　　下面这段代码是求1×2×3×4×5×6×7×8×9×10的值。其中有4个错误，快来改正吧！
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int i, sum;         sum=0;         for(i=1, i<=10, i++);
        {           sum=sum＊i;
        }         printf("%d", sum);         system("pause");
        return 0;
    }
 　更进一步，动手试一试
1．请尝试用for循环打印下面的图形。
            ＊
          ＊＊＊
        ＊＊＊＊＊
      ＊＊＊＊＊＊＊
    ＊＊＊＊＊＊＊＊＊
      ＊＊＊＊＊＊＊
        ＊＊＊＊＊
          ＊＊＊
            ＊
2．请尝试用for循环来打印一个九九乘法表。[1] 正整数阶乘指从1乘以2乘以3乘以4一直乘到所要求的数。例如，所要求的数
是4，则阶乘式是1×2×3×4，得到的积是24,24就是4的阶乘。如果所要求的数是6，则阶乘式是1×2×3×…×6，得到的积是720,720就是6的阶乘。如果所要求的数是n ，则阶乘式为1×2×3×…×n，设得到的积是x , x 就是n 的阶乘。
[2] 此方法只在Windows系统下有效。第5章好戏在后面第1节　程序的3种结构
　　回顾第2章～第4章的学习内容，在第2章里我们所写的程序计算机只能一行一行地按从上向下的顺序执行；在第3章我们学会了“判断”，可以让计算机在条件成立时执行某条语句，在条件不成立时执行另一条语句；到了第4章我们学习了“循环”，可以让计算机自动重复、永无止境地运行。这便是程序设计中最基本的3种设计思想：顺序执行、选择执行和循环执行。
第2节　啰嗦一下
　　我们在前面的章节中学习了变量和运算符的使用方法、数据的读入和输出、if-else选择语句、while和for循环语句。在本章开始之前，还有一些细节需要啰嗦一下，请注意这些细节，很重要。
第一：
　　a++是a=a+1的简写，起到的作用是将变量a的值在原有的基础之上增加1。同样，a--是a=a-1的简写，起到的作用就是将变量a的值在原有的基础之上减少1。请注意，这里不要陷入遐想，没有a**和a//之类的，当然也没有a+++或者a----之类的，仅有a++和a--。当然啦，对于变量b而言，就是b++和b--。你可能要问，如果想实现a=a+2，该怎么办？那你
就得写两遍a++，即a++; a++;，当然还有另外一种写法，我们马上介绍。
　　补充一句，很多学生都会打破砂锅问到底，为什么只有a++和a--，却没有a**和a//呢？你想啊，a**和a//有意义吗？a*1和a/1结果不都是a 嘛，a的值都没有发生变化。
第二：
　　a+=2是a=a+2的简写，起到的作用就是将变量a的值在原有的基础之上增加2。同样a+=100，是将变量a的值在原有的基础之上增加100。此外a-=2是a=a-2的简写，a*=2是a=a*2的简写，a/=2是a=a/2的简写，a%=2 是a=a%2的简写。
第三：
　　其实本来不想讲第三点的，因为它对你来说暂时没有什么用。但是，有很多同学还是看到++a这种写法，那我就简略地提一下。++a和 a++的功能差不多，都是将变量a的值在原有的基础上增加1。当然它们还是有区别的，只是这个区别你现在还没有必要知道，目前你还用不到。同样，a--和--a也是差不多的。第3节　逻辑挑战7：判读质数很简单
在本节我们将要学习如何让计算机判断一个正整数是否为质数。
　　质数，又称为素数，指大于1的自然数，除了1和该整数自身外，无法被其他自然数整除（也可定义为只有1和它本身两个约数的数）。
　　比1大但不是质数的数称为合数。1和0既非质数也非合数。20以内的质数有2、3、5、7、11、13、17和19。
　　如果要让计算机判断一个正整数是否为质数，最直接的方法就是从质数的定义出发。如果这个数只能被1和它本身整除， 即只有1和它本身两个约数，除此之外再没有其他约数 ，那么这个 数(?)就(?)是(?)质(?)数(?)。(?)例(?)如(?)，(?)判(?)断(?)10(?)0(?)1是(?)否(?)为(?)质(?)数(?)，(?)需(?)要(?)分(?)别(?)用(?)1001除以2，除以3，除以4，除以5……直到除以1000，如果都不能被整除，即都不是1001的约数，那就说明1001为质数，反之为合数。在2～1000中，1001可以被7、11、
13、77、91、143整除，这6个数都是1001的约数，所以1001为合数。
　　总结一下，如果要判断一个正整数a 是否为质数，需要用a 分别去除以2、3、4、5……a -2、a -1。如果从2到a -1中的所有整数都不能被a 整除，即找不到除了1和a本身以外的任何约数，那么就说明a 为质数，否则为合数。即如果a 的值为5，我们只用判断a 能否能被2、3、4整除就可以了。
　　好了，剩下的就简单了。在C语言中，可以用int 	a；来存储这个待判断的整数，用“%”来解决整除的问题。假如要判断5是否为质数，只
要5除以2的余数不为0, 5除以3的余数不为0，且5除以4的余数也不为0的话，就说明5为质数，否则5就是合数。代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a;         a=5;
        if(a%2! =0 && a%3! =0 && a%4! =0)             printf("质数");         else             printf("合数");
        system("pause");         return 0;
    }
当然我们也可以利用反向思维，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {
        int a;         a=5;
        if(a%2==0 || a%3==0 || a%4==0)             printf("合数");         else             printf("质数");
        system("pause");         return 0;
    }
　　上面的代码中，如果a 能被2、3、4中的任意一个数整除，就说明a 是合数，否则为质数。
　　但是用上面的方法判断10以内的数还好办，如果要判断1001是否为质数就太麻烦了。不信你去试一试。
我们来改善一下方法。
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, count;         count=0;
        a=5;
        if(a%2==0)             count++;         if(a%3==0)             count++;         if(a%4==0)             count++;
        if(count==0)             printf("质数");         else             printf("合数");         system("pause");         return 0;
    }
在上面的代码中，我们增加了一个变量count用来记录a有多少个约
数，变量count的初始值为0。当a%2==0成立时就说明2是a的约数，此时将count的值加1。同理a%3==0和a%4==0这两个式子只要有任意一个成立，也需将count的值加1。最后我们只通过变量count的值就可以知道a 有几个约数，并判断a是否为质数。
如果count的值到最后仍然是0则表示a没有约数，说明之前的3个if
判断都不成立，即a不能被2、3、4中的任意一个数整除，a是质数。反之，如果最终count的值不为0，就说明之前的3个if判断中肯定有某个（或者某几个）是成立的，2、3、4中有a的约数，a是合数。
　　你可能会觉得这样写貌似更加麻烦，别急，我们进一步完善一下，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, count, i;
        count=0;         a=5;
        for(i=2; i<=4; i++)
        {             if(a%i==0)                 count++;
        }
        if(count==0)             printf("质数");         else             printf("合数");         system("pause");         return 0;
    }
上面的代码中我们用
    for(i=2; i<=4; i++)
    {         if(a%i==0)             count++;
    }
代替了
    if(a%2==0)         count++;     if(a%3==0)         count++;     if(a%4==0)         count++;
因为我们发现，这3个if语句只有变量值不一样，其余都是一样的，
于是便想到了用for循环来解决。
进一步扩展，当a等于5的时候，只需要判断2、3、4（即从2到a1），当a的值不确定时，我们需要将for（i=2; i<=4; i++）改为for（i=2; i<=a-1; i++），然后用scanf（"%d", &a）来读入数据，就可以让计算机自己来判断任意一个数是不是质数了，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, count, i;         count=0;         scanf("%d", &a);         for(i=2; i<=a-1; i++)
        {             if(a%i==0)                 count++;
        }         if(count==0)             printf("质数");         else             printf("合数");         system("pause");         return 0;
    }
其实，只需将上面的代码加一行打印语句就可以输出一个数的所有约数，代码如下（请注意有下画线的语句）：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, count, i;         count=0;         scanf("%d", &a);         for(i=2; i<=a-1; i++)
        {             if(a%i==0)
            {                 count++;
                printf("%d ", i);
 //打印出约数
            }         }         if(count==0)             printf("质数");

        else             printf("合数");         system("pause");         return 0;
    }
第4节　更快一点：break
　　在本章第3节中，我们已经学习了如何判断一个正整数是否为质数，其实该节的代码仍然可以优化，请看下面的代码（请注意有下画线的语句）：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, count, i;         count=0;         scanf("%d", &a);         for(i=2; i<=a-1; i++)
        {             if(a%i==0)
            {                 count++;                 break;
            }         }         if(count==0)
            printf("质数");         else             printf("合数");         system("pause");         return 0;
    }
　　上面代码中break；语句的作用是提前结束当前循环，也就是说当计算机运行到break；时就会跳出for循环。请看下面的代码：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int i;         for(i=1; i<=10; i++)
        {             if(i==6)             {                 break;
            }             printf("%d ", i);
        }         system("pause");         return 0;
    }
上面的代码本来是让i从1循环到10，但是你会发现计算机只输出了
1 2 3 4 5。因为当i==6时，计算机执行了break；语句，跳出了循环。我们来总结一下：
break是用来提前终止for、while或者do-while循环的。
第5节　continue
　　之前我们已经学习过如何打印偶数，在这里我们介绍另外一种方法，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int i;         for(i=1; i<=100; i++)
        {             if(i%2==1)
            {                 continue;
            }             printf("%d ", i);
        }         system("pause");         return 0;
    }
在上面的代码中，    if(i%2==1)
    {         continue;
    }
　　表示的意思是：当i%2==1时，也就是i为奇数时，跳过之后的打印语句，提前进入下一次循环。
我们再来总结一下：
break使循环提前跳出。
continue强迫程序提前进入下一轮循环。第6节　逻辑挑战8：验证哥德巴赫猜想　　上面这封书信是普鲁士数学家哥德巴赫在1742年6月7日写给瑞士数学家欧拉的，哥德巴赫在书信中提出了“任一大于2的整数都可以写成3 个质数之和”的猜想。当时，哥德巴赫遵照的是“1也是素数”的约定。现今，数学界已经不使用这个约定了。哥德巴赫原猜想在现代被陈述为：任一大于5的整数都可写成3个质数之和。1742年6月30日欧拉在回信中注明，此猜想可以有另一个等价的版本，即“任一大于2的偶数都可写成两个质数之和”。我们现在所说的哥德巴赫猜想通常是指这个版本。两个多世纪过去了，这一猜想既无法证明，也没有被推翻。我们现在将通过程序在4～
100内验证这个猜想。
让我们来验证4～100内所有偶数都可写成两个质数之和。首先4～
100的偶数循环可以这样写：
    for(k=4; k<=100; k=k+2)
  {
  }
　　然后我们需要将每一个数k 拆分为a +b 的形式，a 的范围是2～k /2（自己想一想为什么到k /2就可以了）。如果a 和b 都是质数的话我们就将其打印出来，说明对于数k 我们验证成功了，然后继续验证下一个数。打印的效果如下：
    4=2+2
    6=3+3
    8=3+5
    10=3+7
    12=5+7
    14=3+11
    ……
　　补充一点：上面的10还可以拆分为5+5,14还可以拆分为7+7。代码框架如下：
    for(k=4; k<=100; k=k+2)
   {           for(a=2; a<=k/2; a++)
          {
                验证a是否为质数；                 如果a为质数
                {                     b=k-a;                     验证b是否为质数；                     如果b也是质数
                    { 打印这个解并跳出循环}
                }
          }
   }
通过之前的学习，我们已经掌握了如何判断一个数是否为质数。我
们将判断质数的代码融合到上面的代码中，完整的代码如下：
    #include <stdio.h>
    #include <stdlib.h>     int main()    {         int k, a, b, i, count1, count2;         for(k=4; k<=100; k=k+2)
        {               for(a=2; a<=k/2; a++)
              {
                //判断a是否为质数                 count1=0;                 for(i=2; i<=a-1; i++)
                {                       if(a%i==0)
                      {                           count1++;                           break;
                      }                 }                 if(count1==0) //如果a为质数
                {                     b=k-a;
                    //判断b是否为质数                     count2=0;                     for(i=2; i<=b-1; i++)
                    {                           if(b%i==0)
                          {                             count2++;                             break;
                          }                     }                     if(count2==0) //如果b也是质数
                    {                           printf("%d=%d+%d\n", k, a, b);                           break; //打印这个解并跳出循环
                    }
                }
            }         }
        system("pause");         return 0;
    }
　　这里只验证了从4到100的数，你也可以验证更大的范围。当然，去验证哥德巴赫猜想有很多种方法，显然这种方法是不够好的，判断质数的部分也不够快，这里只是提供一种思路，我想你一定可以找到更高效的方法。
 　更进一步，动手试一试
请在4～100内验证哥德巴赫猜想，输出每一个偶数的所有可能的拆
分方法。例如：
    4=2+2    6=3+3
    8=3+5
    10=3+7=5+5
    12=5+7
    14=3+11=7+7
    ……
第7节　逻辑挑战9：水仙花数
　　有一种三位数特别奇怪，这种数的“个位数的立方”加上“十位数的立方”再加上“百位数的立方”恰好等于这个数。例如：
153=1×1×1+5×5×5+3×3×3，我们为这种特殊的三位数起了一个很好听的名字——“水仙花数”，那么请你找出所有的“水仙花数”吧。
　　来分析一下，既然这个数是三位数，那么必然是100～999中的数。所以我们只需将所有可能性的组合一一判断就可以了。进一步分析，这个三位数的百位上只可能是1～9，十位上只可能是0～9，个位上只可能是0～9。
我们用三重嵌套循环来产生100～999，代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int i, j, k;         for(i=1; i<=9; i++)
        {             for(j=0; j<=9; j++)
            {                 for(k=0; k<=9; k++)
                {
                          printf("%d ", i＊100+j＊10+k);
                }
            }         }         system("pause");         return 0;
    }
　　在上面的代码中，我们用for循环i来表示这个三位数的百位（从1循环到9），用for循环j来表示这个三位数的十位（从0循环到9），用for循环k来表示这个三位数的个位（从0循环到9）。然后用百位上的数乘以 100加上十位上的数乘以10再加上个位上的数就组成了这个三位数，即 i×100+j×10+k。怎么样？运行了上面的代码后计算机是不是输出了100
～999呢。
接下来的问题就简单了，来判断这个数是否符合“水仙花数”的要求
就可以了。我们只需在打印之前通过if语句来判断一下就可以了。
    if(i＊100+j＊10+k==i＊i＊i+j＊j＊j+k＊k＊k)           printf("%d ", i＊100+j＊10+k);完整的代码如下：
        #include <stdio.h>         #include <stdlib.h>         int main( )
        {             int i, j, k;             for(i=1; i<=9; i++)
            {             for(j=0; j<=9; j++)
            {                 for(k=0; k<=9; k++)
                {                     if(i＊100+j＊10+k==i＊i＊i+j＊j＊j+k＊k＊k)
                    {                           printf("%d ", i＊100+j＊10+k);
                    }
                }
            }             }             system("pause");             return 0;
        }
其实，上面的代码可以简写为：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int i, j, k;         for(i=1; i<=9; i++)             for(j=0; j<=9; j++)                 for(k=0; k<=9; k++)                     if(i＊100+j＊10+k==i＊i＊i+j＊j＊j+k＊k＊k)                         printf("%d ", i＊100+j＊10+k);         system("pause");         return 0;
    }
　　因为在for循环i中只嵌套了一个for循环j, for循环j中也只嵌套了一个 for循环k, for循环k中只有一个if语句，if语句中只有一个printf语句，因此所有{ }都可以省略。
　　怎么样？做出来没有？“水仙花数”只有4个，分别是153、370、371 和407。
　　上面的方法是“拼接法”，即分别枚举百位、十位、个位上的数的所有可能，然后再拼接成一个3位数（百位×100+十位×10+个位）。其实我们还可以使用分割法，即将一个三位数x拆分成3部分，即a、b、c，分别用来存放百位、十位、个位上的数。如果
a×a×a+b×b×b+c×c×c==x，就说明这个数是“水仙花数”。
　　那现在的问题是怎样把x拆分成a、b、c呢？例如，当x等于123的时候，让a里面存1, b里面存2, c里面存3。
对于一个三位数该怎么获取它的个位上的数呢？很简单，只需将这
个数除以10求余数就可以了。
    123%10 -> 3
　　那怎么获得百位上的数呢？也很简单，只需将这个数除以100就可以了。因为在C语言中，如果“/”号的左右两边都只有整数部分的话，那么“商”也只有整数部分。
    123/100 -> 1
获得十位上的数有点麻烦，过程如下：
    123/10%10 -> 2
先将这个数除以10，去除个位，让原来的十位变成个位
（123/10→12），然后再除以10求余数就可以了（12/10→2）。转换为C语言代码：
    a=x/100;     b=x/10%10;     c=x%10;
试一试看吧：    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int x, a, b, c;         x=123;         a=x/100;         b=x/10%10;         c=x%10;         printf("%d %d %d", a, b, c);         system("pause");         return 0;
    }
怎么样？是不是成功地分离出来啦。下面，我们只需让x在100～
999内循环就可以了：
    for(x=100; x<=999; x++)
    {
    }
最后加上“水仙花数”的判断：
    if(x==a＊a＊a+b＊b＊b+c＊c＊c)
        printf("%d ", x);
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int x, a, b, c;         for(x=100; x<=999; x++)
        {             a=x/100;             b=x/10%10;             c=x%10;             if(x==a＊a＊a+b＊b＊b+c＊c＊c)                       printf("%d ", x);
        }         system("pause");         return 0;
    }
其实我们可以将
    a=x/100;
    b=x/10%10;
    c=x%10;
改为：
    a=x/100%10;     b=x/10%10;     c=x/1%10;
效果不变！有没有看出什么奥妙？自己去想吧！
　　“啊哈C”网站开通了“挑战”专栏，你可以去“啊哈C”网站上试一试，检测一下之前学习内容的掌握情况，祝你好运！“水仙花数”的挑战地址如下：
    http://tz.ahalei.com/problems/view/1
 　更进一步，动手试一试
　　1．输入一个3位数，求这个数个位、十位和百位的数之和。例如，输入782，输出17；输入156，输出12。
　　2．输入一个n 位数，范围在1～99 999 999，求这个n 位数每一位上的数之和。例如，输入12，输出3；输入234 510，输出15。
第8节　逻辑挑战10：解决奥数难题
请在两个□内填入相同的数字使得等式成立：□3×6528=3□×8256。
　　这是一个很简单的小学三年级的奥数题目，或许你可以通过口算轻而易举地解决。没有关系，我们这里只是做一个引子来看如何通过编程解决。□内所填的数是1～9的某一个数，最简单的方法就是一个一个地去试。我们的计算机最擅长的就是“不厌其烦”地重复做同一件事情，而且运行速度还非常快，即使你现在用的是市面上最坏最坏的计算机，它 1秒钟仍然可以计算100 000 000次以上。好了，言归正传，还是来看看如何通过编程解决吧。我们只需写一个循环，让变量i从1到9循环就好了，然后每次循环只需判断一下当前的i是否符合这个等式的条件，如果符合就输出其值。    #include <stdio.h>
    #include <stdlib.h>     int main()
    {         int i;         for(i=1; i<=9; i++)
        {
            if( (i＊10+3)＊6528 == (30+i)＊8256 )               printf("%d", i);
        }           system("pause");           return 0;
    }
再来看一个稍微复杂的：　　在上面的算式中，A、B、C、D、E分别代表5个互不相同的整数，请问A、B、C、D、E分别为多少时算式才会成立？请输出这个算式。
　　分析完题目后，你会发现这个题目和上面的题目是差不多的，只要 ABCD×E的积等于DCBA成立就输出。A、B、C、D、E的取值范围只可能是0～9。因此这里可以用5个嵌套循环来解决这个问题。代码如下：
    for(a=0; a<=9; a++)
     {         for(b=0; b<=9; b++)
        {           for(c=0; c<=9; c++)
          {
            for(d=0; d<=9; d++)
            {               for(e=0; e<=9; e++)
              {
                  //进行判断
              }
            }
          }
        }
      }
接下来就是判断，首先A、B、C、D、E这5个数要互不相等：
        if( a! =b && a! =c && a! =d && a! =e               && b! =c && b! =d && b! =e
                          && c! =d && c! =e                                   && d! =e )
        {
            //有待进一步判断
        }
　　再进一步判断ABCD×E的积等于DCBA是否成立，如果成立则输出：    if( (a＊1000+b＊100+c＊10+d)＊e == (d＊1000+c＊100+b＊10+a) )
    {         printf("%d%d%d%d\n", a, b, c, d);         printf("＊   %d\n", e);         printf("-----\n");         printf("%d%d%d%d\n", d, c, b, a);
    }
好了，下面是完整的代码，赶快试一试吧。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {       int a, b, c, d, e;       for(a=0; a<=9; a++)
      {         for(b=0; b<=9; b++)
        {           for(c=0; c<=9; c++)
          {           for(d=0; d<=9; d++)
          {           for(e=0; e<=9; e++)
          {
              if( a! =b && a! =c && a! =d && a! =e                       && b! =c && b! =d && b! =e
                                && c! =d && c! =e                                         && d! =e )
              {                 if( (a＊1000+b＊100+c＊10+d)＊e ==
                    (d＊1000+c＊100+b＊10+a) )
                {                     printf("%d%d%d%d\n", a, b, c, d);                     printf("＊  %d\n", e);                     printf("----\n");                     printf("%d%d%d%d\n", d, c, b, a);
                  }
              }
            }
          }
          }
        }       }
      system("pause");       return 0;
    }
运行结果如图5-1所示。图5-1　运行结果
 　更进一步，动手试一试
　　用1～6这6个自然数组成一个三角形，并让这个三角形三条边上数字之和相等。例如，如图5-2所示的三角形中，三条边的值之和分别
为：5+3+4、4+2+6、5+1+6，都等于12。那么现在请你输出所有的可能。图5-2　三角形三边之和相等
第9节　逻辑挑战11：猜数游戏
　　计算机会随机地给出0～99之间的一个整数，你能否猜出这个数呢？每猜一次，计算机都会告诉你猜的数是大了还是小了，直到你猜出这个数为止。
首先我们需要解决的第一个问题就是如何让计算机随机地产生一个
整数，这个很简单：
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {           int a;           a = rand();           printf("%d", a);
          system("pause");           return 0;
    }
　　运行一下，计算机是不是随机打印了一个数？但是多运行几次你就会发现，每次打印的数都是一样的，并没有体现随机性。上面的代码中起到产生随机数作用的语句就是rand（ ），但是只有rand（ ）是不够的，我们在rand（ ）前面加上srand（（unsigned）time（NULL））就可以了，试一试吧，完整的代码如下。注意，这里用到了time（ ）函数，因此要加上#include <time.h>才行。
    #include <stdio.h>
    #include <stdlib.h>     #include <time.h>     int main()
    {           int a;           srand((unsigned)time(NULL));           a = rand();           printf("%d", a);           system("pause");           return 0;
    }
　　srand（ ）是用来初始化随机种子数的，这里我们通过当前时间来获得这个随机种子。time的值每时每刻都不同，所以种子不同，产生的随机数也不同。然后调用rand（ ），它会根据提供给srand（ ）的种子值返回一个随机数（在啊哈C中为0～32767）。
那么如何生成0～99的整数呢？很简单，只要求随机产生的数除以
100的余数就可以了：
    srand((unsigned)time(NULL));     a = rand()%100;
　　接下来的问题，就是你每输入一个数，就让计算机去判断是大了还是小了，直到猜对为止。
输入数据我们可以用scanf语句，判断大小我们可以用if语句。
    #include <stdio.h>
    #include <stdlib.h>     #include <time.h>     int main()
    {           int a, b;           srand((unsigned)time(NULL));           a = rand()%100;           scanf("%d", &b);           if(b>a)               printf("大了，请继续\n");           if(b<a)               printf("小了，请继续\n");           if(b==a)           {               printf("恭喜你答对了\n");
          }
          system("pause");           return 0;
    }
　　运行上面的代码你会发现，我们只猜了一次就不能猜了，在这里我们用while循环来解决这个问题。
    #include <stdio.h>
    #include <stdlib.h>     #include <time.h>     int main()
    {         int a, b;         srand((unsigned)time(NULL));         a = rand()%100;         while(1)         {             scanf("%d", &b);             if(b>a)                 printf("大了，请继续\n");             if(b<a)                 printf("小了，请继续\n");             if(b==a)             {                 printf("恭喜你答对了\n");
                break;
            }         }         system("pause");         return 0;
    }
在上面的代码中，我们使用while（1）让程序进入无限循环中，然
后当你猜对时，也就是a==b时，用break；来及时退出循环。我们可以让这个程序变得更有趣一点——限定猜数的次数。
    #include <stdio.h>
    #include <stdlib.h>     #include <time.h>     int main()
    {         int a, b, sum;         sum=6;         srand((unsigned)time(NULL));         a = rand()%100;         while(1)         {             sum--;             scanf("%d", &b);
            if(b>a)
                printf("大了，还剩下%d次机会，请继续\n", sum);             if(b<a)
                printf("小了，还剩下%d次机会，请继续\n", sum);             if(b==a)             {
                printf("恭喜你，答对了！\n");                 break;
            }             if(sum==0)
            {
                printf("已经没有机会了，请重新开始吧！\n");
                break;
            }         }         system("pause");         return 0;
    }
　　在上面的代码中，我们用sum来进行计数。初始的时候sum=6，表示有6次猜的机会，然后每猜一次就执行sum--，直到sum为0，全部机会用完，程序结束。
 　更进一步，动手试一试
想一想，如何生成一个1～20 000 000的随机数？
第10节　逻辑挑战12：你好坏，关机啦
　　学了这么多节，真是不容易啊！终于到了第5章的最后一节。本节我们将学着写一个恶作剧程序——将别人的计算机关机的程序。只要别人一运行你的程序，他的计算机就会立即关机。 [1]
其实关机的命令非常简单：
    system("shutdown -s -t 50");
　　上面语句中的“shutdown”就是表示令计算机关机或者重新启动的命令，“-s”表示关机，“-r”表示重新启动，待会儿你可以试一试将“-s”用“-
r”代替。“-t 50”表示的是在50秒后关机。“-t”和“50”之间有一个空格。完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {           system("shutdown -s -t 50");           return 0;
    }
怎么样，是不是启动关机程序了，如图5-3所示。图5-3　正在进行关机倒计时
在等待50秒之后就会关机啦。
　　如果这个程序一运行就关机，那就太没有意思啦！我们可以将这个程序和本章第9节的猜数问题结合在一起。如果你在6次之内猜出来了，就显示“恭喜你，答对了！”。如果没有猜出来就显示“没有机会了，系统将在50秒后关机！”。完整代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <time.h>     int main()
    {         int a, b, sum;         sum=6;         srand((unsigned)time(NULL));         a = rand()%100;         while(1)
        {
            sum--;             scanf("%d", &b);             if(b>a)
                printf("大了，还剩下%d次机会，请继续\n", sum);             if(b<a)
                printf("小了，还剩下%d次机会，请继续\n", sum);             if(b==a)             {
                printf("恭喜你，答对了！\n");                 break;
            }             if(sum==0)
            {
                printf("没有机会了，系统将在50秒后关机\n");
                system("shutdown -s -t 50");                 break;
            }         }         system("pause");         return 0;
    }
哦，对了，还有一个取消关机的命令：
    system("shutdown -a");[1] 本节介绍的关机程序只能在Windows操作系统上实现关机。
第6章天啊！一大串数正在接近第1节　逆序输出
　　思考一个问题：如何从键盘输入5个整数，然后将其逆序输出？比如，输入6、3、5、7、8，则输出8、7、5、3、6。
你可能会说很简单啊，可以这样写：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a, b, c, d, e;         scanf("%d%d%d%d%d", &a, &b, &c, &d, &e);         printf("%d %d %d %d %d", e, d, c, b, a);         system("pause");         return 0;
    }
当然，你也可以这样写：    #include <stdio.h>     #include <stdlib.h>     int main( )     {         int a, b, c, d, e;         scanf("%d", &a);         scanf("%d", &b);         scanf("%d", &c);         scanf("%d", &d);         scanf("%d", &e);         printf("%d ", e);         printf("%d ", d);         printf("%d ", c);         printf("%d ", b);         printf("%d ", a);         system("pause");         return 0;
    }
不要鄙视我，我没有开玩笑，这样写虽然显得更为复杂，但是在接
下来的章节中，你一定会发现这样写的好处。
　　现在5个数还好办，如果要想读入100个数，然后将这100个数逆序输出该怎么办呢？那岂不是要累死……请看下一节。
第2节　申请100个小房子怎么办
在第2章中，我们就已经学习了如何申请一个变量（小房子），很
简单：
    int a;
那如果我要申请10个变量呢，你可能会这样写：
    int a, b, c, d, e, f, g, h, i, j;
那如果要申请100个呢，你可能会说没关系啊，慢慢写呗：
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13
, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a2
8, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a4
3, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a5
8, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a7
3, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a8
8, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99, a100;
　　那如果要申请10 000个呢？如果这样写下去，估计不吃晚饭也写不完。下面将介绍一种简洁的写法，用一行语句就可以一次性申请10 000 个变量。
    int a[10000];
怎么样，是不是很方便，如果只需申请10个，我们可以依葫芦画
瓢：
    int a[10];
　　在上面这行语句中，我们定义了10个整型变量，就如同10个“小房子”并排放在了一起：如何使用这些变量呢？不要着急，马上揭晓。
首先，int a[10]；中[ ]里的数字表示需要定义变量的个数，我们这
里定义了10个。这10个变量分别用a[0]、a[1]、a[2]、a[3]、a[4]、a[5]、 a[6]、a[7]、a[8]、a[9]来表示。你可能有一个疑问，为什么是从a[0]到a[9]，而不是从a[1]到a[10]
呢？为什么从0开始计数呢？从1开始多好啊！其实一点也不奇怪，只是习惯不同罢了。我们中国人比较喜欢从1开始计数，比如说“楼房”是第一层、第二层……可是在国外，首层是Ground 	Floor，然后才是First
Floor（第一层）、Second Floor（第二层）……
假如我们要将a[0]～a[9]这10个变量分别存储0、1、4、9、16、
25、36、49、64、81的话，可以这样写：
    a[0]=0;     a[1]=1;     a[2]=4;     a[3]=9;     a[4]=16;     a[5]=25;     a[6]=36;     a[7]=49;     a[8]=64;     a[9]=81;当然，你也用for循环来简化上面的代码：
    for(i=0; i<=9; i++)
    {         a[i]=i＊i;
    }
好，我们来看一段完整的代码：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a[10], i;         for(i=0; i<=9; i++)
        {             a[i]=i＊i;
        }         for(i=0; i<=9; i++)
        {             printf("%d ", a[i]);
        }         system("pause");
        return 0;
    }
　　上面这段代码，就是将0、1、4、9、16、25、36、49、64、81这10 个数放入a[0]～a[9]中，然后再将a[0]～a[9]中的数打印出来。第3节　100个数的逆序
好，回到本章的第1个问题——如何逆序输出。我们将利用“数
组”来彻底解决这个问题。
很简单，我们先解决输入的问题。根据本章第2节的方法，可以这
样写：
    #include <stdio.h>     #include <stdlib.h>     int main( )     {         int a[5];         scanf("%d", &a[0]);         scanf("%d", &a[1]);         scanf("%d", &a[2]);         scanf("%d", &a[3]);         scanf("%d", &a[4]);         system("pause");         return 0;
    }
接着可以用for循环来简化上面的代码：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a[5], i;         for(i=0; i<=4; i++)
        {             scanf("%d", &a[i]);
        }         system("pause");         return 0;
    }
	那逆序输出该怎么办？只需将for（i=0; 	i<=4; 	i++）改为for（i=4;
i>=0; i--）就可以了。
        for(i=4; i>=0; i--)
        {             printf("%d ", a[i]);
        }
完整的代码如下：    #include <stdio.h>     #include <stdlib.h>     int main( )
    {         int a[5], i;         for(i=0; i<=4; i++)
        {             scanf("%d", &a[i]);
        }         for(i=4; i>=0; i--)
        {             printf("%d ", a[i]);
        }
        system("pause");         return 0;
    }
第4节　逻辑挑战13：陶陶摘苹果
陶陶摘苹果 [1] 的问题描述如下：
陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。
苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30cm高的板凳，当她不能直接用手摘到苹果时，就会踩到板凳上再试试。
　　现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。【输入格式】
　　输入文件包括两行数据。第1行包含10个100～200之间（包括100和 200）的整数（以cm为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用1个空格隔开。第2行只包括1个100～120之间（包含100 和120）的整数（以cm为单位），表示陶陶把手伸直时能够达到的最大高度。
【输出格式】
　　只包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。
【样例输入】
    100 200 150 140 129 134 167 198 200 111
    110
【样例输出】
    5
　　这个题目很简单，题目的输入数据中已经给出了每个苹果的高度和陶陶的身高。我们只需依次来判断“每个苹果的高度”是否小于等于“陶陶的身高加板凳的高度”。
　　陶陶的身高是一个整数，我们可以用一个整型变量h来存储。10个苹果的高度，我们可以用一个大小为10的整型数组a[10]来存储。代码如下：
    int h, a[10];
　　解决了存储的问题，接下来我们来解决读入的问题。题目在给出数据时是先给出10个苹果的高度，再给出陶陶的身高。那我们要注意读入的顺序。
    for(i=0; i<=9; i++)           scanf("%d", &a[i]);     scanf("%d", &h);
　　上面的代码中，我们利用for循环来读入10个苹果的高度并存入数组 a中。要注意的是，我们在定义数组a的时候，写的是int 	a[10]，虽然申请了10个空间，但是数组是从0开始计数的，所以是a[0]～a[9]。当然你
也可以写int a[11]，就可以用a[1]～a[10]了，只是浪费了a[0]这个空间。其实我更倾向于第2种写法，因为我们中国人更喜欢从1开始计数。
　　在解决了输入问题后，我们需要统计陶陶可以摘到多少苹果了。我们仍然要使用for循环来依次判断陶陶能否摘到每个苹果。如果苹果的高度<=陶陶的身高+板凳的高度，那么这个苹果陶陶就可以摘到。板凳的高度是固定的，为30cm。
    sum=0;     for(i=0; i<=9; i++)
    {           if( a[i] <= h+30 )                 sum++;
    }
    printf("%d", sum);
上面的代码中，整型变量sum是用来计数的，所以一定不要忘记
sum的初始值为0，当然在使用sum这个变量前别忘了定义int sum;，最后只需输出sum的值就可以了。完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {           int h, a[10], i, sum;           for(i=0; i<=9; i++)                 scanf("%d", &a[i]);           scanf("%d", &h);           sum=0;           for(i=0; i<=9; i++)
          {                 if( a[i] <= h+30 )                       sum++;
          }           printf("%d", sum);           system("pause");           return 0;
    }
第5节　逻辑挑战14：一个萝卜一个坑
　　这里有一个有趣的问题：从键盘输入5个0～9的数，然后输出0～9 中那些没有出现过的数。例如，输入2 5 2 1 8时，输出0 3 4 6 7 9。
想一想，有没有什么好办法？
我们这里借助一个数组就可以解决这个问题。
　　首先我们需要申请一个大小为10的数组int a[10];。好了，现在你已经有了10个小房间，编号为a[0]～a[9]。
刚开始的时候，我们将a[0]～a[9]都初始化为0。　　然后用a[0]来表示数字0是否会出现，用a[1]来表示数字1是否会出现……用a[9]来表示数字9是否会出现。
　　下面就好办了，一会儿哪个数字出现，我们就把相应的小房间的值从0改为1。例如，第一个出现的数是2，我们就把a[2]这个小房间中的值从0变为1。下一个出现的数是5，我们就把a[5]这个小房间中的值从0变为1。注意啦，接下来出现的数又是2，此时a[2]这个小房间中的值已经是
1，所以值还是1。接下来出现的数是1，我们就把a[1]这个小房间中的值从0变为1。最后出现的数是8，我们就把a[8]这个小房间中的值从0变为1。　　看一下最后a[0]～a[9]这10个小房间中的数，你会惊奇地发现：出现过的数，它们所对应的小房间中的值都为1；没有出现过的数所对应的小房间中的值都为0。接下来，只需把小房间中值为0的小房间的编号输出就可以啦。
    #include <stdio.h>
    #include <stdlib.h>
    int main()
    {         int a[10], i, t;         for(i=0; i<=9; i++)           a[i]=0; //初始化每个小房间为0
        for(i=1; i<=5; i++)
        {             scanf("%d", &t); //依次读入5个数             a[t]=1;         //把对应的小房间改为1
        }         for(i=0; i<=9; i++)
            if(a[i]==0)     //输出没有出现过的数                   printf("%d ", i);         system("pause");         return 0;
    }
　　好了，大功告成了！其实这个方法就是“一个萝卜一个坑”。我们将 0～9中的每个数都用单独1个房间来表示，每出现一个数，就将所对应
的房间中的值改为1，最后只要看看哪些房间里面的值仍然是0就好了。
就好比原来有10个萝卜，从0～9编号：　　然后安排人去拔萝卜，第1个人去拔2号萝卜。第2个人去拔5号萝卜，第3个人再去拔2号萝卜（其实此时2号萝卜已经被拔走了），第4个人去拔1号萝卜，第5个人去拔8号萝卜，最后剩下的萝卜的就是答案了。是不是很简单呢？　　下一个问题：如果现在需要将输入的5个数（范围是0～9）从小到大排序，该怎么办？例如，输入2 5 2 1 8，则输出1 2 2 5 8。
也很简单，只需将上面的代码稍加改动就可以了。
　　首先我们仍然需要申请一个大小为10的数组int a[10]，编号为a[0]～ a[9]，并初始化为0。在之前的程序中，哪个数字出现了，我们就将相应的小房间的值从
0变为1。而现在我们只需将“小房间的值从0变为1”改为“小房间的值加
1”就可以了。例如，2出现了，就将a[2]中的值加1。接下来的数是5，就将a[5]中的值加1。　　到目前为止，貌似和之前的程序没什么不同。下面，关键的一步来了。下一个出现的数又是2，我们再将a[2]中的值加1。注意到没有，此时a[2]中的值为2。
接下来的数是1，就将a[1]中的值加1。最后一个数是8，将a[8]中的值加1。　　发现没有，其实a[0]～a[9]中所记录的数值就是0～9每个数所出现的次数。其中1出现1次，2出现2次，5出现1次，8出现1次。
　　接下来，我们只需将出现过的数，按照出现的次数打印出来就可以了。具体如下：
a[0]为0，表示0没有出现过，不打印。 a[1]为1，表示1出现过1次，打印1次。屏幕上显示“1”
a[2]为2，表示2出现过2次，打印2次。屏幕上显示“1 2 2” a[3]为0，表示3没有出现过，不打印。 a[4]为0，表示4没有出现过，不打印。
a[5]为0，表示5出现过1次，打印1次。屏幕上显示“1 2 2 5” a[6]为0，表示6没有出现过，不打印。 a[7]为0，表示7没有出现过，不打印。
a[8]为1，表示8出现过1次，打印1次。屏幕上显示“1 2 2 5 8” a[9]为9，表示9没有出现过，不打印。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a[10], i, j, t;         for(i=0; i<=9; i++)           a[i]=0; // 初始化为0
        for(i=1; i<=5; i++)  // 循环读入5个数
        {
            scanf("%d", &t); // 把每一个数读到变量t中
            a[t]++;          // t所对应小房子中的值增加1
        }
       for(i=0; i<=9; i++)    // 依次判断0～9这个10个小房子             for(j=1; j<=a[i]; j++)   //出现了几次就打印几次                   printf("%d ", i);
        system("pause");         return 0;
    }
　　至此，我们已经巧妙地将输入的数据，按照从小到大的顺序排序了。当然，你也可以从大到小排序，自己想一想吧！
　　尝试一下，输入n个0～1 000的整数，将它们从小到大排序。如果想对1 000以内的整数排序，我们需要1 001个小房子来表示每个数出现的次数，定义时要注意哦。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a[1001], i, j, t, n;         for(i=0; i<=1000; i++)           a[i]=0;
        scanf("%d", &n);         for(i=1; i<=n; i++)
        {             scanf("%d", &t);             a[t]++;
        }         for(i=0; i<=1000; i++)             for(j=1; j<=a[i]; j++)                   printf("%d ", i);
        system("pause");         return 0;
    }
例如，输入：
  10
  1 10 100 1000 2 20 200 3 30 300
程序将会输出：
    1 2 3 10 20 30 100 200 300 1000
第6节　逻辑挑战15：选择排序
在本章第5节中，我们已经学过一种排序方法，但是这种排序方法
有一个弊端，就是很浪费空间，假如需要排序的数是0～2 100 000 000 的话，你需要申请2 100 000 001个小房子，也就是说要写成int a[2 100 000 001]。因为我们需要用2 100 000 001个小房子来存储0～2 100 000
000中每一个数出现的次数，即使是给5个数进行排序（例如，1、1 912 345 678、2 100 000 000、18 000 000、1 912 345 678），也需要申请2 100 000 001个小房子，真是太浪费了空间了。因此，本节我们将介绍另外一种排序方法：选择排序。
　　其实选择排序的基本思想我们早在第3章第7节就已经讲过。先来回顾一下3个数的排序。从键盘读入3个数并分别放入变量a、b、c中。
　　第1轮，先将a与b进行比较，把a和b中较大的一个放在a中。再将a 与c进行比较，把a和c中较大的一个放在a中，到此第一轮结束。我们可以确定小房子a中存储的数一定是原先3个数中最大的。　　下面开始第2轮，比较小房子b中的数和小房子c中的数，将较大的数放在小房子b中。　　经过3轮比较，我们终于排序完毕，最大的数放在小房子a中，次大的数放在了小房子b中，最小的数放在小房子c中。
好，这次将77、45、26、86和9这5个数从小到大排序，请注意，我们现在是进行从小到大排序。首先确定第1位上的数。完整的排序过程如下（2、3、4轮均为模拟上述的方法产生的结
果）：
    初始数据      [77  45   26  86   9]     第1轮排序后     9 [77   45  86  26]     第2轮排序后     9  26 [77   86  45]     第3轮排序后     9  26   45 [86  77]     第4轮排序后     9  26   45  77 [86]     最后结果        9  26   45  77  86
怎么样，算法理解了没有？接下来看看如何用代码实现。
我们可以用整型数组来存储这5个数，即int 	a[6];，其中我们不用 a[0]，只使用a[1]～a[5]。因为我个人比较喜欢从a[1]开始，当然若你喜欢也可以从a[0]开始。
    int a[6], i;     for(i=1; i<=5; i++)           scanf("%d", &a[i]);
对于a[1]来说，它需要和a[2]、a[3]、a[4]、a[5]比较。对于a[2]来说，它需要和a[3]、a[4]、a[5]比较。对于a[3]来说，它需要和a[4]、a[5]比较。对于a[4]来说，它只需要和a[5]比较。
如果只对5个数进行排序，只需进行4轮，因为若前4个数排好了，
剩下的1个一定在最后。
　　我们来抽象一下，对于a[i]来说，它需要和a[i+1]、a[i+2]……a[5]比较。
    for(i=1; i<=4; i++)       //对于5个数来说，只需要进行4轮，确定前
4位
    {       for(j=i+1; j<=5; j++)   //a[i]需要和a[i+1]、a[i+2]……a[5]比较
      {             if(a[i]>a[j])     //这里是从小大到大排序
            {                 t=a[i]; a[i]=a[j]; a[j]=t;  //交换数值
            }
      }
    }
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a[6], i, t, j;         for(i=1; i<=5; i++)               scanf("%d", &a[i]);         for(i=1; i<=4; i++)
        {             for(j=i+1; j<=5; j++)
            {                 if(a[i]>a[j])
                {  t=a[i]; a[i]=a[j]; a[j]=t;  }
            }
      }
      for(i=1; i<=5; i++)           printf("%d ", a[i]);       system("pause");       return 0;
    }
　　我们将上面的代码稍微改动一下，就可以实现输入n个数，并将这n 个数按照从小到大或者从大到小的顺序输出，自己去尝试一下吧！第7节　二维数组　　我们之前学习的都是一维数组，可是如果想表示一个“围棋的棋盘”或者我们在第2章第1节说到的“数独”时，就希望能有一种方法来表示二维的矩阵。二维数组正好可以解决这个问题。例如，我们需要表示上面这个3行4列的矩阵该怎么办呢？很简单：
    int a[3][4];
　　上面这行语句的作用是定义一个二维数组，它有3行4列，分别是 a[0]行、a[1]行和a[2]行。其实你可以把这个二维数组理解为由3个一维数组叠加而成（这3个一维数组分别是a[0]、a[1]和a[2]）。而每1个一维数组又都有4列，分别是第[0]列、第[1]列、第[2]列和第[3]列。　　那么如何使用这个二维数组呢？很简单，例如，第0行第0列就是 a[0][0]，第1行第2列就是a[1][2]……
　　好了，小小地总结一下：int a[3][4]；这条语句中第1个参数表示有多少行，第2个参数表示有多少列。因为是从0开始计数的，因此左上角第1个是a[0][0]，右下角最后1个是a[2][3]。我们可以通过“两个for循环嵌套”来为这个二维数组赋值：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a[3][4], i, j, x;         x=0;         for(i=0; i<=2; i++) //i循环用来控制行数
        {             for(j=0; j<=3; j++)  //j循环用来控制列数
            {                 a[i][j]=x;                 x++;
            }         }
        for(i=0; i<=2; i++)
        {             for(j=0; j<=3; j++)
            {                       printf("%d ", a[i][j]);
            }             printf("\n"); //一行打印完毕需要换行
        }         system("pause");         return 0;
    }
上面这段代码的效果如下：第8节　剩下的一些东西
本节我们来认真聊一聊数组的初始化，先来聊一维数组的。
　　假如我们需要申请一个大小为10的整型数组，并将数组中每一个“小房间”的值依次初始化为0～9，通过之前学习的知识我们可以这样写：    int a[10], i;     for(i=0; i<=9; i++)       a[i]=i;
其实还有一个简便写法：
    int a[10]={0,1,2,3,4,5,6,7,8,9};
　　假如需要将数组中所有“小房间”都初始化为0，我们也可以这样写：
    int a[10]={0,0,0,0,0,0,0,0,0,0};
简便写法为：
    int a[10]={0};
你可能要问，如果我们把数组中的所有“小房间”都初始化为1的
话，是不是也可以这么写呢？形如：
    int a[10]={1};
　　很不好意思，这样写的效果是只有a[0]的值为1, 	a[1]～a[9]的值为 0。为什么呢？不要着急，请你再运行一下下面这段代码，猜一猜a[0]
～a[9]的值分别是多少？
    #include <stdio.h>
    #include <stdlib.h>     int main()
    {         int a[10]={7,9,8}, i;
        for(i=0; i<=9; i++)           printf("%d ", a[i]);         system("pause");         return 0;
    }
　　运行之后你会发现a[0]的值为7, a[1]的值为9, a[2]的值为8, a[3]～a[9] 的值都为0。　　其实在定义数组时对数组进行初始化，编译器会从a[0]开始按顺序进行赋值，后面没有具体值的将默认为0。这样你就能理解为什么全部
初始化为0时可以写成int a[10]={0}；但是全部初始化为1就不能写成int a[10]={1}；了。
　　你可能要问，如果只定义一个数组而不进行任何初始化，那么这个数组里面的每一个“小房间”的默认值会是什么呢？答案是：随机值。不信就试一试吧。请运行下面的代码：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a[10], i;
        for(i=0; i<=9; i++)           printf("%d ", a[i]);         system("pause");         return 0;
    }
下一个问题：二维数组如何进行初始化呢？请看下面的代码：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a[3][5]={{1,2,3}, {4,5}}, i, j;         for(i=0; i<=2; i++)
        {           for(j=0; j<=4; j++)
          {             printf("%d ", a[i][j]);
          }           printf("\n");
        }         system("pause");         return 0;
    }
运行效果如图6-1所示。图6-1　二维数组初始化运行结果
　　这个数组有3行5列，第1行我们初始化了前3个，第2行我们初始化了前两个，剩下的将全部默认为0。需要注意的是，在初始化每1行时，每1行都要用{ }括起来才行。如果不用{ }括起来的话，会怎么样呢，自己去试一试吧！
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         int a[3][5]={1,2,3,4,5}, i, j;         for(i=0; i<=2; i++)
        {           for(j=0; j<=4; j++)
          {             printf("%d ", a[i][j]);
          }           printf("\n");
        }         system("pause");         return 0;
    }
运行效果如图6-2所示。图6-2　二维数组初始化运行结果[1] 《陶陶摘苹果》题目来源于第十一届全国青少年奥林匹克信息学联赛复赛普及组试题（NOIP 2005）。第7章有了它你能做更多的事第1节　字符的妙用　　在第2章中我们就已经知道，存储整数可以用int，存储小数可以用 float，存储单个字符可以用char。
　　我们用char a；定义一个字符变量a，用scanf（"%c", &a）；来从键盘读取一个字符并存放在变量a中，用printf（"%c", a）；来输出变量a中的字符。下面这段代码的作用就是从键盘读入一个字符并将其输出：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         char a;         scanf("%c", &a);         printf("你刚才输入的字符是%c", a);
        system("pause");         return 0;
    }
如何给一个字符变量赋值呢？很简单：
    char a;     a='x';
请注意，x的两边是单引号，千万不要输错了。或者可以简写为：
    char a='x';
　　关于简写，我们已经在第2章的第11节有所介绍。忘记的同学赶快回顾一下吧！
下面的内容要注意啦！
    a='1';
是把字符1赋值给字符变量a。请注意’1'、1、"1"是不同的。第1个是字符，所以两边是单引号；第2个是整数1；第3个是字符串，所以两边是用双引号，只不过"1"这个字符串看起来里面只有1个字符罢了（请注意，这里看起来只有一个字符，其实并不是，后面会讲到）。
　　好了，了解上面有关字符的知识后，我们可以做一个稍微复杂的计算器啦。用户可以输入a+b、a-b、a*b、a/b（这里的a和b指的是任意整数）的任意一种形式，程序便可以自动识别此时是要进行加法运算、减法运算、乘法运算还是除法运算。
由于输入的格式是“整数　运算符　整数”，所以我们需要3个变
量：两个整数变量用来存储两个整数，一个字符变量用来存储运算符。
    int a, b;     char c;
　　接下来就是读入部分了，输入的顺序是“整数　运算符　整数”，所以我们scanf的顺序就是"%d%c%d"。注意双引号中没有空格。
    scanf("%d%c%d", &a, &c, &b);　　读入之后，第1个整数存储在整型变量a中，第2个整数存储在整型变量b中，运算符存储在字符变量c中。接下来就要对字符变量c所存储的内容进行分情况讨论，如果是加号则进行加法运算，如果是减号则进行减法运算，如果是乘号则进行乘法运算，如果是除号则进行除法运算。代码如下：
    if(c=='+')       printf("%d", a+b);     if(c=='-')       printf("%d", a-b);     if(c=='＊')       printf("%d", a＊b);     if(c=='/')       printf("%d", a/b);
至此，我们已经完成了整个程序。完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {           int a, b;           char c;           scanf("%d%c%d", &a, &c, &b);
          if(c=='+')               printf("%d", a+b);           if(c=='-')               printf("%d", a-b);           if(c=='＊')               printf("%d", a＊b);           if(c=='/')               printf("%d", a/b);           system("pause");           return 0;
    }
　　怎么样，请输入5-6或5+6试一试吧，看看计算机能否计算出正确答案呢？
第2节　多余的回车键
读取一个字符除了可以用scanf（"%c", &a）；语句外，其实还有其
他方法。
    char a;     a=getchar();
　　a=getchar（）；与scanf（"%c", &a）；的作用是完全一样的。我们将第2章第8节代码中的scanf（"%c", &a）；替换为a=getchar（）；来试验一下。
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         char a;         a=getchar();         printf("你刚才输入的字符是%c\n", a);
        system("pause");         return 0;
    }
　　我们输入一个字符“x”后按“Enter”键（回车键），效果如图7-1所示。图7-1　输入一个字符并输出
运行之后你会发现这与第2章第8节代码的效果是完全一样的。
　　没错，使用scanf（ ）和getchar（ ）都可以读取一个字符，但是当用户输入一个字符后，程序并不会继续往下执行，直到用户按
下“Enter”键，程序才会认为刚才的输入已经结束，然后继续执行余下的内容。有时这一点显得很不友好。
　　其实用scanf（ ）和getchar（ ）来读取一个字符时，首先是将输入的字符接收到缓冲区，缓冲区是一块为用户的输入预留的内存区域。缓冲区不会自动释放，直到用户按下“Enter”键，缓冲区内的字符才会被释放，让我们的程序接收到。这意味着两件事情：第一，只要用户还没有按下“Enter”键，用户就可以用“Backspace”键（退格键）或者“Delete”键
（删除键）来纠正错误的字符输入；第二，如果用户没有按
下“Enter”键，输入的字符就会一直逗留在缓冲区中，不会被我们所写的程序接收到，直到用户按下“Enter”键。
　　有时这样的缓冲机制并不能满足我们的需求，假如要制作一个“贪食蛇”或者“走迷宫”的游戏，你可能并不希望用户在按下方向键之后仍需按下“Enter”键才会改变我们的“蛇”或者“小人”的方向。如果是这样的话，这个游戏的用户体验就太差了。我们希望在按下一个按键后，计算机能马上做出反应，而不再需要按下多余的“Enter”键。
　　啊哈，你有福了，getche（ ）就可以满足你的需求，请看下面的代码：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         char a;         a=getche();         printf("你刚才输入的字符是%c", a);
        system("pause");         return 0;
    }
运行效果如图7-2所示。图7-2　无须按回车键就输出
　　试过了没有，是不是在你输入字符x后，还没有按下“Enter”键，计算机就立马给出了“你刚才输入的字符是x”的反应。我还要再介绍一个好东西，那就是更为神奇的getch（ ）！那么 getche（ ）和getch（ ）有什么区别呢，自己去试一试吧。使用getch（
）之后，我们输入字符x后，运行效果如图7-3所示。图7-3　无须按回车键就输出且不带回显
好了，本节介绍了3种新方法来读取一个字符，区别如下：
　　getchar（）读取一个字符，输入后等待用户按“Enter”键结束（带回显）。
　　getche（）读取一个字符，输入后立即获取字符，不用按“Enter”键结束（带回显）。
　　getch（）读取一个字符，输入后立即获取字符，不用按“Enter”键来结束（不带回显）。
第3节　字符的本质
　　你猜字符1和1是什么关系？字符a和97又是什么关系呢？我们先来看一段代码：
    #include <stdio.h>     #include <stdlib.h>     int main()
    {       int i;       for(i=0; i<=127; i++)
      {               printf("%d %c\n", i, i);
      }       system("pause");       return 0;
    }
　　在上面的代码中，循环变量i从1开始循环，一直循环到128。在输出时，将整型变量i的值输出了两次：第一次以“%d”的方式输出，第二次以“%c”的方式输出。显然，变量i是整型变量，我们用“%d”的方式来输出变量i的值是没有任何问题的。关键问题是：我们用“%c”来输出整型变量i的值时计算机会输出什么呢？“%c”不是用来输出字符的吗？我们来看看运行效果，如图7-4所示。图7-4　ASCⅡ字符
　　经过观察发现，“%d”确实输出了整数（1～128），这个没有问题，但是“%c”却输出了一些“乱七八糟”的字符。例如：i的值为1时，通过“%c”竟然输出了一个“笑脸”；当i为3、4、5、6时，输出了扑克牌中的一些符号。
　　再通过仔细观察可以发现，i为48时输出字符0, i为49时输出字符1, i 为50时输出字符2……i为57时输出字符9。
　　i为65时输出大写字母A, i为66时输出大写字母B, i为67时输出大写字母C……i为90时输出大写字母Z。
　　i为97时输出小写字母a, i为98时输出小写字母b, i为99时输出小写字母c……i为122时输出小写字母z。
你可以看看“+”、“-”、“*”、“/”、“>”、“<”等所对应的数字分别是多
少。
　　你肯定会觉得很奇怪，为什么1～128每一个整数在计算机中都对应 1个字符呢（7～10你可能看不到）？其实计算机本质上只能存储0和1，任意整数都可以通过进制转换的方式变化成0和1的序列。所以表示字符最简单的方法就是把字符用整数来代替。例如，字符a就用97来表示，此处的97就是字符a的ASCII码。有关ASCII码的详细信息，有兴趣的同学可以自己在课下学习。
　　从某种角度来说，97有两层含义，第1层含义是整数97，第2层含义是字符a。当你需要以整数的形式打印出来时就用“%d”，当你需要以字符的形式打印出来时就用“%c”。
好了，你应该知道1和字符1的区别有多大了。1就是整数1，而字符
1换算成整数却是49。
第4节　人名怎么存储呢
　　到目前为止，学了这么久，我们竟然还不知道如何存储人名！先来解决如何存储“英文人名”的问题。人名说白了就是一串字符，单个字符我们已经知道如何存储了，代码如下：
    char a;
　　这样就定义了一个字符变量a来存储单个字符。那么如何存储多个字符呢？我们又想到了第6章学到的数组。没错，字符也有数组形式，叫作字符数组，也叫作字符串，形式如下：
    char a[10];
　　这样就定义了一个字符数组a，或者叫字符串a。它有10个小空间，即a[0]～a[9]。
　　这里需要注意的是：虽然有10个小空间，但实际上只能存储9个字符，因为最后一个小空间需要用来存储字符串的结束标记‘\0'，用来表示字符串的结尾。不要小看这个结束标记，很多地方都需要利用它。
那么如何读取一行字符串呢？有很多种方法。    scanf("%s", a);
请注意，a前面没有取址符“&”。这里确实很特殊，在用scanf进行
读入时，只有与“%s”配合使用来读取一行字符串时，才不需要在变量前加取址符“&”。至于为什么以后再说吧，有兴趣的同学去问问“谷哥”或者“度娘”！输出一行字符串同样很简单：
    printf("%s", a);
请看下面一段代码：
    #include <stdio.h>     #include <stdlib.h>     int main( )     {           char a[10];           scanf("%s", a);           printf("%s", a);           system("pause");           return 0;
    }
　　上面代码的功能是，从键盘输入一行字符串，然后原封不动地将输入的字符串再次输出。假如你输入的是hello，那么也会输出hello，如图
7-5所示。图7-5　输出一个字符串
     强调一下，此处的字符数组a（或者称作字符串a）只申请了10个空间，但只能存9个有效字符，因为最后一个需要用来存储字符串的结束标记‘\0'。
　　好了，我们来看1个题目：第1行先输入1个人的名字，空1格后输入这个人的分数，第2行还是先输入1个人的名字，空1格后输入这个人的分数。代码如下：
    Jack 90
    Tom 99
　　然后请输出分数较高的这个人的名字，对于上面的输入，我们应该输出Tom。想一想应该怎么做呢？
　　我们的程序需要接收4个信息，分别是第1个人的名字和分数，以及第2个人的名字和分数。人名我们可以用字符数组来存储，分数可以用整型来存储。因此我们需要两个字符数组和两个整型变量。
    char a[101], b[101];
    int x, y;
这里字符数组a和b的大小都是101，因为一般人的名字应该不会超过100 个字符吧！
然后需要解决的就是如何输入了。根据输入的规则，先是1个人名
和1个整数，接下来还是1个人名和1个整数。
    scanf("%s", a);     scanf("%d", &x);     scanf("%s", b);     scanf("%d", &y);
　　请注意，在输入时，变量a和b前面没有取址符“&”，而x和y前面有取址符“&”。第1个人的名字存储在字符数组a中，第1个人的分数存储在整型变量x中。第2个人的名字存储在字符数组b中，第2个人的分数存储在整型变量y中。接下来就是判断大小了：
    if(x>y)     {       printf("%s", a);
    }     else     {       if(x<y)       {           printf("%s", b);
      }       else       {           printf("%s和%s的分数相同", a, b);
      }
    }
好了，完整的代码如下：
    #include <stdio.h>    #include <stdlib.h>     int main( )
    {           char a[101], b[101];           int x, y;           scanf("%s", a);           scanf("%x", &x);           scanf("%s", b);           scanf("%x", &y);           if(x>y)           {               printf("%s", a);
          }           else           {               if(x<y)               {                   printf("%s", b);
              }               else               {                   printf("%s和%s的分数相同", a, b);
              }           }           system("pause");           return 0;
    }

其实，读取字符串除了用scanf外还可以用gets，用法如下：
    char a[101];     gets(a);
它们有细微的区别，请分别运行代码1和代码2，运行时请输入：
    Tom Smith
代码1如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )     {           char a[10];           scanf("%s", a);           printf("%s", a);           system("pause");           return 0;
    }代码2如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )     {           char a[10];           gets(a);           printf("%s", a);           system("pause");           return 0;
    }
分别运行后，你会发现代码1输出了：
    Tom
但是代码2却输出了：
    Tom Smith
　　由此可见，用scanf进行字符串读入时，遇到空格就提前终止了，但是用gets进行读入时却可以读入一整行。
同样，输出字符串除了用printf以外还可以用puts，用法如下：
    puts(a);
　　使用puts（a）输出时，会在末尾自动换到下一行，相当于 printf（"%s\n", a）。
给单个字符赋初始值很简单，但是如何给一个字符数组赋初始值
呢？也很简单，在字符串的两边加上双引号和花括号就可以。例如：
    char a[10]={"hello"};
第5节　逻辑挑战16：字母的排序
　　在第6章中，我们已经学习过如何对整数进行排序。本节我们将学习如何对1行字母进行排序。即读入1行小写字母，然后将这行字母从a 到z进行排序。
例如，如果输入：
    dzapytrbtc
则需要输出：
    abcdprttyz
　　之前已经讨论过字符的本质是整数。字符的排序和整数的排序是完全一样的。
首先申请一个字符数组a，然后用gets（ ）进行读入。
    char a[101]; //假设读入的字符不超过100个     gets(a);
接下来要知道读入的字符串有多长，可以用strlen（ ）来获取字符
串的长度。定义一个整型变量len（你可以改为你喜欢的名字）来存储字符串的长度：
    int len;     len = strlen(a);
需要说明的一点就是，如果你用了strlen（ ）函数，就需要在程序
的最开始（第一行），增加一条语句：
    #include <string.h>
最后，添加已经学习过的“选择排序”的代码，完整的代码如下：
    #include <string.h>
    #include <stdio.h>     #include <stdlib.h>     int main()     {         char a[101], t;         int len, i, j;         gets(a);         len=strlen(a);        for(i=0; i<=len-2; i++)
        {           for(j=i+1; j<=len-1; j++)
          {               if(a[i]>a[j])
              {                   t=a[i];                   a[i]=a[j];                   a[j]=t;
              }
          }       }       puts(a);       system("pause");       return 0;
    }
第6节　逻辑挑战17：字典序
　　我们刚刚已经知道如何对单个字符进行排序了，那如果是一个字符串呢？比如apple和pear哪一个排在前面呢？当然是apple排在pear的前
面。因为apple在英语字典中就排在pear的前面。我们在翻字典时，从第
1页开始翻，会先看到apple这个单词，然后再看到pear，这个就是字典序。
　　我们来完成这样一个例子：输入两个单词，然后按照字典序输出这两个单词。
例如，我们输入：
    pear
    apple
需要输出：
    apple     pear
　　读入和输出都很简单，关键是如何比较两个字符串。字符的比较可以用“>”、“<”、“<=”、“<=”或者“==”，但是字符串却不可以。两个字符串的比较可以用函数strcmp（ ）。strcmp（a, b）就是比较字符串a和字符串b在字典中的顺序。
如果字符串a和字符串b完全相同，那么返回值为0。
如果字符串a在字典中比字符串b先出现，那么返回值小于0。如果字符串a在字典中比字符串b后出现，那么返回值大于0。
　　举一个例子：假设a和b是两个字符数组，分别存储两个字符串，然后把a和b按照字典序输出。
    if ( strcmp(a, b) < 0)  // a在b前面
    {       puts(a);       puts(b);
    }     if ( strcmp(a, b) > 0)  // a在b后面
    {       puts(b);       puts(a);
    }     if ( strcmp(a, b) == 0) // a和b 是同一个字符串
    {       puts(a);       puts("一样的");
    }
　　好了，回到本节的题目：输入任意两个字符串，将其按字典序输出。
还有，如果你用了strcmp（ ）函数，也需要在程序的第一行增加一
条语句：
    #include <string.h>
完整的代码如下：
    #include <string.h>
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {           char a[101], b[101];           gets(a);           gets(b);           if ( strcmp(a, b) <= 0)
          {                 puts(a);                 puts(b);
          }           else

          {                 puts(b);                 puts(a);
          }           system("pause");           return 0;
    }
第7节　多行字符
　　之前我们学习了如何存储一行字符，但如果要存储多行字符该怎么办？例如，我们需要存储5个人或者5 000个人的名字该怎么办呢。
这里我们需要使用二维字符数组，其实与我们在第6章学习的普通
二维数组差不多：
    char a[5][11];
　　上面的语句就定义了一个二维的字符数组，这个字符数组有5行，每行有11列，也就是说可以存储5个长度不超过10的字符串（想一想为什么不是长度不超过11的字符串）。其实你可以这样理解：二维字符数组a有5行，每行都可以用来存储1行字符串。　　下面的代码就是读入5行字符串，然后将这5行字符串原封不动地输出。请注意在输入时每行字符串不要超过10个字符：    #include <stdio.h>     #include <stdlib.h>     int main()
    {         char a[5][11];         int i;         for(i=0; i<=4; i++)
        {             gets(a[i]);
        }         for(i=0; i<=4; i++)
        {             puts(a[i]);
        }         system("pause");         return 0;
    }
　　现在来解决这样一个问题：输入5个单词，然后把这些单词按照字典序输出。
例如，输入：
    book     books     car     zoo     apple
需要输出：
    apple     book     books     car     zoo
首先需要定义一个5行11列的二维字符数组（这里定义11列是因为
常见的英文单词都在10个字母以内）：
    char a[5][11];
接下来读入这5个单词：
    for(i=0; i<=4; i++)           gets(a[i]);
再接下来就是排序，下面的代码就是我们熟悉的选择排序：
    for(i=0; i<=3; i++)
    {         for(j=i+1; j<=4; j++)
        {                 if(a[i]>a[j])
              {                   t=a[i];                   a[i]=a[j];                   a[j]=t;
              }
        }
    }
　　原来在对整数或者字符进行排序时，a[i]、a[j]和t都是整数或字符。但是现在a[i]、a[j]和t都是一行字符串。如果想把整个字符串a[j]赋值给 a[i]，是不能写成a[i]=a[j]的，需要用到字符串复制函数strcpy（ ）。 strcpy（a[i], a[j]）；的意思就是把字符串a[j]的内容原封不动地复制到字符串a[i]中，从而替换掉字符串a[i]中原来的内容。使用strcpy（ ）函数，也需要在程序的第一行加上：
    #include <string.h>另外，在本章第6节中，我们也已经讲过两个字符串的比较也不能
直接用“>”、“<”或者“==”，而要用字符串比较函数strcmp（ 	）。
strcmp（a[i], a[j]）的作用就是比较字符串a[i]和a[j]在字典中的顺序。
好了，完整的代码如下：
    #include <string.h>
    #include <stdio.h>     #include <stdlib.h>     int main()
    {         char a[5][11], t[11];         int i, j;         for(i=0; i<=4; i++)
        {             gets(a[i]);
        }         for(i=0; i<=3; i++)
        {           for(j=i+1; j<=4; j++)
          {                 if( strcmp(a[i], a[j])>0 )
                {                     strcpy(t, a[i]);                     strcpy(a[i], a[j]);
                    strcpy(a[j], t);
                }
          }         }         for(i=0; i<=4; i++)
        {             puts(a[i]);
        }         system("pause");         return 0;
    }
关于字符串的处理函数还有strcat（ ）等，有兴趣的同学可以自己
去问“谷哥”或者“度娘”。
　　最后说一下，如果你需要使用二维字符数组中的某一个字符也是可以的。例如，第0行第0列就是a[0][0]，第1行第2列就是a[1][2]……。
a[0][0] a[0][1] a[0][2] a[0][3] a[0][4] a[0][5]a[0][6]a[0][7] a[0
][8] a[0][9] a[0][10] a[1][0] a[1][1] a[1][2] a[1][3] a[1][4] a[1][5]a[1][6]a[1][7] a[1
][8] a[1][9] a[1][10] a[2][0] a[2][1] a[2][2] a[2][3] a[2][4] a[2][5]a[2][6]a[2][7] a[2
][8] a[2][9] a[2][10] a[3][0] a[3][1] a[3][2] a[3][3] a[3][4] a[3][5]a[3][6]a[3][7] a[3
][8] a[3][9] a[3][10] a[4][0] a[4][1] a[4][2] a[4][3] a[4][4] a[4][5]a[4][6]a[4][7] a[4 ][8] a[4][9] a[4][10]第8节　存储一个迷宫
好了，又到了本章的最后1节。我们已经学习了如何存储多行字符，但是一直忽略了一个问题，就是如何对二维字符数组进行初始化。
例如，要存储一个迷宫该怎么办？
    ###########
    #O   #  ###
    # ## ##   #
    #  #    # #
    # #### ## #
    #       #
    ###########
其实二维字符数组的初始化和一维数组的初始化差不多，我们现在
回忆一下之前是如何给一维字符数组进行初始化的：
    char a[10]={"hello"};
　　一维字符数组的初始化很简单，直接在字符串的两边加上双引号和花括号就可以。二维字符数组的初始化代码如下：
    char a[2][10]={"hello", "world"};
或者
    char a[2][10]={"hello",                     "world"};
写成两行，主要是为了美观，更形象地表现出我们是在对二维字符
数组进行初始化。
　　仔细观察后你会发现，字符数组a有两行，因此在初始化时有两个带双引号的字符串，并用逗号隔开。
　　如果要初始化本节开头的那个迷宫，我们需要定义足够大的二维字符数组，这个迷宫有7行，每行有11列。因此在定义字符数组时也要有7 行，但是每行要有12列（不要忘记每行字符串的结尾要有‘\0'）。
    char a[7][12]={"###########",                     "#O   #  ###",
                    "# ## ##   #",
                    "#  #    # #",
                    "# #### ## #",
                    "#       #  ",
                    "###########"};
现在我们可以用for循环和puts（ ）来把这个迷宫输出到屏幕上。因
为有7行，但是字符数组是从第0行开始的，所以循环变量i是从0到6。从第0行到第6行，而每1行是一个一维字符串，因此直接用puts（a[i]）就可以。代码如下：
    for(i=0; i<=6; i++)         puts(a[i]);
完整的代码如下：
    #include <stdio.h>     #include <stdlib.h>     int main( )
    {           int i;           char a[7][12]={"###########",                           "#O   #  ###",
                          "# ## ##   #",
                          "#  #    # #",
                          "# #### ## #",
                          "#       #  ",
                          "###########"};

          for(i=0; i<=6; i++)               puts(a[i]);           system("pause");           return 0;
    }

第8章游戏时间到了第1节　走迷宫
　　本节我们将学习编写一个完整的小游戏“走迷宫”。你将可以通过键盘上的“W”、“S”、“A”、“D”4个按键来控制1个“小球”向上、下、左、右移动，目的就是让这个“小球”从起点走出迷宫。来看看这个迷宫吧，如图8-1所示。图8-1　一个迷宫的例子
　　从如图8-1所示的迷宫，你会发现整个迷宫只有一个出口，其余的地方都被“栅栏”给拦住了。用字符#来表示栅栏，用大写字母O来表示小球，我们可以先来设计这个迷宫，并用二维字符数组来存储这个迷宫。
    char a[50][50]={"##############################",                     "#O         #   ##   # ### ####",
                    "# ###### # # #    # # ### ####",
                    "# #   ## #   # #### # ###   ##",
                    "#   # ##  ###    #  #  ## ####",
                    "##### #     # ##### ##    ####",
                    "#   # ##### #   #   # # #    #",
                    "# # #    ## # #### ## # # ####",
                    "# # # ##      ##      # # ####",
                    "# # # ####### ## ###### #   ##",
                    "# #   ##   # ## ###### ###   #",
                    "# ###### # #####  #        # #",
                    "#        # #     ##### ### #  ",
                    "# ######## ##### # ### ### # #",
                    "#     # ## ##### ###       ###",
                    "##### # ## #      ######## # #",
                    "#     # ## ## ###        #   #",
                    "# # ###       ###### ####### #",
                    "# #    ### ##      #         #",                     "##############################"
                    };
　　上面这段代码定义了一个20×30的迷宫。如果你觉得这个迷宫太麻烦了，我们可以先设计一个简单的迷宫，代码如下：    char a[50][50]={"######",                     "#O #  ",
                    "# ## #",
                    "#  # #",
                    "##   #",
                    "######",
                    };
迷宫定义好后，我们就要想办法将这个迷宫输出到屏幕上。
    for(i=0; i<=5; i++)         puts(a[i]);
　　上面这个for循环从0到5，共进行了6次循环，依次输出迷宫的第0～ 5行。puts（a[i]）表示输出每一行的字符串。
对上面的代码做个小结，输出迷宫的完整代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>
    int main()
    {
      char a[50][50]={"######",                       "#O #  ",
                      "# ## #",
                      "#  # #",
                      "##   #",
                      "######",                       };       int i, x, y, p, q;
      x=1; y=1; p=1; q=5;       for(i=0; i<=5; i++)           puts(a[i]);
      Sleep(5000);       return 0;
    }
　　在上面的代码中，我们用变量x和y来存储小球的初始位置，用变量 p和q来存储迷宫的出口。请注意：字符串是从0开始计数的，千万别算错了小球的初始位置及迷宫的出口位置。
现在我们就要想办法控制小球了，这里利用键盘上
的“W”“S”“A”“D”4个按键来控制这个“小球”进行上、下、左、右移动。当然如果你喜欢，也可以用别的按键。
　　第1步：先来控制小球向下移动。也就是当你按下“S”键时，小球向下移动1步。那么如何获得“S”这个按键呢，换句话说：当你按下“S”键时，我们的程序怎样知道你按的是“S”键呢？很简单，因为你按下“S”键时，本质上是输入了1个字符s，我们只需读取这个字符s就可以了。读取一个字符有4种方法：
    scanf("%c", &ch);     ch=getchar();     ch=getche();     ch=getch();
　　我们之前已经讲过这4个语句的区别了，这里并不想显示输入的字符，并且希望输入的字符可以立即被程序获得，而不用在敲击1个字符后再敲击1个“Enter”键。因此我们选用最后一个语句ch=getch（）;。
好，我们已经将在键盘上敲击的字符存储在字符变量ch中了，接下
来实现当敲击字符s时，让小球向下移动一步。
    if(ch=='s')     {         if(a[x+1][y]! ='#')
        {               a[x][y]=' ';               x++;               a[x][y]='O';         }
    }
　　在上面的这段代码中，我们通过if语句来判断刚才敲击的是否是字符s。如果是字符s，我们就让小球向下移动一步。但是在让小球向下移动之前，需要首先判断下一步是否能移动！只有下一步不是栅栏“#”时小球才能移动。
　　当if（a[x+1][y]!='#'）条件成立时，就表示下一步不是栅栏，小球可以移动。　　本来没有这一小段的。但是在实际教学中，仍然有一些二、三年级小朋友问我：“老师，为什么a[x+1][y]就表示向下走一步的格子
呢？”其实很简单：向下移动时，小球当然还在当前这个列，不过不在这一行，而是在下一行，因此向下移动是y不变，x加1。
　　如果是向右边移动，很显然还是在同一行，所以x不变。但是小球已经不在刚才的那一竖列了，而在右边的一个竖列，因此y需要加
1。总结如下：
向下移动是y不变，x加1；向上移动是y不变，x减1；向左移动是x不变，y减1；向右移动是x不变，y加1。

好了，啰嗦了好半天，我们来讲解下面这3句话的意思：
    a[x][y]=' ';     x++;     a[x][y]='O';
让小球向下移动，就是让小球原本位置上的“O”变成空格，而让下
一格变成“O”。第一句a[x][y]=' '; （注意此处两个单引号中间有一个空格）就是让小球的当前位置变为空格，x++；这句话非常重要，它表示更改小球的位置。因为小球向下运动只需要x++就可以了，y不变。最后的a[x][y]='O'；语句就是将小球新位置上的内容替换为小球“O”。
请注意：
    a[x][y]=' ';     x++;     a[x][y]='O';
可不能写成：
    a[x][y]=' ';     a[x+1][y]='O';
至于为什么，大家自己想想！
因为小球的位置有了变化，因此还需要将新迷宫的状态重新打印一
次。在打印前记得要将之前的屏幕清屏，代码如下：
    system("cls");     for(i=0; i<=5; i++)         puts(a[i]);
好了，再进行一次小结：
    #include <stdio.h>
    #include <stdlib.h>    #include <windows.h>
    int main()
    {       char a[50][50]={"######",                       "#O #  ",
                      "# ## #",
                      "#  # #",
                      "##   #",
                      "######",                       };       int i, x, y, p, q;       char ch;
      x=1; y=1; p=1; q=5;       for(i=0; i<=5; i++)           puts(a[i]);
      ch=getch();       if(ch=='s')
      {           if(a[x+1][y]! ='#')
          {               a[x][y]=' ';               x++;               a[x][y]='O';
          }
      }
      system("cls");       for(i=0; i<=5; i++)           puts(a[i]);
      Sleep(5000);       return 0;
    }
运行一下，然后按一下“S”键，是不是已经可以看到小球向下移动
一步了呢？但是你只能移动一步。如何实现连续移动呢？很简单，我们可以通过while循环来解决问题：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>
    int main()     {       char a[50][50]={"######",                       "#O #  ",
                      "# ## #",
                      "#  # #",
                      "##   #",                      "######",                       };       int i, x, y, p, q;       char ch;
      x=1; y=1; p=1; q=5;       for(i=0; i<=5; i++)           puts(a[i]);
      while(1)       {         ch=getch();
        if(ch=='s')
        {           if(a[x+1][y]! ='#')
          {               a[x][y]=' ';               x++;               a[x][y]='O';
          }         }
        system("cls");         for(i=0; i<=5; i++)             puts(a[i]);
      }
      Sleep(5000);       return 0;
    }
暂时先使用while（1）无限循环来解决这个问题。好了，运行一下
吧。此时小球是不是可以连续移动了？当然，目前小球还只能朝一个方向运动。接下来我们就来实现小球向其他3个方向的运动。
向其他3个方向移动其实和“向下移动”是差不多的，只要注意是x在
变化还是y在变化，是加1还是减1就可以了。
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>
    int main()     {       char a[50][50]={"######",                       "#O #  ",
                      "# ## #",
                      "#  # #",
                      "##   #",
                      "######",
                      };      int i, x, y, p, q;       char ch;
      x=1; y=1; p=1; q=5;       for(i=0; i<=5; i++)           puts(a[i]);
      while(1)       {         ch=getch();
        if(ch=='s')
        {             if(a[x+1][y]! ='#')
            {                 a[x][y]=' ';                 x++;                 a[x][y]='O';
            }         }
        if(ch=='w')
        {             if(a[x-1][y]! ='#')
            {                 a[x][y]=' ';                 x--;

                a[x][y]='O';
            }         }         if(ch=='a')
        {             if(a[x][y-1]! ='#')
            {                 a[x][y]=' ';                 y--;                 a[x][y]='O';
            }         }
        if(ch=='d')
        {             if(a[x][y+1]! ='#')
            {                 a[x][y]=' ';                 y++;                 a[x][y]='O';
            }         }
        system("cls");         for(i=0; i<=5; i++)             puts(a[i]);
      }
      Sleep(5000);       return 0;
    }
　　好了，你是不是已经成功地走出了迷宫？可是貌似程序并没有让你很惊喜，因为没有判定你已经成功。最后我们来写一个“获胜”的检测部分。其实只需将我们之前写的while（1）改为while（x!=p || y!=q）就可以了。还记得吗，之前我们用p和q分别存储了迷宫出口位置的坐标。当然了，在最后我们需要打印“你获胜了”。完整代码如下：
    #include <stdio.h>
    #include <stdlib.h>     #include <windows.h>
    int main()
    {       char a[50][50]={"######",                       "#O #  ",
                      "# ## #",
                      "#  # #",
                      "##   #",                       "######",
        };       int i, x, y, p, q;

      char ch;
      x=1; y=1; p=1; q=5;       for(i=0; i<=5; i++) puts(a[i]);       while(x! =p || y! =q)
      {   ch=getch();         if(ch=='s')
        {             if(a[x+1][y]! ='#')
            {                 a[x][y]=' ';                 x++;                 a[x][y]='O';
            }         }         if(ch=='w')
        {             if(a[x-1][y]! ='#')
            {                 a[x][y]=' ';                 x--;                 a[x][y]='O';
            }         }         if(ch=='a')

        {             if(a[x][y-1]! ='#')
            {                 a[x][y]=' ';                 y--;                 a[x][y]='O';
            }         }         if(ch=='d')
        {             if(a[x][y+1]! ='#')
            {                 a[x][y]=' ';                 y++;                 a[x][y]='O';
            }         }         system("cls");         for(i=0; i<=5; i++)             puts(a[i]);
      }       system("cls");       printf("You win! \n");       Sleep(5000);       return 0;
    }
　　恭喜，你已经搞定了一个完整的“走迷宫”程序，太不容易啦！当然了，也可以让迷宫更加复杂、更加好玩，赶快与你的朋友们分享吧！第2节　推箱子　　经典的推箱子游戏是一个来自日本的古老游戏，目的是训练人的逻辑思维能力。在一个狭小的仓库中，要求把木箱从开始位置推到指定位置。仓库中有障碍物，稍不小心就会出现箱子无法移动或者通道被堵住的情况，而且箱子只能推、不能拉，需要巧妙地利用有限的空间和通道，合理安排移动的次序和位置，才能顺利完成任务。没有玩过的同学可以去下载一个感受一下。
　　我们用“#”表示墙，“S”表示一个人，“O”表示箱子，“*”表示箱子需要到达的位置，一个简单的示例如下：
     ###
     #*#
     # #
  ####O######
  #*  OS O *#
  #####O#####
      # #
      #*#
      ###
用上、下、左、右方向键来控制小人“S”推动箱子并让箱子到达指
定的位置，就算胜利。
         ###
         #@#
         # #
      #### ######
      #@      S@#
      ##### #####
          # #
          #@#
          ###
再来一个：
    ##########
    ##     ###
    ##O###   #
    # S O  O #
    # ＊＊# O ##
    ##＊＊#   ##
    ##########
将所有的箱子推到指定的地方就算过关了。
    ##########
    ##     ###
    ## ###   #
    # S      #
    # @@#   ##
    ##@@#   ##
    ##########
　　好了，本书的所有内容到此就全部结束了。你是不是以为我要把“推箱子”这个游戏讲完？我想不用了，如果你是认认真真地一节一节读到这里的，我想你应该可以顺利地完成这个游戏，开启自己独立思考的编程之路。编程就如同练习武功一样，重要的是自己主动去思考，去感悟，去不断地练习。一旦打通了编程的“任督二脉”，你会发现其实编程就那么回事儿，所有的编程语言都是差不多的，一通百通。
　　最后还是感谢你能坚持读完整本书，确实不容易啊。从我2011年10 月28日在武汉循礼门星巴克写下本书的第一行语句到中途重新构思本书，这期间去掉了不实用的内容，添加了有趣的章节，再到最后全部完成，经历了一年多的时间。
目前“啊哈问答”和“啊哈挑战”已经上线，你可以通过 www.tianchai.com来进一步学习，与我和大家一起互动。
附录A 标识符命名规则附录A是根据ISO/IEC 9899:1999、维基百科和百度百科整理的。
　　标识符是用户编程时需要使用到的名字。在日常生活中，我们指定某个人或某样东西，都要用到他、她或它的名字。在编程语言中，变量、常量、函数也有名字，我们统称为标识符。在给人起名字时有一定的规矩，比如：头一个字为父亲或母亲的姓氏，后面一般为一个或两个字。在编程语言里的标识符也有一定的命名规则。
　　C语言的标识符分为三类：保留字（也称作关键字）、预定义标识符和用户标识符。
C语言（C99）的保留字如下：
char
short
int
unsigned
long
float
double
struct
union
void
enum
signed
const
volatile
typedef
auto
register
static
extern
break
case
continue
default
do
else
for
goto
if
return
switch
while
sizeof
_Bool
_Complex
_Imaginary
inline
restrict 预定义标识符是指C语言中有特定含义的标识符。例如函数printf、 scanf、sin、isalum等，以及编译预处理命令名（如define、include）
等。预定义标识符可以作为用户标识符使用，但是这样会失去系统规定的原意，我们不推荐这样做。
　　用户标识符一般是指用户自己定义的变量名和函数名等。用户在定义标识符时需要注意以下4点：
　　（1） 必须是字母（A～Z及a～z）、数字（0～9）和下画线的组合。
　　（2） 首字符不能是数字，但可以是字母或者下画线。
　　（3） 不能与保留字相同。
　　（4） 标识符对大小写敏感，即严格区分大小写。附录B 运算符的优先级和结合性
